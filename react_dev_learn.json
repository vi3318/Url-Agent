{
  "stats": {
    "pages_crawled": 20,
    "pages_failed": 0,
    "expandables_clicked": 1,
    "links_discovered": 51,
    "elapsed_time": 127.43,
    "pages_per_second": 0.16,
    "stop_reason": "MAX_PAGES limit reached (20)",
    "scope": "Subtree: react.dev/learn/**"
  },
  "hierarchy": {
    "root": {
      "Quick Start": {
        "_pages": [
          "https://react.dev/learn"
        ],
        "_children": {}
      },
      "Adding Interactivity": {
        "_pages": [
          "https://react.dev/learn/render-and-commit",
          "https://react.dev/learn/updating-arrays-in-state",
          "https://react.dev/learn/state-as-a-snapshot"
        ],
        "_children": {
          "Render and Commit": {
            "_pages": [
              "https://react.dev/learn/render-and-commit"
            ],
            "_children": {}
          },
          "Updating Arrays in State": {
            "_pages": [
              "https://react.dev/learn/updating-arrays-in-state"
            ],
            "_children": {}
          },
          "State as a Snapshot": {
            "_pages": [
              "https://react.dev/learn/state-as-a-snapshot"
            ],
            "_children": {}
          }
        }
      },
      "Describing the UI": {
        "_pages": [
          "https://react.dev/learn/your-first-component",
          "https://react.dev/learn/importing-and-exporting-components",
          "https://react.dev/learn/writing-markup-with-jsx"
        ],
        "_children": {
          "Your First Component": {
            "_pages": [
              "https://react.dev/learn/your-first-component"
            ],
            "_children": {}
          },
          "Importing and Exporting Components": {
            "_pages": [
              "https://react.dev/learn/importing-and-exporting-components"
            ],
            "_children": {}
          },
          "Writing Markup with JSX": {
            "_pages": [
              "https://react.dev/learn/writing-markup-with-jsx"
            ],
            "_children": {}
          }
        }
      },
      "Managing State": {
        "_pages": [
          "https://react.dev/learn/reacting-to-input-with-state",
          "https://react.dev/learn/extracting-state-logic-into-a-reducer"
        ],
        "_children": {
          "Reacting to Input with State": {
            "_pages": [
              "https://react.dev/learn/reacting-to-input-with-state"
            ],
            "_children": {}
          },
          "Extracting State Logic into a Reducer": {
            "_pages": [
              "https://react.dev/learn/extracting-state-logic-into-a-reducer"
            ],
            "_children": {}
          }
        }
      },
      "React Compiler": {
        "_pages": [
          "https://react.dev/learn/react-compiler/installation",
          "https://react.dev/learn/react-compiler/debugging",
          "https://react.dev/learn/react-compiler/introduction"
        ],
        "_children": {
          "Installation": {
            "_pages": [
              "https://react.dev/learn/react-compiler/installation"
            ],
            "_children": {}
          },
          "Debugging and Troubleshooting": {
            "_pages": [
              "https://react.dev/learn/react-compiler/debugging"
            ],
            "_children": {}
          },
          "Introduction": {
            "_pages": [
              "https://react.dev/learn/react-compiler/introduction"
            ],
            "_children": {}
          }
        }
      },
      "Setup": {
        "_pages": [
          "https://react.dev/learn/setup",
          "https://react.dev/learn/typescript"
        ],
        "_children": {
          "Using TypeScript": {
            "_pages": [
              "https://react.dev/learn/typescript"
            ],
            "_children": {}
          }
        }
      },
      "Escape Hatches": {
        "_pages": [
          "https://react.dev/learn/escape-hatches",
          "https://react.dev/learn/separating-events-from-effects",
          "https://react.dev/learn/you-might-not-need-an-effect",
          "https://react.dev/learn/referencing-values-with-refs",
          "https://react.dev/learn/reusing-logic-with-custom-hooks"
        ],
        "_children": {
          "Separating Events from Effects": {
            "_pages": [
              "https://react.dev/learn/separating-events-from-effects"
            ],
            "_children": {}
          },
          "You Might Not Need an Effect": {
            "_pages": [
              "https://react.dev/learn/you-might-not-need-an-effect"
            ],
            "_children": {}
          },
          "Referencing Values with Refs": {
            "_pages": [
              "https://react.dev/learn/referencing-values-with-refs"
            ],
            "_children": {}
          },
          "Reusing Logic with Custom Hooks": {
            "_pages": [
              "https://react.dev/learn/reusing-logic-with-custom-hooks"
            ],
            "_children": {}
          }
        }
      },
      "Installation": {
        "_pages": [
          "https://react.dev/learn/build-a-react-app-from-scratch"
        ],
        "_children": {
          "Build a React App from Scratch": {
            "_pages": [
              "https://react.dev/learn/build-a-react-app-from-scratch"
            ],
            "_children": {}
          }
        }
      }
    },
    "pages": {
      "https://react.dev/learn": {
        "title": "Quick Start",
        "section_path": [
          "Quick Start"
        ],
        "depth": 0
      },
      "https://react.dev/learn/render-and-commit": {
        "title": "Render and Commit",
        "section_path": [
          "Adding Interactivity",
          "Render and Commit"
        ],
        "depth": 1
      },
      "https://react.dev/learn/your-first-component": {
        "title": "Your First Component",
        "section_path": [
          "Describing the UI",
          "Your First Component"
        ],
        "depth": 1
      },
      "https://react.dev/learn/reacting-to-input-with-state": {
        "title": "Reacting to Input with State",
        "section_path": [
          "Managing State",
          "Reacting to Input with State"
        ],
        "depth": 1
      },
      "https://react.dev/learn/react-compiler/installation": {
        "title": "Installation",
        "section_path": [
          "React Compiler",
          "Installation"
        ],
        "depth": 1
      },
      "https://react.dev/learn/setup": {
        "title": "Setup",
        "section_path": [
          "Setup"
        ],
        "depth": 1
      },
      "https://react.dev/learn/escape-hatches": {
        "title": "Escape Hatches",
        "section_path": [
          "Escape Hatches"
        ],
        "depth": 1
      },
      "https://react.dev/learn/react-compiler/debugging": {
        "title": "Debugging and Troubleshooting",
        "section_path": [
          "React Compiler",
          "Debugging and Troubleshooting"
        ],
        "depth": 1
      },
      "https://react.dev/learn/updating-arrays-in-state": {
        "title": "Updating Arrays in State",
        "section_path": [
          "Adding Interactivity",
          "Updating Arrays in State"
        ],
        "depth": 1
      },
      "https://react.dev/learn/separating-events-from-effects": {
        "title": "Separating Events from Effects",
        "section_path": [
          "Escape Hatches",
          "Separating Events from Effects"
        ],
        "depth": 1
      },
      "https://react.dev/learn/state-as-a-snapshot": {
        "title": "State as a Snapshot",
        "section_path": [
          "Adding Interactivity",
          "State as a Snapshot"
        ],
        "depth": 1
      },
      "https://react.dev/learn/build-a-react-app-from-scratch": {
        "title": "Build a React app from Scratch",
        "section_path": [
          "Installation",
          "Build a React App from Scratch"
        ],
        "depth": 1
      },
      "https://react.dev/learn/you-might-not-need-an-effect": {
        "title": "You Might Not Need an Effect",
        "section_path": [
          "Escape Hatches",
          "You Might Not Need an Effect"
        ],
        "depth": 1
      },
      "https://react.dev/learn/importing-and-exporting-components": {
        "title": "Importing and Exporting Components",
        "section_path": [
          "Describing the UI",
          "Importing and Exporting Components"
        ],
        "depth": 1
      },
      "https://react.dev/learn/extracting-state-logic-into-a-reducer": {
        "title": "Extracting State Logic into a Reducer",
        "section_path": [
          "Managing State",
          "Extracting State Logic into a Reducer"
        ],
        "depth": 1
      },
      "https://react.dev/learn/typescript": {
        "title": "Using TypeScript",
        "section_path": [
          "Setup",
          "Using TypeScript"
        ],
        "depth": 1
      },
      "https://react.dev/learn/writing-markup-with-jsx": {
        "title": "Writing Markup with JSX",
        "section_path": [
          "Describing the UI",
          "Writing Markup with JSX"
        ],
        "depth": 1
      },
      "https://react.dev/learn/referencing-values-with-refs": {
        "title": "Referencing Values with Refs",
        "section_path": [
          "Escape Hatches",
          "Referencing Values with Refs"
        ],
        "depth": 1
      },
      "https://react.dev/learn/reusing-logic-with-custom-hooks": {
        "title": "Reusing Logic with Custom Hooks",
        "section_path": [
          "Escape Hatches",
          "Reusing Logic with Custom Hooks"
        ],
        "depth": 1
      },
      "https://react.dev/learn/react-compiler/introduction": {
        "title": "Introduction",
        "section_path": [
          "React Compiler",
          "Introduction"
        ],
        "depth": 1
      }
    }
  },
  "pages": [
    {
      "url": "https://react.dev/learn",
      "title": "Quick Start",
      "breadcrumb": [],
      "section_path": [
        "Quick Start"
      ],
      "headings": {
        "h1": [
          "Quick Start"
        ],
        "h2": [
          "Creating and nesting components",
          "Writing markup with JSX",
          "Adding styles",
          "Displaying data",
          "Conditional rendering",
          "Rendering lists",
          "Responding to events",
          "Updating the screen",
          "Using Hooks",
          "Sharing data between components",
          "Next Steps"
        ],
        "h3": [
          "You will learn"
        ]
      },
      "text_content": "LEARN REACT\nQuick Start\n\nWelcome to the React documentation! This page will give you an introduction to 80% of the React concepts that you will use on a daily basis.\n\nYou will learn\nHow to create and nest components\nHow to add markup and styles\nHow to display data\nHow to render conditions and lists\nHow to respond to events and update the screen\nHow to share data between components\nCreating and nesting components \n\nReact apps are made out of components. A component is a piece of the UI (user interface) that has its own logic and appearance. A component can be as small as a button, or as large as an entire page.\n\nReact components are JavaScript functions that return markup:\n\nfunction MyButton() {\n\n return (\n\n <button>I'm a button</button>\n\n );\n\n}\n\nNow that you‚Äôve declared MyButton, you can nest it into another component:\n\nexport default function MyApp() {\n\n return (\n\n <div>\n\n <h1>Welcome to my app</h1>\n\n <MyButton />\n\n </div>\n\n );\n\n}\n\nNotice that <MyButton /> starts with a capital letter. That‚Äôs how you know it‚Äôs a React component. React component names must always start with a capital letter, while HTML tags must be lowercase.\n\nHave a look at the result:\n\nApp.js\nDownload\nReload\nClear\nFork\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nfunction MyButton() {\n return (\n <button>\n I'm a button\n </button>\n );\n}\n\nexport default function MyApp() {\n return (\n <div>\n <h1>Welcome to my app</h1>\n <MyButton />\n </div>\n );\n}\n\nShow more\n\nThe export default keywords specify the main component in the file. If you‚Äôre not familiar with some piece of JavaScript syntax, MDN and javascript.info have great references.\n\nWriting markup with JSX \n\nThe markup syntax you‚Äôve seen above is called JSX. It is optional, but most React projects use JSX for its convenience. All of the tools we recommend for local development support JSX out of the box.\n\nJSX is stricter than HTML. You have to close tags like <br />. Your component also can‚Äôt return multiple JSX tags. You have to wrap them into a shared parent, like a <div>...</div> or an empty <>...</> wrapper:\n\nfunction AboutPage() {\n\n return (\n\n <>\n\n <h1>About</h1>\n\n <p>Hello there.<br />How do you do?</p>\n\n </>\n\n );\n\n}\n\nIf you have a lot of HTML to port to JSX, you can use an online converter.\n\nAdding styles \n\nIn React, you specify a CSS class with className. It works the same way as the HTML class attribute:\n\n<img className=\"avatar\" />\n\nThen you write the CSS rules for it in a separate CSS file:\n\n/* In your CSS */\n\n.avatar {\n\n border-radius: 50%;\n\n}\n\nReact does not prescribe how you add CSS files. In the simplest case, you‚Äôll add a <link> tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project.\n\nDisplaying data \n\nJSX lets you put markup into JavaScript. Curly braces let you ‚Äúescape back‚Äù into JavaScript so that you can embed some variable from your code and display it to the user. For example, this will display user.name:\n\nreturn (\n\n <h1>\n\n {user.name}\n\n </h1>\n\n);\n\nYou can also ‚Äúescape into JavaScript‚Äù from JSX attributes, but you have to use curly braces instead of quotes. For example, className=\"avatar\" passes the \"avatar\" string as the CSS class, but src={user.imageUrl} reads the JavaScript user.imageUrl variable value, and then passes that value as the src attribute:\n\nreturn (\n\n <img\n\n className=\"avatar\"\n\n src={user.imageUrl}\n\n />\n\n);\n\nYou can put more complex expressions inside the JSX curly braces too, for example, string concatenation:\n\nApp.js\nDownload\nReload\nClear\nFork\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nconst user = {\n name: 'Hedy Lamarr',\n imageUrl: 'https://i.imgur.com/yXOvdOSs.jpg',\n imageSize: 90,\n};\n\nexport default function Profile() {\n return (\n <>\n <h1>{user.name}</h1>\n <img\n className=\"avatar\"\n src={user.imageUrl}\n alt={'Photo of ' + user.name}\n style={{\n width: user.imageSize,\n height: user.imageSize\n }}\n />\n </>\n );\n}\n\nShow more\n\nIn the above example, style={{}} is not a special syntax, but a regular {} object inside the style={ } JSX curly braces. You can use the style attribute when your styles depend on JavaScript variables.\n\nConditional rendering \n\nIn React, there is no special syntax for writing conditions. Instead, you‚Äôll use the same techniques as you use when writing regular JavaScript code. For example, you can use an if statement to conditionally include JSX:\n\nlet content;\n\nif (isLoggedIn) {\n\n content = <AdminPanel />;\n\n} else {\n\n content = <LoginForm />;\n\n}\n\nreturn (\n\n <div>\n\n {content}\n\n </div>\n\n);\n\nIf you prefer more compact code, you can use the conditional ? operator. Unlike if, it works inside JSX:\n\n<div>\n\n {isLoggedIn ? (\n\n <AdminPanel />\n\n ) : (\n\n <LoginForm />\n\n )}\n\n</div>\n\nWhen you don‚Äôt need the else branch, you can also use a shorter logical && syntax:\n\n<div>\n\n {isLoggedIn && <AdminPanel />}\n\n</div>\n\nAll of these approaches also work for conditionally specifying attributes. If you‚Äôre unfamiliar with some of this JavaScript syntax, you can start by always using if...else.\n\nRendering lists \n\nYou will rely on JavaScript features like for loop and the array map() function to render lists of components.\n\nFor example, let‚Äôs say you have an array of products:\n\nconst products = [\n\n { title: 'Cabbage', id: 1 },\n\n { title: 'Garlic', id: 2 },\n\n { title: 'Apple', id: 3 },\n\n];\n\nInside your component, use the map() function to transform an array of products into an array of <li> items:\n\nconst listItems = products.map(product =>\n\n <li key={product.id}>\n\n {product.title}\n\n </li>\n\n);\n\nreturn (\n\n <ul>{listItems}</ul>\n\n);\n\nNotice how <li> has a key attribute. For each item in a list, you should pass a string or a number that uniquely identifies that item among its siblings. Usually, a key should be coming from your data, such as a database ID. React uses your keys to know what happened if you later insert, delete, or reorder the items.\n\nApp.js\nDownload\nReload\nClear\nFork\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nconst products = [\n { title: 'Cabbage', isFruit: false, id: 1 },\n { title: 'Garlic', isFruit: false, id: 2 },\n { title: 'Apple', isFruit: true, id: 3 },\n];\n\nexport default function ShoppingList() {\n const listItems = products.map(product =>\n <li\n key={product.id}\n style={{\n color: product.isFruit ? 'magenta' : 'darkgreen'\n }}\n >\n {product.title}\n </li>\n );\n\n return (\n <ul>{listItems}</ul>\n );\n}\n\nShow more\nResponding to events \n\nYou can respond to events by declaring event handler functions inside your components:\n\nfunction MyButton() {\n\n function handleClick() {\n\n alert('You clicked me!');\n\n }\n\n return (\n\n <button onClick={handleClick}>\n\n Click me\n\n </button>\n\n );\n\n}\n\nNotice how onClick={handleClick} has no parentheses at the end! Do not call the event handler function: you only need to pass it down. React will call your event handler when the user clicks the button.\n\nUpdating the screen \n\nOften, you‚Äôll want your component to ‚Äúremember‚Äù some information and display it. For example, maybe you want to count the number of times a button is clicked. To do this, add state to your component.\n\nFirst, import useState from React:\n\nimport { useState } from 'react';\n\nNow you can declare a state variable inside your component:\n\nfunction MyButton() {\n\n const [count, setCount] = useState(0);\n\n // ...\n\nYou‚Äôll get two things from useState: the current state (count), and the function that lets you update it (setCount). You can give them any names, but the convention is to write [something, setSomething].\n\nThe first time the button is displayed, count will be 0 because you passed 0 to useState(). When you want to change state, call setCount() and pass the new value to it. Clicking this button will increment the counter:\n\nfunction MyButton() {\n\n const [count, setCount] = useState(0);\n\n function handleClick() {\n\n setCount(count + 1);\n\n }\n\n return (\n\n <button onClick={handleClick}>\n\n Clicked {count} times\n\n </button>\n\n );\n\n}\n\nReact will call your component function again. This time, count will be 1. Then it will be 2. And so on.\n\nIf you render the same component multiple times, each will get its own state. Click each button separately:\n\nApp.js\nDownload\nReload\nClear\nFork\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nimport { useState } from 'react';\n\nexport default function MyApp() {\n return (\n <div>\n <h1>Counters that update separately</h1>\n <MyButton />\n <MyButton />\n </div>\n );\n}\n\nfunction MyButton() {\n const [count, setCount] = useState(0);\n\n function handleClick() {\n setCount(count + 1);\n }\n\n return (\n <button onClick={handleClick}>\n Clicked {count} times\n </button>\n );\n}\n\nShow more\n\nNotice how each button ‚Äúremembers‚Äù its own count state and doesn‚Äôt affect other buttons.\n\nUsing Hooks \n\nFunctions starting with use are called Hooks. useState is a built-in Hook provided by React. You can find other built-in Hooks in the API reference. You can also write your own Hooks by combining the existing ones.\n\nHooks are more restrictive than other functions. You can only call Hooks at the top of your components (or other Hooks). If you want to use useState in a condition or a loop, extract a new component and put it there.\n\nSharing data between components \n\nIn the previous example, each MyButton had its own independent count, and when each button was clicked, only the count for the button clicked changed:\n\nInitially, each MyButton‚Äôs count state is 0\n\nThe first MyButton updates its count to 1\n\nHowever, often you‚Äôll need components to share data and always update together.\n\nTo make both MyButton components display the same count and update together, you need to move the state from the individual buttons ‚Äúupwards‚Äù to the closest component containing all of them.\n\nIn this example, it is MyApp:\n\nInitially, MyApp‚Äôs count state is 0 and is passed down to both children\n\nOn click, MyApp updates its count state to 1 and passes it down to both children\n\nNow when you click either button, the count in MyApp will change, which will change both of the counts in MyButton. Here‚Äôs how you can express this in code.\n\nFirst, move the state up from MyButton into MyApp:\n\nexport default function MyApp() {\n\n const [count, setCount] = useState(0);\n\n function handleClick() {\n\n setCount(count + 1);\n\n }\n\n return (\n\n <div>\n\n <h1>Counters that update separately</h1>\n\n <MyButton />\n\n <MyButton />\n\n </div>\n\n );\n\n}\n\nfunction MyButton() {\n\n // ... we're moving code from here ...\n\n}\n\nThen, pass the state down from MyApp to each MyButton, together with the shared click handler. You can pass information to MyButton using the JSX curly braces, just like you previously did with built-in tags like <img>:\n\nexport default function MyApp() {\n\n const [count, setCount] = useState(0);\n\n function handleClick() {\n\n setCount(count + 1);\n\n }\n\n return (\n\n <div>\n\n <h1>Counters that update together</h1>\n\n <MyButton count={count} onClick={handleClick} />\n\n <MyButton count={count} onClick={handleClick} />\n\n </div>\n\n );\n\n}\n\nThe information you pass down like this is called props. Now the MyApp component contains the count state and the handleClick event handler, and passes both of them down as props to each of the buttons.\n\nFinally, change MyButton to read the props you have passed from its parent component:\n\nfunction MyButton({ count, onClick }) {\n\n return (\n\n <button onClick={onClick}>\n\n Clicked {count} times\n\n </button>\n\n );\n\n}\n\nWhen you click the button, the onClick handler fires. Each button‚Äôs onClick prop was set to the handleClick function inside MyApp, so the code inside of it runs. That code calls setCount(count + 1), incrementing the count state variable. The new count value is passed as a prop to each button, so they all show the new value. This is called ‚Äúlifting state up‚Äù. By moving state up, you‚Äôve shared it between components.\n\nApp.js\nDownload\nReload\nClear\nFork\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nimport { useState } from 'react';\n\nexport default function MyApp() {\n const [count, setCount] = useState(0);\n\n function handleClick() {\n setCount(count + 1);\n }\n\n return (\n <div>\n <h1>Counters that update together</h1>\n <MyButton count={count} onClick={handleClick} />\n <MyButton count={count} onClick={handleClick} />\n </div>\n );\n}\n\nfunction MyButton({ count, onClick }) {\n return (\n <button onClick={onClick}>\n Clicked {count} times\n </button>\n );\n}\n\nShow more\nNext Steps \n\nBy now, you know the basics of how to write React code!\n\nCheck out the Tutorial to put them into practice and build your first mini-app with React.\n\nNEXT\nTutorial: Tic-Tac-Toe",
      "tables": [],
      "code_blocks": [
        "function MyButton() {\n\n  return (\n\n    <button>I'm a button</button>\n\n  );\n\n}",
        "function MyButton() {\n\n  return (\n\n    <button>I'm a button</button>\n\n  );\n\n}",
        "export default function MyApp() {\n\n  return (\n\n    <div>\n\n      <h1>Welcome to my app</h1>\n\n      <MyButton />\n\n    </div>\n\n  );\n\n}",
        "export default function MyApp() {\n\n  return (\n\n    <div>\n\n      <h1>Welcome to my app</h1>\n\n      <MyButton />\n\n    </div>\n\n  );\n\n}",
        "<MyButton />",
        "export default",
        "<div>...</div>",
        "function AboutPage() {\n\n  return (\n\n    <>\n\n      <h1>About</h1>\n\n      <p>Hello there.<br />How do you do?</p>\n\n    </>\n\n  );\n\n}",
        "function AboutPage() {\n\n  return (\n\n    <>\n\n      <h1>About</h1>\n\n      <p>Hello there.<br />How do you do?</p>\n\n    </>\n\n  );\n\n}",
        "<img className=\"avatar\" />",
        "<img className=\"avatar\" />",
        "/* In your CSS */\n\n.avatar {\n\n  border-radius: 50%;\n\n}",
        "/* In your CSS */\n\n.avatar {\n\n  border-radius: 50%;\n\n}",
        "return (\n\n  <h1>\n\n    {user.name}\n\n  </h1>\n\n);",
        "return (\n\n  <h1>\n\n    {user.name}\n\n  </h1>\n\n);",
        "className=\"avatar\"",
        "src={user.imageUrl}",
        "user.imageUrl",
        "return (\n\n  <img\n\n    className=\"avatar\"\n\n    src={user.imageUrl}\n\n  />\n\n);",
        "return (\n\n  <img\n\n    className=\"avatar\"\n\n    src={user.imageUrl}\n\n  />\n\n);",
        "let content;\n\nif (isLoggedIn) {\n\n  content = <AdminPanel />;\n\n} else {\n\n  content = <LoginForm />;\n\n}\n\nreturn (\n\n  <div>\n\n    {content}\n\n  </div>\n\n);",
        "let content;\n\nif (isLoggedIn) {\n\n  content = <AdminPanel />;\n\n} else {\n\n  content = <LoginForm />;\n\n}\n\nreturn (\n\n  <div>\n\n    {content}\n\n  </div>\n\n);",
        "<div>\n\n  {isLoggedIn ? (\n\n    <AdminPanel />\n\n  ) : (\n\n    <LoginForm />\n\n  )}\n\n</div>",
        "<div>\n\n  {isLoggedIn ? (\n\n    <AdminPanel />\n\n  ) : (\n\n    <LoginForm />\n\n  )}\n\n</div>",
        "<div>\n\n  {isLoggedIn && <AdminPanel />}\n\n</div>",
        "<div>\n\n  {isLoggedIn && <AdminPanel />}\n\n</div>",
        "const products = [\n\n  { title: 'Cabbage', id: 1 },\n\n  { title: 'Garlic', id: 2 },\n\n  { title: 'Apple', id: 3 },\n\n];",
        "const products = [\n\n  { title: 'Cabbage', id: 1 },\n\n  { title: 'Garlic', id: 2 },\n\n  { title: 'Apple', id: 3 },\n\n];",
        "const listItems = products.map(product =>\n\n  <li key={product.id}>\n\n    {product.title}\n\n  </li>\n\n);\n\n\n\nreturn (\n\n  <ul>{listItems}</ul>\n\n);",
        "const listItems = products.map(product =>\n\n  <li key={product.id}>\n\n    {product.title}\n\n  </li>\n\n);\n\n\n\nreturn (\n\n  <ul>{listItems}</ul>\n\n);",
        "function MyButton() {\n\n  function handleClick() {\n\n    alert('You clicked me!');\n\n  }\n\n\n\n  return (\n\n    <button onClick={handleClick}>\n\n      Click me\n\n    </button>\n\n  );\n\n}",
        "function MyButton() {\n\n  function handleClick() {\n\n    alert('You clicked me!');\n\n  }\n\n\n\n  return (\n\n    <button onClick={handleClick}>\n\n      Click me\n\n    </button>\n\n  );\n\n}",
        "onClick={handleClick}",
        "import { useState } from 'react';",
        "import { useState } from 'react';",
        "function MyButton() {\n\n  const [count, setCount] = useState(0);\n\n  // ...",
        "function MyButton() {\n\n  const [count, setCount] = useState(0);\n\n  // ...",
        "[something, setSomething]",
        "function MyButton() {\n\n  const [count, setCount] = useState(0);\n\n\n\n  function handleClick() {\n\n    setCount(count + 1);\n\n  }\n\n\n\n  return (\n\n    <button onClick={handleClick}>\n\n      Clicked {count} times\n\n    </button>\n\n  );\n\n}",
        "function MyButton() {\n\n  const [count, setCount] = useState(0);\n\n\n\n  function handleClick() {\n\n    setCount(count + 1);\n\n  }\n\n\n\n  return (\n\n    <button onClick={handleClick}>\n\n      Clicked {count} times\n\n    </button>\n\n  );\n\n}",
        "export default function MyApp() {\n\n  const [count, setCount] = useState(0);\n\n\n\n  function handleClick() {\n\n    setCount(count + 1);\n\n  }\n\n\n\n  return (\n\n    <div>\n\n      <h1>Counters that update separately</h1>\n\n      <MyButton />\n\n      <MyButton />\n\n    </div>\n\n  );\n\n}\n\n\n\nfunction MyButton() {\n\n  // ... we're moving code from here ...\n\n}",
        "export default function MyApp() {\n\n  const [count, setCount] = useState(0);\n\n\n\n  function handleClick() {\n\n    setCount(count + 1);\n\n  }\n\n\n\n  return (\n\n    <div>\n\n      <h1>Counters that update separately</h1>\n\n      <MyButton />\n\n      <MyButton />\n\n    </div>\n\n  );\n\n}\n\n\n\nfunction MyButton() {\n\n  // ... we're moving code from here ...\n\n}",
        "export default function MyApp() {\n\n  const [count, setCount] = useState(0);\n\n\n\n  function handleClick() {\n\n    setCount(count + 1);\n\n  }\n\n\n\n  return (\n\n    <div>\n\n      <h1>Counters that update together</h1>\n\n      <MyButton count={count} onClick={handleClick} />\n\n      <MyButton count={count} onClick={handleClick} />\n\n    </div>\n\n  );\n\n}",
        "export default function MyApp() {\n\n  const [count, setCount] = useState(0);\n\n\n\n  function handleClick() {\n\n    setCount(count + 1);\n\n  }\n\n\n\n  return (\n\n    <div>\n\n      <h1>Counters that update together</h1>\n\n      <MyButton count={count} onClick={handleClick} />\n\n      <MyButton count={count} onClick={handleClick} />\n\n    </div>\n\n  );\n\n}",
        "handleClick",
        "function MyButton({ count, onClick }) {\n\n  return (\n\n    <button onClick={onClick}>\n\n      Clicked {count} times\n\n    </button>\n\n  );\n\n}",
        "function MyButton({ count, onClick }) {\n\n  return (\n\n    <button onClick={onClick}>\n\n      Clicked {count} times\n\n    </button>\n\n  );\n\n}",
        "handleClick",
        "setCount(count + 1)"
      ],
      "internal_links": [
        "https://react.dev/learn/render-and-commit",
        "https://react.dev/learn/your-first-component",
        "https://react.dev/learn/reacting-to-input-with-state",
        "https://react.dev/learn/react-compiler/installation",
        "https://react.dev/learn/setup",
        "https://react.dev/learn/escape-hatches",
        "https://react.dev/learn",
        "https://react.dev/learn/react-compiler/debugging",
        "https://react.dev/learn/updating-arrays-in-state",
        "https://react.dev/learn/separating-events-from-effects",
        "https://react.dev/learn/state-as-a-snapshot",
        "https://react.dev/learn/build-a-react-app-from-scratch",
        "https://react.dev/learn/you-might-not-need-an-effect",
        "https://react.dev/learn/importing-and-exporting-components",
        "https://react.dev/learn/extracting-state-logic-into-a-reducer",
        "https://react.dev/learn/typescript",
        "https://react.dev/learn/writing-markup-with-jsx",
        "https://react.dev/learn/referencing-values-with-refs",
        "https://react.dev/learn/reusing-logic-with-custom-hooks",
        "https://react.dev/learn/react-compiler/introduction",
        "https://react.dev/learn/describing-the-ui",
        "https://react.dev/learn/passing-props-to-a-component",
        "https://react.dev/learn/updating-objects-in-state",
        "https://react.dev/learn/state-a-components-memory",
        "https://react.dev/learn/manipulating-the-dom-with-refs",
        "https://react.dev/learn/editor-setup",
        "https://react.dev/learn/passing-data-deeply-with-context",
        "https://react.dev/learn/lifecycle-of-reactive-effects",
        "https://react.dev/learn/conditional-rendering",
        "https://react.dev/learn/react-compiler",
        "https://react.dev/learn/understanding-your-ui-as-a-tree",
        "https://react.dev/learn/tutorial-tic-tac-toe",
        "https://react.dev/learn/add-react-to-an-existing-project",
        "https://react.dev/learn/react-compiler/incremental-adoption",
        "https://react.dev/learn/sharing-state-between-components",
        "https://react.dev/learn/thinking-in-react",
        "https://react.dev/learn/scaling-up-with-reducer-and-context",
        "https://react.dev/learn/queueing-a-series-of-state-updates",
        "https://react.dev/learn/managing-state",
        "https://react.dev/learn/choosing-the-state-structure",
        "https://react.dev/learn/synchronizing-with-effects",
        "https://react.dev/learn/removing-effect-dependencies",
        "https://react.dev/learn/react-developer-tools",
        "https://react.dev/learn/installation",
        "https://react.dev/learn/responding-to-events",
        "https://react.dev/learn/preserving-and-resetting-state",
        "https://react.dev/learn/creating-a-react-app",
        "https://react.dev/learn/javascript-in-jsx-with-curly-braces",
        "https://react.dev/learn/keeping-components-pure",
        "https://react.dev/learn/adding-interactivity",
        "https://react.dev/learn/rendering-lists"
      ],
      "parent_url": "",
      "depth": 0,
      "word_count": 2066
    },
    {
      "url": "https://react.dev/learn/render-and-commit",
      "title": "Render and Commit",
      "breadcrumb": [],
      "section_path": [
        "Adding Interactivity",
        "Render and Commit"
      ],
      "headings": {
        "h1": [
          "Render and Commit"
        ],
        "h2": [
          "Step 1: Trigger a render",
          "Step 2: React renders your components",
          "Step 3: React commits changes to the DOM",
          "Epilogue: Browser paint",
          "Recap"
        ],
        "h3": [
          "You will learn",
          "Initial render",
          "Re-renders when state updates",
          "Pitfall"
        ],
        "h4": [
          "Optimizing performance"
        ],
        "h5": [
          "DEEP DIVE"
        ]
      },
      "text_content": "LEARN REACT\nADDING INTERACTIVITY\nRender and Commit\n\nBefore your components are displayed on screen, they must be rendered by React. Understanding the steps in this process will help you think about how your code executes and explain its behavior.\n\nYou will learn\nWhat rendering means in React\nWhen and why React renders a component\nThe steps involved in displaying a component on screen\nWhy rendering does not always produce a DOM update\n\nImagine that your components are cooks in the kitchen, assembling tasty dishes from ingredients. In this scenario, React is the waiter who puts in requests from customers and brings them their orders. This process of requesting and serving UI has three steps:\n\nTriggering a render (delivering the guest‚Äôs order to the kitchen)\nRendering the component (preparing the order in the kitchen)\nCommitting to the DOM (placing the order on the table)\nTrigger\nRender\nCommit\n\nIllustrated by Rachel Lee Nabors\n\nStep 1: Trigger a render \n\nThere are two reasons for a component to render:\n\nIt‚Äôs the component‚Äôs initial render.\nThe component‚Äôs (or one of its ancestors‚Äô) state has been updated.\nInitial render \n\nWhen your app starts, you need to trigger the initial render. Frameworks and sandboxes sometimes hide this code, but it‚Äôs done by calling createRoot with the target DOM node, and then calling its render method with your component:\n\nindex.js\nImage.js\nReload\nClear\nFork\nimport Image from './Image.js';\nimport { createRoot } from 'react-dom/client';\n\nconst root = createRoot(document.getElementById('root'))\nroot.render(<Image />);\n\nTry commenting out the root.render() call and see the component disappear!\n\nRe-renders when state updates \n\nOnce the component has been initially rendered, you can trigger further renders by updating its state with the set function. Updating your component‚Äôs state automatically queues a render. (You can imagine these as a restaurant guest ordering tea, dessert, and all sorts of things after putting in their first order, depending on the state of their thirst or hunger.)\n\nState update...\n...triggers...\n...render!\n\nIllustrated by Rachel Lee Nabors\n\nStep 2: React renders your components \n\nAfter you trigger a render, React calls your components to figure out what to display on screen. ‚ÄúRendering‚Äù is React calling your components.\n\nOn initial render, React will call the root component.\nFor subsequent renders, React will call the function component whose state update triggered the render.\n\nThis process is recursive: if the updated component returns some other component, React will render that component next, and if that component also returns something, it will render that component next, and so on. The process will continue until there are no more nested components and React knows exactly what should be displayed on screen.\n\nIn the following example, React will call Gallery() and Image() several times:\n\nindex.js\nGallery.js\nReload\nClear\nFork\nexport default function Gallery() {\n return (\n <section>\n <h1>Inspiring Sculptures</h1>\n <Image />\n <Image />\n <Image />\n </section>\n );\n}\n\nfunction Image() {\n return (\n <img\n src=\"https://i.imgur.com/ZF6s192.jpg\"\n alt=\"'Floralis Gen√©rica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals\"\n />\n );\n}\n\nShow more\nDuring the initial render, React will create the DOM nodes for <section>, <h1>, and three <img> tags.\nDuring a re-render, React will calculate which of their properties, if any, have changed since the previous render. It won‚Äôt do anything with that information until the next step, the commit phase.\nPitfall\n\nRendering must always be a pure calculation:\n\nSame inputs, same output. Given the same inputs, a component should always return the same JSX. (When someone orders a salad with tomatoes, they should not receive a salad with onions!)\nIt minds its own business. It should not change any objects or variables that existed before rendering. (One order should not change anyone else‚Äôs order.)\n\nOtherwise, you can encounter confusing bugs and unpredictable behavior as your codebase grows in complexity. When developing in ‚ÄúStrict Mode‚Äù, React calls each component‚Äôs function twice, which can help surface mistakes caused by impure functions.\n\nDEEP DIVE\nOptimizing performance \nShow Details\nStep 3: React commits changes to the DOM \n\nAfter rendering (calling) your components, React will modify the DOM.\n\nFor the initial render, React will use the appendChild() DOM API to put all the DOM nodes it has created on screen.\nFor re-renders, React will apply the minimal necessary operations (calculated while rendering!) to make the DOM match the latest rendering output.\n\nReact only changes the DOM nodes if there‚Äôs a difference between renders. For example, here is a component that re-renders with different props passed from its parent every second. Notice how you can add some text into the <input>, updating its value, but the text doesn‚Äôt disappear when the component re-renders:\n\nClock.js\nReload\nClear\nFork\nexport default function Clock({ time }) {\n return (\n <>\n <h1>{time}</h1>\n <input />\n </>\n );\n}\n\nThis works because during this last step, React only updates the content of <h1> with the new time. It sees that the <input> appears in the JSX in the same place as last time, so React doesn‚Äôt touch the <input>‚Äîor its value!\n\nEpilogue: Browser paint \n\nAfter rendering is done and React updated the DOM, the browser will repaint the screen. Although this process is known as ‚Äúbrowser rendering‚Äù, we‚Äôll refer to it as ‚Äúpainting‚Äù to avoid confusion throughout the docs.\n\nIllustrated by Rachel Lee Nabors\n\nRecap\nAny screen update in a React app happens in three steps:\nTrigger\nRender\nCommit\nYou can use Strict Mode to find mistakes in your components\nReact does not touch the DOM if the rendering result is the same as last time\nPREVIOUS\nState: A Component's Memory\nNEXT\nState as a Snapshot",
      "tables": [],
      "code_blocks": [
        "import Image from './Image.js';\nimport { createRoot } from 'react-dom/client';\n\nconst root = createRoot(document.getElementById('root'))\nroot.render(<Image />);",
        "root.render()",
        "export default function Gallery() {\n  return (\n    <section>\n      <h1>Inspiring Sculptures</h1>\n      <Image />\n      <Image />\n      <Image />\n    </section>\n  );\n}\n\nfunction Image() {\n  return (\n    <img\n      src=\"https://i.imgur.com/ZF6s192.jpg\"\n      alt=\"'Floralis Gen√©rica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals\"\n    />\n  );\n}",
        "appendChild()",
        "export default function Clock({ time }) {\n  return (\n    <>\n      <h1>{time}</h1>\n      <input />\n    </>\n  );\n}"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 917
    },
    {
      "url": "https://react.dev/learn/your-first-component",
      "title": "Your First Component",
      "breadcrumb": [],
      "section_path": [
        "Describing the UI",
        "Your First Component"
      ],
      "headings": {
        "h1": [
          "Your First Component"
        ],
        "h2": [
          "Components: UI building blocks",
          "Defining a component",
          "Using a component",
          "Recap",
          "Try out some challenges"
        ],
        "h3": [
          "You will learn",
          "Step 1: Export the component",
          "Step 2: Define the function",
          "Pitfall",
          "Step 3: Add markup",
          "Pitfall",
          "What the browser sees",
          "Nesting and organizing components",
          "Pitfall"
        ],
        "h4": [
          "Components all the way down",
          "Challenge 1 of 4: Export the component"
        ],
        "h5": [
          "DEEP DIVE"
        ]
      },
      "text_content": "LEARN REACT\nDESCRIBING THE UI\nYour First Component\n\nComponents are one of the core concepts of React. They are the foundation upon which you build user interfaces (UI), which makes them the perfect place to start your React journey!\n\nYou will learn\nWhat a component is\nWhat role components play in a React application\nHow to write your first React component\nComponents: UI building blocks \n\nOn the Web, HTML lets us create rich structured documents with its built-in set of tags like <h1> and <li>:\n\n<article>\n\n <h1>My First Component</h1>\n\n <ol>\n\n <li>Components: UI Building Blocks</li>\n\n <li>Defining a Component</li>\n\n <li>Using a Component</li>\n\n </ol>\n\n</article>\n\nThis markup represents this article <article>, its heading <h1>, and an (abbreviated) table of contents as an ordered list <ol>. Markup like this, combined with CSS for style, and JavaScript for interactivity, lies behind every sidebar, avatar, modal, dropdown‚Äîevery piece of UI you see on the Web.\n\nReact lets you combine your markup, CSS, and JavaScript into custom ‚Äúcomponents‚Äù, reusable UI elements for your app. The table of contents code you saw above could be turned into a <TableOfContents /> component you could render on every page. Under the hood, it still uses the same HTML tags like <article>, <h1>, etc.\n\nJust like with HTML tags, you can compose, order and nest components to design whole pages. For example, the documentation page you‚Äôre reading is made out of React components:\n\n<PageLayout>\n\n <NavigationHeader>\n\n <SearchBar />\n\n <Link to=\"/docs\">Docs</Link>\n\n </NavigationHeader>\n\n <Sidebar />\n\n <PageContent>\n\n <TableOfContents />\n\n <DocumentationText />\n\n </PageContent>\n\n</PageLayout>\n\nAs your project grows, you will notice that many of your designs can be composed by reusing components you already wrote, speeding up your development. Our table of contents above could be added to any screen with <TableOfContents />! You can even jumpstart your project with the thousands of components shared by the React open source community like Chakra UI and Material UI.\n\nDefining a component \n\nTraditionally when creating web pages, web developers marked up their content and then added interaction by sprinkling on some JavaScript. This worked great when interaction was a nice-to-have on the web. Now it is expected for many sites and all apps. React puts interactivity first while still using the same technology: a React component is a JavaScript function that you can sprinkle with markup. Here‚Äôs what that looks like (you can edit the example below):\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function Profile() {\n return (\n <img\n src=\"https://i.imgur.com/MK3eW3Am.jpg\"\n alt=\"Katherine Johnson\"\n />\n )\n}\n\nAnd here‚Äôs how to build a component:\n\nStep 1: Export the component \n\nThe export default prefix is a standard JavaScript syntax (not specific to React). It lets you mark the main function in a file so that you can later import it from other files. (More on importing in Importing and Exporting Components!)\n\nStep 2: Define the function \n\nWith function Profile() { } you define a JavaScript function with the name Profile.\n\nPitfall\n\nReact components are regular JavaScript functions, but their names must start with a capital letter or they won‚Äôt work!\n\nStep 3: Add markup \n\nThe component returns an <img /> tag with src and alt attributes. <img /> is written like HTML, but it is actually JavaScript under the hood! This syntax is called JSX, and it lets you embed markup inside JavaScript.\n\nReturn statements can be written all on one line, as in this component:\n\nreturn <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />;\n\nBut if your markup isn‚Äôt all on the same line as the return keyword, you must wrap it in a pair of parentheses:\n\nreturn (\n\n <div>\n\n <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n\n </div>\n\n);\nPitfall\n\nWithout parentheses, any code on the lines after return will be ignored!\n\nUsing a component \n\nNow that you‚Äôve defined your Profile component, you can nest it inside other components. For example, you can export a Gallery component that uses multiple Profile components:\n\nApp.js\nDownload\nReload\nClear\nFork\nfunction Profile() {\n return (\n <img\n src=\"https://i.imgur.com/MK3eW3As.jpg\"\n alt=\"Katherine Johnson\"\n />\n );\n}\n\nexport default function Gallery() {\n return (\n <section>\n <h1>Amazing scientists</h1>\n <Profile />\n <Profile />\n <Profile />\n </section>\n );\n}\n\nShow more\nWhat the browser sees \n\nNotice the difference in casing:\n\n<section> is lowercase, so React knows we refer to an HTML tag.\n<Profile /> starts with a capital P, so React knows that we want to use our component called Profile.\n\nAnd Profile contains even more HTML: <img />. In the end, this is what the browser sees:\n\n<section>\n\n <h1>Amazing scientists</h1>\n\n <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n\n <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n\n <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n\n</section>\nNesting and organizing components \n\nComponents are regular JavaScript functions, so you can keep multiple components in the same file. This is convenient when components are relatively small or tightly related to each other. If this file gets crowded, you can always move Profile to a separate file. You will learn how to do this shortly on the page about imports.\n\nBecause the Profile components are rendered inside Gallery‚Äîeven several times!‚Äîwe can say that Gallery is a parent component, rendering each Profile as a ‚Äúchild‚Äù. This is part of the magic of React: you can define a component once, and then use it in as many places and as many times as you like.\n\nPitfall\n\nComponents can render other components, but you must never nest their definitions:\n\nexport default function Gallery() {\n\n // üî¥ Never define a component inside another component!\n\n function Profile() {\n\n // ...\n\n }\n\n // ...\n\n}\n\nThe snippet above is very slow and causes bugs. Instead, define every component at the top level:\n\nexport default function Gallery() {\n\n // ...\n\n}\n\n// ‚úÖ Declare components at the top level\n\nfunction Profile() {\n\n // ...\n\n}\n\nWhen a child component needs some data from a parent, pass it by props instead of nesting definitions.\n\nDEEP DIVE\nComponents all the way down \nShow Details\nRecap\n\nYou‚Äôve just gotten your first taste of React! Let‚Äôs recap some key points.\n\nReact lets you create components, reusable UI elements for your app.\n\nIn a React app, every piece of UI is a component.\n\nReact components are regular JavaScript functions except:\n\nTheir names always begin with a capital letter.\nThey return JSX markup.\nTry out some challenges\n1. Export the component\n2. Fix the return statement\n3. Spot the mistake\n4. Your own component\nChallenge 1 of 4: Export the component \n\nThis sandbox doesn‚Äôt work because the root component is not exported:\n\nApp.js\nDownload\nReload\nClear\nFork\nfunction Profile() {\n return (\n <img\n src=\"https://i.imgur.com/lICfvbD.jpg\"\n alt=\"Aklilu Lemma\"\n />\n );\n}\n\nTry to fix it yourself before looking at the solution!\n\nShow solution\nNext Challenge\nPREVIOUS\nDescribing the UI\nNEXT\nImporting and Exporting Components",
      "tables": [],
      "code_blocks": [
        "<article>\n\n  <h1>My First Component</h1>\n\n  <ol>\n\n    <li>Components: UI Building Blocks</li>\n\n    <li>Defining a Component</li>\n\n    <li>Using a Component</li>\n\n  </ol>\n\n</article>",
        "<article>\n\n  <h1>My First Component</h1>\n\n  <ol>\n\n    <li>Components: UI Building Blocks</li>\n\n    <li>Defining a Component</li>\n\n    <li>Using a Component</li>\n\n  </ol>\n\n</article>",
        "<TableOfContents />",
        "<PageLayout>\n\n  <NavigationHeader>\n\n    <SearchBar />\n\n    <Link to=\"/docs\">Docs</Link>\n\n  </NavigationHeader>\n\n  <Sidebar />\n\n  <PageContent>\n\n    <TableOfContents />\n\n    <DocumentationText />\n\n  </PageContent>\n\n</PageLayout>",
        "<PageLayout>\n\n  <NavigationHeader>\n\n    <SearchBar />\n\n    <Link to=\"/docs\">Docs</Link>\n\n  </NavigationHeader>\n\n  <Sidebar />\n\n  <PageContent>\n\n    <TableOfContents />\n\n    <DocumentationText />\n\n  </PageContent>\n\n</PageLayout>",
        "<TableOfContents />",
        "export default function Profile() {\n  return (\n    <img\n      src=\"https://i.imgur.com/MK3eW3Am.jpg\"\n      alt=\"Katherine Johnson\"\n    />\n  )\n}",
        "export default",
        "function Profile() { }",
        "return <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />;",
        "return <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />;",
        "return (\n\n  <div>\n\n    <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n\n  </div>\n\n);",
        "return (\n\n  <div>\n\n    <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n\n  </div>\n\n);",
        "function Profile() {\n  return (\n    <img\n      src=\"https://i.imgur.com/MK3eW3As.jpg\"\n      alt=\"Katherine Johnson\"\n    />\n  );\n}\n\nexport default function Gallery() {\n  return (\n    <section>\n      <h1>Amazing scientists</h1>\n      <Profile />\n      <Profile />\n      <Profile />\n    </section>\n  );\n}",
        "<Profile />",
        "<section>\n\n  <h1>Amazing scientists</h1>\n\n  <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n\n  <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n\n  <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n\n</section>",
        "<section>\n\n  <h1>Amazing scientists</h1>\n\n  <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n\n  <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n\n  <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n\n</section>",
        "export default function Gallery() {\n\n  // üî¥ Never define a component inside another component!\n\n  function Profile() {\n\n    // ...\n\n  }\n\n  // ...\n\n}",
        "export default function Gallery() {\n\n  // üî¥ Never define a component inside another component!\n\n  function Profile() {\n\n    // ...\n\n  }\n\n  // ...\n\n}",
        "export default function Gallery() {\n\n  // ...\n\n}\n\n\n\n// ‚úÖ Declare components at the top level\n\nfunction Profile() {\n\n  // ...\n\n}",
        "export default function Gallery() {\n\n  // ...\n\n}\n\n\n\n// ‚úÖ Declare components at the top level\n\nfunction Profile() {\n\n  // ...\n\n}",
        "function Profile() {\n  return (\n    <img\n      src=\"https://i.imgur.com/lICfvbD.jpg\"\n      alt=\"Aklilu Lemma\"\n    />\n  );\n}"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 1101
    },
    {
      "url": "https://react.dev/learn/reacting-to-input-with-state",
      "title": "Reacting to Input with State",
      "breadcrumb": [],
      "section_path": [
        "Managing State",
        "Reacting to Input with State"
      ],
      "headings": {
        "h1": [
          "Reacting to Input with State"
        ],
        "h2": [
          "How declarative UI compares to imperative",
          "Thinking about UI declaratively",
          "Recap",
          "Try out some challenges"
        ],
        "h3": [
          "You will learn",
          "Step 1: Identify your component‚Äôs different visual states",
          "Step 2: Determine what triggers those state changes",
          "Note",
          "Step 3: Represent the state in memory with useState",
          "Step 4: Remove any non-essential state variables",
          "Step 5: Connect the event handlers to set state"
        ],
        "h4": [
          "Displaying many visual states at once",
          "Eliminating ‚Äúimpossible‚Äù states with a reducer",
          "Challenge 1 of 3: Add and remove a CSS class"
        ],
        "h5": [
          "DEEP DIVE",
          "DEEP DIVE"
        ]
      },
      "text_content": "LEARN REACT\nMANAGING STATE\nReacting to Input with State\n\nReact provides a declarative way to manipulate the UI. Instead of manipulating individual pieces of the UI directly, you describe the different states that your component can be in, and switch between them in response to the user input. This is similar to how designers think about the UI.\n\nYou will learn\nHow declarative UI programming differs from imperative UI programming\nHow to enumerate the different visual states your component can be in\nHow to trigger the changes between the different visual states from code\nHow declarative UI compares to imperative \n\nWhen you design UI interactions, you probably think about how the UI changes in response to user actions. Consider a form that lets the user submit an answer:\n\nWhen you type something into the form, the ‚ÄúSubmit‚Äù button becomes enabled.\nWhen you press ‚ÄúSubmit‚Äù, both the form and the button become disabled, and a spinner appears.\nIf the network request succeeds, the form gets hidden, and the ‚ÄúThank you‚Äù message appears.\nIf the network request fails, an error message appears, and the form becomes enabled again.\n\nIn imperative programming, the above corresponds directly to how you implement interaction. You have to write the exact instructions to manipulate the UI depending on what just happened. Here‚Äôs another way to think about this: imagine riding next to someone in a car and telling them turn by turn where to go.\n\nIllustrated by Rachel Lee Nabors\n\nThey don‚Äôt know where you want to go, they just follow your commands. (And if you get the directions wrong, you end up in the wrong place!) It‚Äôs called imperative because you have to ‚Äúcommand‚Äù each element, from the spinner to the button, telling the computer how to update the UI.\n\nIn this example of imperative UI programming, the form is built without React. It only uses the browser DOM:\n\nindex.js\nindex.html\nReload\nClear\nFork\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\nasync function handleFormSubmit(e) {\n e.preventDefault();\n disable(textarea);\n disable(button);\n show(loadingMessage);\n hide(errorMessage);\n try {\n await submitForm(textarea.value);\n show(successMessage);\n hide(form);\n } catch (err) {\n show(errorMessage);\n errorMessage.textContent = err.message;\n } finally {\n hide(loadingMessage);\n enable(textarea);\n enable(button);\n }\n}\n\nfunction handleTextareaChange() {\n if (textarea.value.length === 0) {\n disable(button);\n } else {\n enable(button);\n }\n}\n\nfunction hide(el) {\n el.style.display = 'none';\n}\n\nfunction show(el) {\n el.style.display = '';\n}\n\nShow more\n\nManipulating the UI imperatively works well enough for isolated examples, but it gets exponentially more difficult to manage in more complex systems. Imagine updating a page full of different forms like this one. Adding a new UI element or a new interaction would require carefully checking all existing code to make sure you haven‚Äôt introduced a bug (for example, forgetting to show or hide something).\n\nReact was built to solve this problem.\n\nIn React, you don‚Äôt directly manipulate the UI‚Äîmeaning you don‚Äôt enable, disable, show, or hide components directly. Instead, you declare what you want to show, and React figures out how to update the UI. Think of getting into a taxi and telling the driver where you want to go instead of telling them exactly where to turn. It‚Äôs the driver‚Äôs job to get you there, and they might even know some shortcuts you haven‚Äôt considered!\n\nIllustrated by Rachel Lee Nabors\n\nThinking about UI declaratively \n\nYou‚Äôve seen how to implement a form imperatively above. To better understand how to think in React, you‚Äôll walk through reimplementing this UI in React below:\n\nIdentify your component‚Äôs different visual states\nDetermine what triggers those state changes\nRepresent the state in memory using useState\nRemove any non-essential state variables\nConnect the event handlers to set the state\nStep 1: Identify your component‚Äôs different visual states \n\nIn computer science, you may hear about a ‚Äústate machine‚Äù being in one of several ‚Äústates‚Äù. If you work with a designer, you may have seen mockups for different ‚Äúvisual states‚Äù. React stands at the intersection of design and computer science, so both of these ideas are sources of inspiration.\n\nFirst, you need to visualize all the different ‚Äústates‚Äù of the UI the user might see:\n\nEmpty: Form has a disabled ‚ÄúSubmit‚Äù button.\nTyping: Form has an enabled ‚ÄúSubmit‚Äù button.\nSubmitting: Form is completely disabled. Spinner is shown.\nSuccess: ‚ÄúThank you‚Äù message is shown instead of a form.\nError: Same as Typing state, but with an extra error message.\n\nJust like a designer, you‚Äôll want to ‚Äúmock up‚Äù or create ‚Äúmocks‚Äù for the different states before you add logic. For example, here is a mock for just the visual part of the form. This mock is controlled by a prop called status with a default value of 'empty':\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function Form({\n status = 'empty'\n}) {\n if (status === 'success') {\n return <h1>That's right!</h1>\n }\n return (\n <>\n <h2>City quiz</h2>\n <p>\n In which city is there a billboard that turns air into drinkable water?\n </p>\n <form>\n <textarea />\n <br />\n <button>\n Submit\n </button>\n </form>\n </>\n )\n}\n\nShow more\n\nYou could call that prop anything you like, the naming is not important. Try editing status = 'empty' to status = 'success' to see the success message appear. Mocking lets you quickly iterate on the UI before you wire up any logic. Here is a more fleshed out prototype of the same component, still ‚Äúcontrolled‚Äù by the status prop:\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function Form({\n // Try 'submitting', 'error', 'success':\n status = 'empty'\n}) {\n if (status === 'success') {\n return <h1>That's right!</h1>\n }\n return (\n <>\n <h2>City quiz</h2>\n <p>\n In which city is there a billboard that turns air into drinkable water?\n </p>\n <form>\n <textarea disabled={\n status === 'submitting'\n } />\n <br />\n <button disabled={\n status === 'empty' ||\n status === 'submitting'\n }>\n Submit\n </button>\n {status === 'error' &&\n <p className=\"Error\">\n Good guess but a wrong answer. Try again!\n </p>\n }\n </form>\n </>\n );\n}\n\nShow more\nDEEP DIVE\nDisplaying many visual states at once \nShow Details\nStep 2: Determine what triggers those state changes \n\nYou can trigger state updates in response to two kinds of inputs:\n\nHuman inputs, like clicking a button, typing in a field, navigating a link.\nComputer inputs, like a network response arriving, a timeout completing, an image loading.\nHuman inputs\nComputer inputs\n\nIllustrated by Rachel Lee Nabors\n\nIn both cases, you must set state variables to update the UI. For the form you‚Äôre developing, you will need to change state in response to a few different inputs:\n\nChanging the text input (human) should switch it from the Empty state to the Typing state or back, depending on whether the text box is empty or not.\nClicking the Submit button (human) should switch it to the Submitting state.\nSuccessful network response (computer) should switch it to the Success state.\nFailed network response (computer) should switch it to the Error state with the matching error message.\nNote\n\nNotice that human inputs often require event handlers!\n\nTo help visualize this flow, try drawing each state on paper as a labeled circle, and each change between two states as an arrow. You can sketch out many flows this way and sort out bugs long before implementation.\n\nForm states\n\nStep 3: Represent the state in memory with useState \n\nNext you‚Äôll need to represent the visual states of your component in memory with useState. Simplicity is key: each piece of state is a ‚Äúmoving piece‚Äù, and you want as few ‚Äúmoving pieces‚Äù as possible. More complexity leads to more bugs!\n\nStart with the state that absolutely must be there. For example, you‚Äôll need to store the answer for the input, and the error (if it exists) to store the last error:\n\nconst [answer, setAnswer] = useState('');\n\nconst [error, setError] = useState(null);\n\nThen, you‚Äôll need a state variable representing which one of the visual states that you want to display. There‚Äôs usually more than a single way to represent that in memory, so you‚Äôll need to experiment with it.\n\nIf you struggle to think of the best way immediately, start by adding enough state that you‚Äôre definitely sure that all the possible visual states are covered:\n\nconst [isEmpty, setIsEmpty] = useState(true);\n\nconst [isTyping, setIsTyping] = useState(false);\n\nconst [isSubmitting, setIsSubmitting] = useState(false);\n\nconst [isSuccess, setIsSuccess] = useState(false);\n\nconst [isError, setIsError] = useState(false);\n\nYour first idea likely won‚Äôt be the best, but that‚Äôs ok‚Äîrefactoring state is a part of the process!\n\nStep 4: Remove any non-essential state variables \n\nYou want to avoid duplication in the state content so you‚Äôre only tracking what is essential. Spending a little time on refactoring your state structure will make your components easier to understand, reduce duplication, and avoid unintended meanings. Your goal is to prevent the cases where the state in memory doesn‚Äôt represent any valid UI that you‚Äôd want a user to see. (For example, you never want to show an error message and disable the input at the same time, or the user won‚Äôt be able to correct the error!)\n\nHere are some questions you can ask about your state variables:\n\nDoes this state cause a paradox? For example, isTyping and isSubmitting can‚Äôt both be true. A paradox usually means that the state is not constrained enough. There are four possible combinations of two booleans, but only three correspond to valid states. To remove the ‚Äúimpossible‚Äù state, you can combine these into a status that must be one of three values: 'typing', 'submitting', or 'success'.\nIs the same information available in another state variable already? Another paradox: isEmpty and isTyping can‚Äôt be true at the same time. By making them separate state variables, you risk them going out of sync and causing bugs. Fortunately, you can remove isEmpty and instead check answer.length === 0.\nCan you get the same information from the inverse of another state variable? isError is not needed because you can check error !== null instead.\n\nAfter this clean-up, you‚Äôre left with 3 (down from 7!) essential state variables:\n\nconst [answer, setAnswer] = useState('');\n\nconst [error, setError] = useState(null);\n\nconst [status, setStatus] = useState('typing'); // 'typing', 'submitting', or 'success'\n\nYou know they are essential, because you can‚Äôt remove any of them without breaking the functionality.\n\nDEEP DIVE\nEliminating ‚Äúimpossible‚Äù states with a reducer \nShow Details\nStep 5: Connect the event handlers to set state \n\nLastly, create event handlers that update the state. Below is the final form, with all event handlers wired up:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function Form() {\n const [answer, setAnswer] = useState('');\n const [error, setError] = useState(null);\n const [status, setStatus] = useState('typing');\n\n if (status === 'success') {\n return <h1>That's right!</h1>\n }\n\n async function handleSubmit(e) {\n e.preventDefault();\n setStatus('submitting');\n try {\n await submitForm(answer);\n setStatus('success');\n } catch (err) {\n setStatus('typing');\n setError(err);\n }\n }\n\n function handleTextareaChange(e) {\n setAnswer(e.target.value);\n }\n\n return (\n <>\n <h2>City quiz</h2>\n <p>\n In which city is there a billboard that turns air into drinkable water?\n </p>\n <form onSubmit={handleSubmit}>\n <textarea\n value={answer}\n onChange={handleTextareaChange}\n disabled={status === 'submitting'}\n />\n <br />\n <button disabled={\n answer.length === 0 ||\n status === 'submitting'\n }>\n Submit\n </button>\n {error !== null &&\n <p className=\"Error\">\n {error.message}\n </p>\n }\n </form>\n </>\n );\n}\n\nfunction submitForm(answer) {\n // Pretend it's hitting the network.\n return new Promise((resolve, reject) => {\n setTimeout(() => {\n let shouldError = answer.toLowerCase() !== 'lima'\n if (shouldError) {\n reject(new Error('Good guess but a wrong answer. Try again!'));\n } else {\n resolve();\n }\n }, 1500);\n });\n}\n\nShow more\n\nAlthough this code is longer than the original imperative example, it is much less fragile. Expressing all interactions as state changes lets you later introduce new visual states without breaking existing ones. It also lets you change what should be displayed in each state without changing the logic of the interaction itself.\n\nRecap\nDeclarative programming means describing the UI for each visual state rather than micromanaging the UI (imperative).\nWhen developing a component:\nIdentify all its visual states.\nDetermine the human and computer triggers for state changes.\nModel the state with useState.\nRemove non-essential state to avoid bugs and paradoxes.\nConnect the event handlers to set state.\nTry out some challenges\n1. Add and remove a CSS class\n2. Profile editor\n3. Refactor the imperative solution without React\nChallenge 1 of 3: Add and remove a CSS class \n\nMake it so that clicking on the picture removes the background--active CSS class from the outer <div>, but adds the picture--active class to the <img>. Clicking the background again should restore the original CSS classes.\n\nVisually, you should expect that clicking on the picture removes the purple background and highlights the picture border. Clicking outside the picture highlights the background, but removes the picture border highlight.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function Picture() {\n return (\n <div className=\"background background--active\">\n <img\n className=\"picture\"\n alt=\"Rainbow houses in Kampung Pelangi, Indonesia\"\n src=\"https://i.imgur.com/5qwVYb1.jpeg\"\n />\n </div>\n );\n}\n\nShow solution\nNext Challenge\nPREVIOUS\nManaging State\nNEXT\nChoosing the State Structure",
      "tables": [],
      "code_blocks": [
        "export default function Form({\n  status = 'empty'\n}) {\n  if (status === 'success') {\n    return <h1>That's right!</h1>\n  }\n  return (\n    <>\n      <h2>City quiz</h2>\n      <p>\n        In which city is there a billboard that turns air into drinkable water?\n      </p>\n      <form>\n        <textarea />\n        <br />\n        <button>\n          Submit\n        </button>\n      </form>\n    </>\n  )\n}",
        "status = 'empty'",
        "status = 'success'",
        "export default function Form({\n  // Try 'submitting', 'error', 'success':\n  status = 'empty'\n}) {\n  if (status === 'success') {\n    return <h1>That's right!</h1>\n  }\n  return (\n    <>\n      <h2>City quiz</h2>\n      <p>\n        In which city is there a billboard that turns air into drinkable water?\n      </p>\n      <form>\n        <textarea disabled={\n          status === 'submitting'\n        } />\n        <br />\n        <button disabled={\n          status === 'empty' ||\n          status === 'submitting'\n        }>\n          Submit\n        </button>\n        {status === 'error' &&\n          <p className=\"Error\">\n            Good guess but a wrong answer. Try again!\n          </p>\n        }\n      </form>\n      </>\n  );\n}",
        "const [answer, setAnswer] = useState('');\n\nconst [error, setError] = useState(null);",
        "const [answer, setAnswer] = useState('');\n\nconst [error, setError] = useState(null);",
        "const [isEmpty, setIsEmpty] = useState(true);\n\nconst [isTyping, setIsTyping] = useState(false);\n\nconst [isSubmitting, setIsSubmitting] = useState(false);\n\nconst [isSuccess, setIsSuccess] = useState(false);\n\nconst [isError, setIsError] = useState(false);",
        "const [isEmpty, setIsEmpty] = useState(true);\n\nconst [isTyping, setIsTyping] = useState(false);\n\nconst [isSubmitting, setIsSubmitting] = useState(false);\n\nconst [isSuccess, setIsSuccess] = useState(false);\n\nconst [isError, setIsError] = useState(false);",
        "isSubmitting",
        "'submitting'",
        "answer.length === 0",
        "error !== null",
        "const [answer, setAnswer] = useState('');\n\nconst [error, setError] = useState(null);\n\nconst [status, setStatus] = useState('typing'); // 'typing', 'submitting', or 'success'",
        "const [answer, setAnswer] = useState('');\n\nconst [error, setError] = useState(null);\n\nconst [status, setStatus] = useState('typing'); // 'typing', 'submitting', or 'success'",
        "import { useState } from 'react';\n\nexport default function Form() {\n  const [answer, setAnswer] = useState('');\n  const [error, setError] = useState(null);\n  const [status, setStatus] = useState('typing');\n\n  if (status === 'success') {\n    return <h1>That's right!</h1>\n  }\n\n  async function handleSubmit(e) {\n    e.preventDefault();\n    setStatus('submitting');\n    try {\n      await submitForm(answer);\n      setStatus('success');\n    } catch (err) {\n      setStatus('typing');\n      setError(err);\n    }\n  }\n\n  function handleTextareaChange(e) {\n    setAnswer(e.target.value);\n  }\n\n  return (\n    <>\n      <h2>City quiz</h2>\n      <p>\n        In which city is there a billboard that turns air into drinkable water?\n      </p>\n      <form onSubmit={handleSubmit}>\n        <textarea\n          value={answer}\n          onChange={handleTextareaChange}\n          disabled={status === 'submitting'}\n        />\n        <br />\n        <button disabled={\n          answer.length === 0 ||\n          status === 'submitting'\n        }>\n          Submit\n        </button>\n        {error !== null &&\n          <p className=\"Error\">\n            {error.message}\n          </p>\n        }\n      </form>\n    </>\n  );\n}\n\nfunction submitForm(answer) {\n  // Pretend it's hitting the network.\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      let shouldError = answer.toLowerCase() !== 'lima'\n      if (shouldError) {\n        reject(new Error('Good guess but a wrong answer. Try again!'));\n      } else {\n        resolve();\n      }\n    }, 1500);\n  });\n}",
        "background--active",
        "picture--active",
        "export default function Picture() {\n  return (\n    <div className=\"background background--active\">\n      <img\n        className=\"picture\"\n        alt=\"Rainbow houses in Kampung Pelangi, Indonesia\"\n        src=\"https://i.imgur.com/5qwVYb1.jpeg\"\n      />\n    </div>\n  );\n}"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 2158
    },
    {
      "url": "https://react.dev/learn/react-compiler/installation",
      "title": "Installation",
      "breadcrumb": [],
      "section_path": [
        "React Compiler",
        "Installation"
      ],
      "headings": {
        "h1": [
          "Installation"
        ],
        "h2": [
          "Prerequisites",
          "Installation",
          "Basic Setup",
          "ESLint Integration",
          "Verify Your Setup",
          "Troubleshooting",
          "Next Steps"
        ],
        "h3": [
          "You will learn",
          "Pitfall",
          "Babel",
          "Vite",
          "Next.js",
          "React Router",
          "Webpack",
          "Expo",
          "Metro (React Native)",
          "Rspack",
          "Rsbuild",
          "Check React DevTools",
          "Check Build Output",
          "Opting out specific components"
        ]
      },
      "text_content": "LEARN REACT\nREACT COMPILER\nInstallation\n\nThis guide will help you install and configure React Compiler in your React application.\n\nYou will learn\nHow to install React Compiler\nBasic configuration for different build tools\nHow to verify your setup is working\nPrerequisites \n\nReact Compiler is designed to work best with React 19, but it also supports React 17 and 18. Learn more about React version compatibility.\n\nInstallation \n\nInstall React Compiler as a devDependency:\n\n Terminal\n Copy\nnpm install -D babel-plugin-react-compiler@latest\n\nOr with Yarn:\n\n Terminal\n Copy\nyarn add -D babel-plugin-react-compiler@latest\n\nOr with pnpm:\n\n Terminal\n Copy\npnpm install -D babel-plugin-react-compiler@latest\nBasic Setup \n\nReact Compiler is designed to work by default without any configuration. However, if you need to configure it in special circumstances (for example, to target React versions below 19), refer to the compiler options reference.\n\nThe setup process depends on your build tool. React Compiler includes a Babel plugin that integrates with your build pipeline.\n\nPitfall\n\nReact Compiler must run first in your Babel plugin pipeline. The compiler needs the original source information for proper analysis, so it must process your code before other transformations.\n\nBabel \n\nCreate or update your babel.config.js:\n\nmodule.exports = {\n\n plugins: [\n\n 'babel-plugin-react-compiler', // must run first!\n\n // ... other plugins\n\n ],\n\n // ... other config\n\n};\nVite \n\nIf you use Vite, you can add the plugin to vite-plugin-react:\n\n// vite.config.js\n\nimport { defineConfig } from 'vite';\n\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n\n plugins: [\n\n react({\n\n babel: {\n\n plugins: ['babel-plugin-react-compiler'],\n\n },\n\n }),\n\n ],\n\n});\n\nAlternatively, if you prefer a separate Babel plugin for Vite:\n\n Terminal\n Copy\nnpm install -D vite-plugin-babel\n// vite.config.js\n\nimport babel from 'vite-plugin-babel';\n\nimport { defineConfig } from 'vite';\n\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n\n plugins: [\n\n react(),\n\n babel({\n\n babelConfig: {\n\n plugins: ['babel-plugin-react-compiler'],\n\n },\n\n }),\n\n ],\n\n});\nNext.js \n\nPlease refer to the Next.js docs for more information.\n\nReact Router \n\nInstall vite-plugin-babel, and add the compiler‚Äôs Babel plugin to it:\n\n Terminal\n Copy\nnpm install vite-plugin-babel\n// vite.config.js\n\nimport { defineConfig } from \"vite\";\n\nimport babel from \"vite-plugin-babel\";\n\nimport { reactRouter } from \"@react-router/dev/vite\";\n\nconst ReactCompilerConfig = { /* ... */ };\n\nexport default defineConfig({\n\n plugins: [\n\n reactRouter(),\n\n babel({\n\n filter: /\\.[jt]sx?$/,\n\n babelConfig: {\n\n presets: [\"@babel/preset-typescript\"], // if you use TypeScript\n\n plugins: [\n\n [\"babel-plugin-react-compiler\", ReactCompilerConfig],\n\n ],\n\n },\n\n }),\n\n ],\n\n});\nWebpack \n\nA community webpack loader is now available here.\n\nExpo \n\nPlease refer to Expo‚Äôs docs to enable and use the React Compiler in Expo apps.\n\nMetro (React Native) \n\nReact Native uses Babel via Metro, so refer to the Usage with Babel section for installation instructions.\n\nRspack \n\nPlease refer to Rspack‚Äôs docs to enable and use the React Compiler in Rspack apps.\n\nRsbuild \n\nPlease refer to Rsbuild‚Äôs docs to enable and use the React Compiler in Rsbuild apps.\n\nESLint Integration \n\nReact Compiler includes an ESLint rule that helps identify code that can‚Äôt be optimized. When the ESLint rule reports an error, it means the compiler will skip optimizing that specific component or hook. This is safe: the compiler will continue optimizing other parts of your codebase. You don‚Äôt need to fix all violations immediately. Address them at your own pace to gradually increase the number of optimized components.\n\nInstall the ESLint plugin:\n\n Terminal\n Copy\nnpm install -D eslint-plugin-react-hooks@latest\n\nIf you haven‚Äôt already configured eslint-plugin-react-hooks, follow the installation instructions in the readme. The compiler rules are available in the recommended-latest preset.\n\nThe ESLint rule will:\n\nIdentify violations of the Rules of React\nShow which components can‚Äôt be optimized\nProvide helpful error messages for fixing issues\nVerify Your Setup \n\nAfter installation, verify that React Compiler is working correctly.\n\nCheck React DevTools \n\nComponents optimized by React Compiler will show a ‚ÄúMemo ‚ú®‚Äù badge in React DevTools:\n\nInstall the React Developer Tools browser extension\nOpen your app in development mode\nOpen React DevTools\nLook for the ‚ú® emoji next to component names\n\nIf the compiler is working:\n\nComponents will show a ‚ÄúMemo ‚ú®‚Äù badge in React DevTools\nExpensive calculations will be automatically memoized\nNo manual useMemo is required\nCheck Build Output \n\nYou can also verify the compiler is running by checking your build output. The compiled code will include automatic memoization logic that the compiler adds automatically.\n\nimport { c as _c } from \"react/compiler-runtime\";\n\nexport default function MyApp() {\n\n const $ = _c(1);\n\n let t0;\n\n if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n\n t0 = <div>Hello World</div>;\n\n $[0] = t0;\n\n } else {\n\n t0 = $[0];\n\n }\n\n return t0;\n\n}\nTroubleshooting \nOpting out specific components \n\nIf a component is causing issues after compilation, you can temporarily opt it out using the \"use no memo\" directive:\n\nfunction ProblematicComponent() {\n\n \"use no memo\";\n\n // Component code here\n\n}\n\nThis tells the compiler to skip optimization for this specific component. You should fix the underlying issue and remove the directive once resolved.\n\nFor more troubleshooting help, see the debugging guide.\n\nNext Steps \n\nNow that you have React Compiler installed, learn more about:\n\nReact version compatibility for React 17 and 18\nConfiguration options to customize the compiler\nIncremental adoption strategies for existing codebases\nDebugging techniques for troubleshooting issues\nCompiling Libraries guide for compiling your React library\nPREVIOUS\nIntroduction\nNEXT\nIncremental Adoption",
      "tables": [],
      "code_blocks": [
        "devDependency",
        "npm install -D babel-plugin-react-compiler@latest",
        "npm install -D babel-plugin-react-compiler@latest",
        "yarn add -D babel-plugin-react-compiler@latest",
        "yarn add -D babel-plugin-react-compiler@latest",
        "pnpm install -D babel-plugin-react-compiler@latest",
        "pnpm install -D babel-plugin-react-compiler@latest",
        "babel.config.js",
        "module.exports = {\n\n  plugins: [\n\n    'babel-plugin-react-compiler', // must run first!\n\n    // ... other plugins\n\n  ],\n\n  // ... other config\n\n};",
        "module.exports = {\n\n  plugins: [\n\n    'babel-plugin-react-compiler', // must run first!\n\n    // ... other plugins\n\n  ],\n\n  // ... other config\n\n};",
        "// vite.config.js\n\nimport { defineConfig } from 'vite';\n\nimport react from '@vitejs/plugin-react';\n\n\n\nexport default defineConfig({\n\n  plugins: [\n\n    react({\n\n      babel: {\n\n        plugins: ['babel-plugin-react-compiler'],\n\n      },\n\n    }),\n\n  ],\n\n});",
        "// vite.config.js\n\nimport { defineConfig } from 'vite';\n\nimport react from '@vitejs/plugin-react';\n\n\n\nexport default defineConfig({\n\n  plugins: [\n\n    react({\n\n      babel: {\n\n        plugins: ['babel-plugin-react-compiler'],\n\n      },\n\n    }),\n\n  ],\n\n});",
        "npm install -D vite-plugin-babel",
        "npm install -D vite-plugin-babel",
        "// vite.config.js\n\nimport babel from 'vite-plugin-babel';\n\nimport { defineConfig } from 'vite';\n\nimport react from '@vitejs/plugin-react';\n\n\n\nexport default defineConfig({\n\n  plugins: [\n\n    react(),\n\n    babel({\n\n      babelConfig: {\n\n        plugins: ['babel-plugin-react-compiler'],\n\n      },\n\n    }),\n\n  ],\n\n});",
        "// vite.config.js\n\nimport babel from 'vite-plugin-babel';\n\nimport { defineConfig } from 'vite';\n\nimport react from '@vitejs/plugin-react';\n\n\n\nexport default defineConfig({\n\n  plugins: [\n\n    react(),\n\n    babel({\n\n      babelConfig: {\n\n        plugins: ['babel-plugin-react-compiler'],\n\n      },\n\n    }),\n\n  ],\n\n});",
        "vite-plugin-babel",
        "npm install vite-plugin-babel",
        "npm install vite-plugin-babel",
        "// vite.config.js\n\nimport { defineConfig } from \"vite\";\n\nimport babel from \"vite-plugin-babel\";\n\nimport { reactRouter } from \"@react-router/dev/vite\";\n\n\n\nconst ReactCompilerConfig = { /* ... */ };\n\n\n\nexport default defineConfig({\n\n  plugins: [\n\n    reactRouter(),\n\n    babel({\n\n      filter: /\\.[jt]sx?$/,\n\n      babelConfig: {\n\n        presets: [\"@babel/preset-typescript\"], // if you use TypeScript\n\n        plugins: [\n\n          [\"babel-plugin-react-compiler\", ReactCompilerConfig],\n\n        ],\n\n      },\n\n    }),\n\n  ],\n\n});",
        "// vite.config.js\n\nimport { defineConfig } from \"vite\";\n\nimport babel from \"vite-plugin-babel\";\n\nimport { reactRouter } from \"@react-router/dev/vite\";\n\n\n\nconst ReactCompilerConfig = { /* ... */ };\n\n\n\nexport default defineConfig({\n\n  plugins: [\n\n    reactRouter(),\n\n    babel({\n\n      filter: /\\.[jt]sx?$/,\n\n      babelConfig: {\n\n        presets: [\"@babel/preset-typescript\"], // if you use TypeScript\n\n        plugins: [\n\n          [\"babel-plugin-react-compiler\", ReactCompilerConfig],\n\n        ],\n\n      },\n\n    }),\n\n  ],\n\n});",
        "npm install -D eslint-plugin-react-hooks@latest",
        "npm install -D eslint-plugin-react-hooks@latest",
        "recommended-latest",
        "import { c as _c } from \"react/compiler-runtime\";\n\nexport default function MyApp() {\n\n  const $ = _c(1);\n\n  let t0;\n\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n\n    t0 = <div>Hello World</div>;\n\n    $[0] = t0;\n\n  } else {\n\n    t0 = $[0];\n\n  }\n\n  return t0;\n\n}",
        "import { c as _c } from \"react/compiler-runtime\";\n\nexport default function MyApp() {\n\n  const $ = _c(1);\n\n  let t0;\n\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n\n    t0 = <div>Hello World</div>;\n\n    $[0] = t0;\n\n  } else {\n\n    t0 = $[0];\n\n  }\n\n  return t0;\n\n}",
        "\"use no memo\"",
        "function ProblematicComponent() {\n\n  \"use no memo\";\n\n  // Component code here\n\n}",
        "function ProblematicComponent() {\n\n  \"use no memo\";\n\n  // Component code here\n\n}"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 844
    },
    {
      "url": "https://react.dev/learn/setup",
      "title": "Setup",
      "breadcrumb": [],
      "section_path": [
        "Setup"
      ],
      "headings": {
        "h1": [
          "Setup"
        ],
        "h2": [
          "Editor Setup",
          "Using TypeScript",
          "React Developer Tools",
          "React Compiler",
          "Next steps"
        ]
      },
      "text_content": "LEARN REACT\nSetup\n\nReact integrates with tools like editors, TypeScript, browser extensions, and compilers. This section will help you get your environment set up.\n\nEditor Setup \n\nSee our recommended editors and learn how to set them up to work with React.\n\nUsing TypeScript \n\nTypeScript is a popular way to add type definitions to JavaScript codebases. Learn how to integrate TypeScript into your React projects.\n\nReact Developer Tools \n\nReact Developer Tools is a browser extension that can inspect React components, edit props and state, and identify performance problems. Learn how to install it here.\n\nReact Compiler \n\nReact Compiler is a tool that automatically optimizes your React app. Learn more.\n\nNext steps \n\nHead to the Quick Start guide for a tour of the most important React concepts you will encounter every day.\n\nPREVIOUS\nAdd React to an Existing Project\nNEXT\nEditor Setup",
      "tables": [],
      "code_blocks": [],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 140
    },
    {
      "url": "https://react.dev/learn/escape-hatches",
      "title": "Escape Hatches",
      "breadcrumb": [],
      "section_path": [
        "Escape Hatches"
      ],
      "headings": {
        "h1": [
          "Escape Hatches"
        ],
        "h2": [
          "Referencing values with refs",
          "Ready to learn this topic?",
          "Manipulating the DOM with refs",
          "Ready to learn this topic?",
          "Synchronizing with Effects",
          "Ready to learn this topic?",
          "You Might Not Need An Effect",
          "Ready to learn this topic?",
          "Lifecycle of reactive effects",
          "Ready to learn this topic?",
          "Separating events from Effects",
          "Ready to learn this topic?",
          "Removing Effect dependencies",
          "Ready to learn this topic?",
          "Reusing logic with custom Hooks",
          "Ready to learn this topic?",
          "What‚Äôs next?"
        ],
        "h3": [
          "In this chapter"
        ]
      },
      "text_content": "LEARN REACT\nEscape Hatches\nADVANCED\n\nSome of your components may need to control and synchronize with systems outside of React. For example, you might need to focus an input using the browser API, play and pause a video player implemented without React, or connect and listen to messages from a remote server. In this chapter, you‚Äôll learn the escape hatches that let you ‚Äústep outside‚Äù React and connect to external systems. Most of your application logic and data flow should not rely on these features.\n\nIn this chapter\nHow to ‚Äúremember‚Äù information without re-rendering\nHow to access DOM elements managed by React\nHow to synchronize components with external systems\nHow to remove unnecessary Effects from your components\nHow an Effect‚Äôs lifecycle is different from a component‚Äôs\nHow to prevent some values from re-triggering Effects\nHow to make your Effect re-run less often\nHow to share logic between components\nReferencing values with refs \n\nWhen you want a component to ‚Äúremember‚Äù some information, but you don‚Äôt want that information to trigger new renders, you can use a ref:\n\nconst ref = useRef(0);\n\nLike state, refs are retained by React between re-renders. However, setting state re-renders a component. Changing a ref does not! You can access the current value of that ref through the ref.current property.\n\nApp.js\nDownload\nReload\nClear\nFork\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nimport { useRef } from 'react';\n\nexport default function Counter() {\n let ref = useRef(0);\n\n function handleClick() {\n ref.current = ref.current + 1;\n alert('You clicked ' + ref.current + ' times!');\n }\n\n return (\n <button onClick={handleClick}>\n Click me!\n </button>\n );\n}\n\nShow more\n\nA ref is like a secret pocket of your component that React doesn‚Äôt track. For example, you can use refs to store timeout IDs, DOM elements, and other objects that don‚Äôt impact the component‚Äôs rendering output.\n\nReady to learn this topic?\n\nRead Referencing Values with Refs to learn how to use refs to remember information.\n\nRead More\nManipulating the DOM with refs \n\nReact automatically updates the DOM to match your render output, so your components won‚Äôt often need to manipulate it. However, sometimes you might need access to the DOM elements managed by React‚Äîfor example, to focus a node, scroll to it, or measure its size and position. There is no built-in way to do those things in React, so you will need a ref to the DOM node. For example, clicking the button will focus the input using a ref:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useRef } from 'react';\n\nexport default function Form() {\n const inputRef = useRef(null);\n\n function handleClick() {\n inputRef.current.focus();\n }\n\n return (\n <>\n <input ref={inputRef} />\n <button onClick={handleClick}>\n Focus the input\n </button>\n </>\n );\n}\n\nShow more\nReady to learn this topic?\n\nRead Manipulating the DOM with Refs to learn how to access DOM elements managed by React.\n\nRead More\nSynchronizing with Effects \n\nSome components need to synchronize with external systems. For example, you might want to control a non-React component based on the React state, set up a server connection, or send an analytics log when a component appears on the screen. Unlike event handlers, which let you handle particular events, Effects let you run some code after rendering. Use them to synchronize your component with a system outside of React.\n\nPress Play/Pause a few times and see how the video player stays synchronized to the isPlaying prop value:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState, useRef, useEffect } from 'react';\n\nfunction VideoPlayer({ src, isPlaying }) {\n const ref = useRef(null);\n\n useEffect(() => {\n if (isPlaying) {\n ref.current.play();\n } else {\n ref.current.pause();\n }\n }, [isPlaying]);\n\n return <video ref={ref} src={src} loop playsInline />;\n}\n\nexport default function App() {\n const [isPlaying, setIsPlaying] = useState(false);\n return (\n <>\n <button onClick={() => setIsPlaying(!isPlaying)}>\n {isPlaying ? 'Pause' : 'Play'}\n </button>\n <VideoPlayer\n isPlaying={isPlaying}\n src=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"\n />\n </>\n );\n}\n\nShow more\n\nMany Effects also ‚Äúclean up‚Äù after themselves. For example, an Effect that sets up a connection to a chat server should return a cleanup function that tells React how to disconnect your component from that server:\n\nApp.js\nchat.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nexport default function ChatRoom() {\n useEffect(() => {\n const connection = createConnection();\n connection.connect();\n return () => connection.disconnect();\n }, []);\n return <h1>Welcome to the chat!</h1>;\n}\n\nIn development, React will immediately run and clean up your Effect one extra time. This is why you see \"‚úÖ Connecting...\" printed twice. This ensures that you don‚Äôt forget to implement the cleanup function.\n\nReady to learn this topic?\n\nRead Synchronizing with Effects to learn how to synchronize components with external systems.\n\nRead More\nYou Might Not Need An Effect \n\nEffects are an escape hatch from the React paradigm. They let you ‚Äústep outside‚Äù of React and synchronize your components with some external system. If there is no external system involved (for example, if you want to update a component‚Äôs state when some props or state change), you shouldn‚Äôt need an Effect. Removing unnecessary Effects will make your code easier to follow, faster to run, and less error-prone.\n\nThere are two common cases in which you don‚Äôt need Effects:\n\nYou don‚Äôt need Effects to transform data for rendering.\nYou don‚Äôt need Effects to handle user events.\n\nFor example, you don‚Äôt need an Effect to adjust some state based on other state:\n\nfunction Form() {\n\n const [firstName, setFirstName] = useState('Taylor');\n\n const [lastName, setLastName] = useState('Swift');\n\n // üî¥ Avoid: redundant state and unnecessary Effect\n\n const [fullName, setFullName] = useState('');\n\n useEffect(() => {\n\n setFullName(firstName + ' ' + lastName);\n\n }, [firstName, lastName]);\n\n // ...\n\n}\n\nInstead, calculate as much as you can while rendering:\n\nfunction Form() {\n\n const [firstName, setFirstName] = useState('Taylor');\n\n const [lastName, setLastName] = useState('Swift');\n\n // ‚úÖ Good: calculated during rendering\n\n const fullName = firstName + ' ' + lastName;\n\n // ...\n\n}\n\nHowever, you do need Effects to synchronize with external systems.\n\nReady to learn this topic?\n\nRead You Might Not Need an Effect to learn how to remove unnecessary Effects.\n\nRead More\nLifecycle of reactive effects \n\nEffects have a different lifecycle from components. Components may mount, update, or unmount. An Effect can only do two things: to start synchronizing something, and later to stop synchronizing it. This cycle can happen multiple times if your Effect depends on props and state that change over time.\n\nThis Effect depends on the value of the roomId prop. Props are reactive values, which means they can change on a re-render. Notice that the Effect re-synchronizes (and re-connects to the server) if roomId changes:\n\nApp.js\nchat.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n useEffect(() => {\n const connection = createConnection(serverUrl, roomId);\n connection.connect();\n return () => connection.disconnect();\n }, [roomId]);\n\n return <h1>Welcome to the {roomId} room!</h1>;\n}\n\nexport default function App() {\n const [roomId, setRoomId] = useState('general');\n return (\n <>\n <label>\n Choose the chat room:{' '}\n <select\n value={roomId}\n onChange={e => setRoomId(e.target.value)}\n >\n <option value=\"general\">general</option>\n <option value=\"travel\">travel</option>\n <option value=\"music\">music</option>\n </select>\n </label>\n <hr />\n <ChatRoom roomId={roomId} />\n </>\n );\n}\n\nShow more\n\nReact provides a linter rule to check that you‚Äôve specified your Effect‚Äôs dependencies correctly. If you forget to specify roomId in the list of dependencies in the above example, the linter will find that bug automatically.\n\nReady to learn this topic?\n\nRead Lifecycle of Reactive Events to learn how an Effect‚Äôs lifecycle is different from a component‚Äôs.\n\nRead More\nSeparating events from Effects \n\nEvent handlers only re-run when you perform the same interaction again. Unlike event handlers, Effects re-synchronize if any of the values they read, like props or state, are different than during last render. Sometimes, you want a mix of both behaviors: an Effect that re-runs in response to some values but not others.\n\nAll code inside Effects is reactive. It will run again if some reactive value it reads has changed due to a re-render. For example, this Effect will re-connect to the chat if either roomId or theme have changed:\n\nApp.js\nchat.js\nnotifications.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { createConnection, sendMessage } from './chat.js';\nimport { showNotification } from './notifications.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId, theme }) {\n useEffect(() => {\n const connection = createConnection(serverUrl, roomId);\n connection.on('connected', () => {\n showNotification('Connected!', theme);\n });\n connection.connect();\n return () => connection.disconnect();\n }, [roomId, theme]);\n\n return <h1>Welcome to the {roomId} room!</h1>\n}\n\nexport default function App() {\n const [roomId, setRoomId] = useState('general');\n const [isDark, setIsDark] = useState(false);\n return (\n <>\n <label>\n Choose the chat room:{' '}\n <select\n value={roomId}\n onChange={e => setRoomId(e.target.value)}\n >\n <option value=\"general\">general</option>\n <option value=\"travel\">travel</option>\n <option value=\"music\">music</option>\n </select>\n </label>\n <label>\n <input\n type=\"checkbox\"\n checked={isDark}\n onChange={e => setIsDark(e.target.checked)}\n />\n Use dark theme\n </label>\n <hr />\n <ChatRoom\n roomId={roomId}\n theme={isDark ? 'dark' : 'light'} \n />\n </>\n );\n}\n\nShow more\n\nThis is not ideal. You want to re-connect to the chat only if the roomId has changed. Switching the theme shouldn‚Äôt re-connect to the chat! Move the code reading theme out of your Effect into an Effect Event:\n\nApp.js\nchat.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { useEffectEvent } from 'react';\nimport { createConnection, sendMessage } from './chat.js';\nimport { showNotification } from './notifications.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId, theme }) {\n const onConnected = useEffectEvent(() => {\n showNotification('Connected!', theme);\n });\n\n useEffect(() => {\n const connection = createConnection(serverUrl, roomId);\n connection.on('connected', () => {\n onConnected();\n });\n connection.connect();\n return () => connection.disconnect();\n }, [roomId]);\n\n return <h1>Welcome to the {roomId} room!</h1>\n}\n\nexport default function App() {\n const [roomId, setRoomId] = useState('general');\n const [isDark, setIsDark] = useState(false);\n return (\n <>\n <label>\n Choose the chat room:{' '}\n <select\n value={roomId}\n onChange={e => setRoomId(e.target.value)}\n >\n <option value=\"general\">general</option>\n <option value=\"travel\">travel</option>\n <option value=\"music\">music</option>\n </select>\n </label>\n <label>\n <input\n type=\"checkbox\"\n checked={isDark}\n onChange={e => setIsDark(e.target.checked)}\n />\n Use dark theme\n </label>\n <hr />\n <ChatRoom\n roomId={roomId}\n theme={isDark ? 'dark' : 'light'} \n />\n </>\n );\n}\n\nShow more\n\nCode inside Effect Events isn‚Äôt reactive, so changing the theme no longer makes your Effect re-connect.\n\nReady to learn this topic?\n\nRead Separating Events from Effects to learn how to prevent some values from re-triggering Effects.\n\nRead More\nRemoving Effect dependencies \n\nWhen you write an Effect, the linter will verify that you‚Äôve included every reactive value (like props and state) that the Effect reads in the list of your Effect‚Äôs dependencies. This ensures that your Effect remains synchronized with the latest props and state of your component. Unnecessary dependencies may cause your Effect to run too often, or even create an infinite loop. The way you remove them depends on the case.\n\nFor example, this Effect depends on the options object which gets re-created every time you edit the input:\n\nApp.js\nchat.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n const [message, setMessage] = useState('');\n\n const options = {\n serverUrl: serverUrl,\n roomId: roomId\n };\n\n useEffect(() => {\n const connection = createConnection(options);\n connection.connect();\n return () => connection.disconnect();\n }, [options]);\n\n return (\n <>\n <h1>Welcome to the {roomId} room!</h1>\n <input value={message} onChange={e => setMessage(e.target.value)} />\n </>\n );\n}\n\nexport default function App() {\n const [roomId, setRoomId] = useState('general');\n return (\n <>\n <label>\n Choose the chat room:{' '}\n <select\n value={roomId}\n onChange={e => setRoomId(e.target.value)}\n >\n <option value=\"general\">general</option>\n <option value=\"travel\">travel</option>\n <option value=\"music\">music</option>\n </select>\n </label>\n <hr />\n <ChatRoom roomId={roomId} />\n </>\n );\n}\n\nShow more\n\nYou don‚Äôt want the chat to re-connect every time you start typing a message in that chat. To fix this problem, move creation of the options object inside the Effect so that the Effect only depends on the roomId string:\n\nApp.js\nchat.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n const [message, setMessage] = useState('');\n\n useEffect(() => {\n const options = {\n serverUrl: serverUrl,\n roomId: roomId\n };\n const connection = createConnection(options);\n connection.connect();\n return () => connection.disconnect();\n }, [roomId]);\n\n return (\n <>\n <h1>Welcome to the {roomId} room!</h1>\n <input value={message} onChange={e => setMessage(e.target.value)} />\n </>\n );\n}\n\nexport default function App() {\n const [roomId, setRoomId] = useState('general');\n return (\n <>\n <label>\n Choose the chat room:{' '}\n <select\n value={roomId}\n onChange={e => setRoomId(e.target.value)}\n >\n <option value=\"general\">general</option>\n <option value=\"travel\">travel</option>\n <option value=\"music\">music</option>\n </select>\n </label>\n <hr />\n <ChatRoom roomId={roomId} />\n </>\n );\n}\n\nShow more\n\nNotice that you didn‚Äôt start by editing the dependency list to remove the options dependency. That would be wrong. Instead, you changed the surrounding code so that the dependency became unnecessary. Think of the dependency list as a list of all the reactive values used by your Effect‚Äôs code. You don‚Äôt intentionally choose what to put on that list. The list describes your code. To change the dependency list, change the code.\n\nReady to learn this topic?\n\nRead Removing Effect Dependencies to learn how to make your Effect re-run less often.\n\nRead More\nReusing logic with custom Hooks \n\nReact comes with built-in Hooks like useState, useContext, and useEffect. Sometimes, you‚Äôll wish that there was a Hook for some more specific purpose: for example, to fetch data, to keep track of whether the user is online, or to connect to a chat room. To do this, you can create your own Hooks for your application‚Äôs needs.\n\nIn this example, the usePointerPosition custom Hook tracks the cursor position, while useDelayedValue custom Hook returns a value that‚Äôs ‚Äúlagging behind‚Äù the value you passed by a certain number of milliseconds. Move the cursor over the sandbox preview area to see a moving trail of dots following the cursor:\n\nApp.js\nusePointerPosition.js\nuseDelayedValue.js\nReload\nClear\nFork\nimport { usePointerPosition } from './usePointerPosition.js';\nimport { useDelayedValue } from './useDelayedValue.js';\n\nexport default function Canvas() {\n const pos1 = usePointerPosition();\n const pos2 = useDelayedValue(pos1, 100);\n const pos3 = useDelayedValue(pos2, 200);\n const pos4 = useDelayedValue(pos3, 100);\n const pos5 = useDelayedValue(pos4, 50);\n return (\n <>\n <Dot position={pos1} opacity={1} />\n <Dot position={pos2} opacity={0.8} />\n <Dot position={pos3} opacity={0.6} />\n <Dot position={pos4} opacity={0.4} />\n <Dot position={pos5} opacity={0.2} />\n </>\n );\n}\n\nfunction Dot({ position, opacity }) {\n return (\n <div style={{\n position: 'absolute',\n backgroundColor: 'pink',\n borderRadius: '50%',\n opacity,\n transform: `translate(${position.x}px, ${position.y}px)`,\n pointerEvents: 'none',\n left: -20,\n top: -20,\n width: 40,\n height: 40,\n }} />\n );\n}\n\nShow more\n\nYou can create custom Hooks, compose them together, pass data between them, and reuse them between components. As your app grows, you will write fewer Effects by hand because you‚Äôll be able to reuse custom Hooks you already wrote. There are also many excellent custom Hooks maintained by the React community.\n\nReady to learn this topic?\n\nRead Reusing Logic with Custom Hooks to learn how to share logic between components.\n\nRead More\nWhat‚Äôs next? \n\nHead over to Referencing Values with Refs to start reading this chapter page by page!\n\nPREVIOUS\nScaling Up with Reducer and Context\nNEXT\nReferencing Values with Refs",
      "tables": [],
      "code_blocks": [
        "const ref = useRef(0);",
        "const ref = useRef(0);",
        "ref.current",
        "import { useRef } from 'react';\n\nexport default function Form() {\n  const inputRef = useRef(null);\n\n  function handleClick() {\n    inputRef.current.focus();\n  }\n\n  return (\n    <>\n      <input ref={inputRef} />\n      <button onClick={handleClick}>\n        Focus the input\n      </button>\n    </>\n  );\n}",
        "import { useState, useRef, useEffect } from 'react';\n\nfunction VideoPlayer({ src, isPlaying }) {\n  const ref = useRef(null);\n\n  useEffect(() => {\n    if (isPlaying) {\n      ref.current.play();\n    } else {\n      ref.current.pause();\n    }\n  }, [isPlaying]);\n\n  return <video ref={ref} src={src} loop playsInline />;\n}\n\nexport default function App() {\n  const [isPlaying, setIsPlaying] = useState(false);\n  return (\n    <>\n      <button onClick={() => setIsPlaying(!isPlaying)}>\n        {isPlaying ? 'Pause' : 'Play'}\n      </button>\n      <VideoPlayer\n        isPlaying={isPlaying}\n        src=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"\n      />\n    </>\n  );\n}",
        "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nexport default function ChatRoom() {\n  useEffect(() => {\n    const connection = createConnection();\n    connection.connect();\n    return () => connection.disconnect();\n  }, []);\n  return <h1>Welcome to the chat!</h1>;\n}",
        "\"‚úÖ Connecting...\"",
        "function Form() {\n\n  const [firstName, setFirstName] = useState('Taylor');\n\n  const [lastName, setLastName] = useState('Swift');\n\n\n\n  // üî¥ Avoid: redundant state and unnecessary Effect\n\n  const [fullName, setFullName] = useState('');\n\n  useEffect(() => {\n\n    setFullName(firstName + ' ' + lastName);\n\n  }, [firstName, lastName]);\n\n  // ...\n\n}",
        "function Form() {\n\n  const [firstName, setFirstName] = useState('Taylor');\n\n  const [lastName, setLastName] = useState('Swift');\n\n\n\n  // üî¥ Avoid: redundant state and unnecessary Effect\n\n  const [fullName, setFullName] = useState('');\n\n  useEffect(() => {\n\n    setFullName(firstName + ' ' + lastName);\n\n  }, [firstName, lastName]);\n\n  // ...\n\n}",
        "function Form() {\n\n  const [firstName, setFirstName] = useState('Taylor');\n\n  const [lastName, setLastName] = useState('Swift');\n\n  // ‚úÖ Good: calculated during rendering\n\n  const fullName = firstName + ' ' + lastName;\n\n  // ...\n\n}",
        "function Form() {\n\n  const [firstName, setFirstName] = useState('Taylor');\n\n  const [lastName, setLastName] = useState('Swift');\n\n  // ‚úÖ Good: calculated during rendering\n\n  const fullName = firstName + ' ' + lastName;\n\n  // ...\n\n}",
        "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId);\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId]);\n\n  return <h1>Welcome to the {roomId} room!</h1>;\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <hr />\n      <ChatRoom roomId={roomId} />\n    </>\n  );\n}",
        "import { useState, useEffect } from 'react';\nimport { createConnection, sendMessage } from './chat.js';\nimport { showNotification } from './notifications.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId, theme }) {\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId);\n    connection.on('connected', () => {\n      showNotification('Connected!', theme);\n    });\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId, theme]);\n\n  return <h1>Welcome to the {roomId} room!</h1>\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  const [isDark, setIsDark] = useState(false);\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={isDark}\n          onChange={e => setIsDark(e.target.checked)}\n        />\n        Use dark theme\n      </label>\n      <hr />\n      <ChatRoom\n        roomId={roomId}\n        theme={isDark ? 'dark' : 'light'} \n      />\n    </>\n  );\n}",
        "import { useState, useEffect } from 'react';\nimport { useEffectEvent } from 'react';\nimport { createConnection, sendMessage } from './chat.js';\nimport { showNotification } from './notifications.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId, theme }) {\n  const onConnected = useEffectEvent(() => {\n    showNotification('Connected!', theme);\n  });\n\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId);\n    connection.on('connected', () => {\n      onConnected();\n    });\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId]);\n\n  return <h1>Welcome to the {roomId} room!</h1>\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  const [isDark, setIsDark] = useState(false);\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={isDark}\n          onChange={e => setIsDark(e.target.checked)}\n        />\n        Use dark theme\n      </label>\n      <hr />\n      <ChatRoom\n        roomId={roomId}\n        theme={isDark ? 'dark' : 'light'} \n      />\n    </>\n  );\n}",
        "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  const [message, setMessage] = useState('');\n\n  const options = {\n    serverUrl: serverUrl,\n    roomId: roomId\n  };\n\n  useEffect(() => {\n    const connection = createConnection(options);\n    connection.connect();\n    return () => connection.disconnect();\n  }, [options]);\n\n  return (\n    <>\n      <h1>Welcome to the {roomId} room!</h1>\n      <input value={message} onChange={e => setMessage(e.target.value)} />\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <hr />\n      <ChatRoom roomId={roomId} />\n    </>\n  );\n}",
        "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  const [message, setMessage] = useState('');\n\n  useEffect(() => {\n    const options = {\n      serverUrl: serverUrl,\n      roomId: roomId\n    };\n    const connection = createConnection(options);\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId]);\n\n  return (\n    <>\n      <h1>Welcome to the {roomId} room!</h1>\n      <input value={message} onChange={e => setMessage(e.target.value)} />\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <hr />\n      <ChatRoom roomId={roomId} />\n    </>\n  );\n}",
        "usePointerPosition",
        "useDelayedValue",
        "import { usePointerPosition } from './usePointerPosition.js';\nimport { useDelayedValue } from './useDelayedValue.js';\n\nexport default function Canvas() {\n  const pos1 = usePointerPosition();\n  const pos2 = useDelayedValue(pos1, 100);\n  const pos3 = useDelayedValue(pos2, 200);\n  const pos4 = useDelayedValue(pos3, 100);\n  const pos5 = useDelayedValue(pos4, 50);\n  return (\n    <>\n      <Dot position={pos1} opacity={1} />\n      <Dot position={pos2} opacity={0.8} />\n      <Dot position={pos3} opacity={0.6} />\n      <Dot position={pos4} opacity={0.4} />\n      <Dot position={pos5} opacity={0.2} />\n    </>\n  );\n}\n\nfunction Dot({ position, opacity }) {\n  return (\n    <div style={{\n      position: 'absolute',\n      backgroundColor: 'pink',\n      borderRadius: '50%',\n      opacity,\n      transform: `translate(${position.x}px, ${position.y}px)`,\n      pointerEvents: 'none',\n      left: -20,\n      top: -20,\n      width: 40,\n      height: 40,\n    }} />\n  );\n}"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 2472
    },
    {
      "url": "https://react.dev/learn/react-compiler/debugging",
      "title": "Debugging and Troubleshooting",
      "breadcrumb": [],
      "section_path": [
        "React Compiler",
        "Debugging and Troubleshooting"
      ],
      "headings": {
        "h1": [
          "Debugging and Troubleshooting"
        ],
        "h2": [
          "Understanding Compiler Behavior",
          "Common Breaking Patterns",
          "Debugging Workflow",
          "Reporting Compiler Bugs",
          "Next Steps"
        ],
        "h3": [
          "You will learn",
          "Compiler Errors vs Runtime Issues",
          "Compiler Build Errors",
          "Runtime Issues",
          "1. Temporarily Disable Compilation",
          "2. Fix Issues Step by Step"
        ]
      },
      "text_content": "LEARN REACT\nREACT COMPILER\nDebugging and Troubleshooting\n\nThis guide helps you identify and fix issues when using React Compiler. Learn how to debug compilation problems and resolve common issues.\n\nYou will learn\nThe difference between compiler errors and runtime issues\nCommon patterns that break compilation\nStep-by-step debugging workflow\nUnderstanding Compiler Behavior \n\nReact Compiler is designed to handle code that follows the Rules of React. When it encounters code that might break these rules, it safely skips optimization rather than risk changing your app‚Äôs behavior.\n\nCompiler Errors vs Runtime Issues \n\nCompiler errors occur at build time and prevent your code from compiling. These are rare because the compiler is designed to skip problematic code rather than fail.\n\nRuntime issues occur when compiled code behaves differently than expected. Most of the time, if you encounter an issue with React Compiler, it‚Äôs a runtime issue. This typically happens when your code violates the Rules of React in subtle ways that the compiler couldn‚Äôt detect, and the compiler mistakenly compiled a component it should have skipped.\n\nWhen debugging runtime issues, focus your efforts on finding Rules of React violations in the affected components that were not detected by the ESLint rule. The compiler relies on your code following these rules, and when they‚Äôre broken in ways it can‚Äôt detect, that‚Äôs when runtime problems occur.\n\nCommon Breaking Patterns \n\nOne of the main ways React Compiler can break your app is if your code was written to rely on memoization for correctness. This means your app depends on specific values being memoized to work properly. Since the compiler may memoize differently than your manual approach, this can lead to unexpected behavior like effects over-firing, infinite loops, or missing updates.\n\nCommon scenarios where this occurs:\n\nEffects that rely on referential equality - When effects depend on objects or arrays maintaining the same reference across renders\nDependency arrays that need stable references - When unstable dependencies cause effects to fire too often or create infinite loops\nConditional logic based on reference checks - When code uses referential equality checks for caching or optimization\nDebugging Workflow \n\nFollow these steps when you encounter issues:\n\nCompiler Build Errors \n\nIf you encounter a compiler error that unexpectedly breaks your build, this is likely a bug in the compiler. Report it to the facebook/react repository with:\n\nThe error message\nThe code that caused the error\nYour React and compiler versions\nRuntime Issues \n\nFor runtime behavior issues:\n\n1. Temporarily Disable Compilation \n\nUse \"use no memo\" to isolate whether an issue is compiler-related:\n\nfunction ProblematicComponent() {\n\n \"use no memo\"; // Skip compilation for this component\n\n // ... rest of component\n\n}\n\nIf the issue disappears, it‚Äôs likely related to a Rules of React violation.\n\nYou can also try removing manual memoization (useMemo, useCallback, memo) from the problematic component to verify that your app works correctly without any memoization. If the bug still occurs when all memoization is removed, you have a Rules of React violation that needs to be fixed.\n\n2. Fix Issues Step by Step \nIdentify the root cause (often memoization-for-correctness)\nTest after each fix\nRemove \"use no memo\" once fixed\nVerify the component shows the ‚ú® badge in React DevTools\nReporting Compiler Bugs \n\nIf you believe you‚Äôve found a compiler bug:\n\nVerify it‚Äôs not a Rules of React violation - Check with ESLint\nCreate a minimal reproduction - Isolate the issue in a small example\nTest without the compiler - Confirm the issue only occurs with compilation\nFile an issue:\nReact and compiler versions\nMinimal reproduction code\nExpected vs actual behavior\nAny error messages\nNext Steps \nReview the Rules of React to prevent issues\nCheck the incremental adoption guide for gradual rollout strategies\nPREVIOUS\nIncremental Adoption",
      "tables": [],
      "code_blocks": [
        "\"use no memo\"",
        "function ProblematicComponent() {\n\n  \"use no memo\"; // Skip compilation for this component\n\n  // ... rest of component\n\n}",
        "function ProblematicComponent() {\n\n  \"use no memo\"; // Skip compilation for this component\n\n  // ... rest of component\n\n}",
        "\"use no memo\""
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 613
    },
    {
      "url": "https://react.dev/learn/updating-arrays-in-state",
      "title": "Updating Arrays in State",
      "breadcrumb": [],
      "section_path": [
        "Adding Interactivity",
        "Updating Arrays in State"
      ],
      "headings": {
        "h1": [
          "Updating Arrays in State"
        ],
        "h2": [
          "Updating arrays without mutation",
          "Updating objects inside arrays",
          "Recap",
          "Try out some challenges"
        ],
        "h3": [
          "You will learn",
          "Pitfall",
          "Adding to an array",
          "Removing from an array",
          "Transforming an array",
          "Replacing items in an array",
          "Inserting into an array",
          "Making other changes to an array",
          "Write concise update logic with Immer"
        ],
        "h4": [
          "Challenge 1 of 4: Update an item in the shopping cart"
        ]
      },
      "text_content": "LEARN REACT\nADDING INTERACTIVITY\nUpdating Arrays in State\n\nArrays are mutable in JavaScript, but you should treat them as immutable when you store them in state. Just like with objects, when you want to update an array stored in state, you need to create a new one (or make a copy of an existing one), and then set state to use the new array.\n\nYou will learn\nHow to add, remove, or change items in an array in React state\nHow to update an object inside of an array\nHow to make array copying less repetitive with Immer\nUpdating arrays without mutation \n\nIn JavaScript, arrays are just another kind of object. Like with objects, you should treat arrays in React state as read-only. This means that you shouldn‚Äôt reassign items inside an array like arr[0] = 'bird', and you also shouldn‚Äôt use methods that mutate the array, such as push() and pop().\n\nInstead, every time you want to update an array, you‚Äôll want to pass a new array to your state setting function. To do that, you can create a new array from the original array in your state by calling its non-mutating methods like filter() and map(). Then you can set your state to the resulting new array.\n\nHere is a reference table of common array operations. When dealing with arrays inside React state, you will need to avoid the methods in the left column, and instead prefer the methods in the right column:\n\n\tavoid (mutates the array)\tprefer (returns a new array)\nadding\tpush, unshift\tconcat, [...arr] spread syntax (example)\nremoving\tpop, shift, splice\tfilter, slice (example)\nreplacing\tsplice, arr[i] = ... assignment\tmap (example)\nsorting\treverse, sort\tcopy the array first (example)\n\nAlternatively, you can use Immer which lets you use methods from both columns.\n\nPitfall\n\nUnfortunately, slice and splice are named similarly but are very different:\n\nslice lets you copy an array or a part of it.\nsplice mutates the array (to insert or delete items).\n\nIn React, you will be using slice (no p!) a lot more often because you don‚Äôt want to mutate objects or arrays in state. Updating Objects explains what mutation is and why it‚Äôs not recommended for state.\n\nAdding to an array \n\npush() will mutate an array, which you don‚Äôt want:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nlet nextId = 0;\n\nexport default function List() {\n const [name, setName] = useState('');\n const [artists, setArtists] = useState([]);\n\n return (\n <>\n <h1>Inspiring sculptors:</h1>\n <input\n value={name}\n onChange={e => setName(e.target.value)}\n />\n <button onClick={() => {\n artists.push({\n id: nextId++,\n name: name,\n });\n }}>Add</button>\n <ul>\n {artists.map(artist => (\n <li key={artist.id}>{artist.name}</li>\n ))}\n </ul>\n </>\n );\n}\n\nShow more\n\nInstead, create a new array which contains the existing items and a new item at the end. There are multiple ways to do this, but the easiest one is to use the ... array spread syntax:\n\nsetArtists( // Replace the state\n\n [ // with a new array\n\n ...artists, // that contains all the old items\n\n { id: nextId++, name: name } // and one new item at the end\n\n ]\n\n);\n\nNow it works correctly:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nlet nextId = 0;\n\nexport default function List() {\n const [name, setName] = useState('');\n const [artists, setArtists] = useState([]);\n\n return (\n <>\n <h1>Inspiring sculptors:</h1>\n <input\n value={name}\n onChange={e => setName(e.target.value)}\n />\n <button onClick={() => {\n setArtists([\n ...artists,\n { id: nextId++, name: name }\n ]);\n }}>Add</button>\n <ul>\n {artists.map(artist => (\n <li key={artist.id}>{artist.name}</li>\n ))}\n </ul>\n </>\n );\n}\n\nShow more\n\nThe array spread syntax also lets you prepend an item by placing it before the original ...artists:\n\nsetArtists([\n\n { id: nextId++, name: name },\n\n ...artists // Put old items at the end\n\n]);\n\nIn this way, spread can do the job of both push() by adding to the end of an array and unshift() by adding to the beginning of an array. Try it in the sandbox above!\n\nRemoving from an array \n\nThe easiest way to remove an item from an array is to filter it out. In other words, you will produce a new array that will not contain that item. To do this, use the filter method, for example:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nlet initialArtists = [\n { id: 0, name: 'Marta Colvin Andrade' },\n { id: 1, name: 'Lamidi Olonade Fakeye'},\n { id: 2, name: 'Louise Nevelson'},\n];\n\nexport default function List() {\n const [artists, setArtists] = useState(\n initialArtists\n );\n\n return (\n <>\n <h1>Inspiring sculptors:</h1>\n <ul>\n {artists.map(artist => (\n <li key={artist.id}>\n {artist.name}{' '}\n <button onClick={() => {\n setArtists(\n artists.filter(a =>\n a.id !== artist.id\n )\n );\n }}>\n Delete\n </button>\n </li>\n ))}\n </ul>\n </>\n );\n}\n\nShow more\n\nClick the ‚ÄúDelete‚Äù button a few times, and look at its click handler.\n\nsetArtists(\n\n artists.filter(a => a.id !== artist.id)\n\n);\n\nHere, artists.filter(a => a.id !== artist.id) means ‚Äúcreate an array that consists of those artists whose IDs are different from artist.id‚Äù. In other words, each artist‚Äôs ‚ÄúDelete‚Äù button will filter that artist out of the array, and then request a re-render with the resulting array. Note that filter does not modify the original array.\n\nTransforming an array \n\nIf you want to change some or all items of the array, you can use map() to create a new array. The function you will pass to map can decide what to do with each item, based on its data or its index (or both).\n\nIn this example, an array holds coordinates of two circles and a square. When you press the button, it moves only the circles down by 50 pixels. It does this by producing a new array of data using map():\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nlet initialShapes = [\n { id: 0, type: 'circle', x: 50, y: 100 },\n { id: 1, type: 'square', x: 150, y: 100 },\n { id: 2, type: 'circle', x: 250, y: 100 },\n];\n\nexport default function ShapeEditor() {\n const [shapes, setShapes] = useState(\n initialShapes\n );\n\n function handleClick() {\n const nextShapes = shapes.map(shape => {\n if (shape.type === 'square') {\n // No change\n return shape;\n } else {\n // Return a new circle 50px below\n return {\n ...shape,\n y: shape.y + 50,\n };\n }\n });\n // Re-render with the new array\n setShapes(nextShapes);\n }\n\n return (\n <>\n <button onClick={handleClick}>\n Move circles down!\n </button>\n {shapes.map(shape => (\n <div\n key={shape.id}\n style={{\n background: 'purple',\n position: 'absolute',\n left: shape.x,\n top: shape.y,\n borderRadius:\n shape.type === 'circle'\n ? '50%' : '',\n width: 20,\n height: 20,\n }} />\n ))}\n </>\n );\n}\n\nShow more\nReplacing items in an array \n\nIt is particularly common to want to replace one or more items in an array. Assignments like arr[0] = 'bird' are mutating the original array, so instead you‚Äôll want to use map for this as well.\n\nTo replace an item, create a new array with map. Inside your map call, you will receive the item index as the second argument. Use it to decide whether to return the original item (the first argument) or something else:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nlet initialCounters = [\n 0, 0, 0\n];\n\nexport default function CounterList() {\n const [counters, setCounters] = useState(\n initialCounters\n );\n\n function handleIncrementClick(index) {\n const nextCounters = counters.map((c, i) => {\n if (i === index) {\n // Increment the clicked counter\n return c + 1;\n } else {\n // The rest haven't changed\n return c;\n }\n });\n setCounters(nextCounters);\n }\n\n return (\n <ul>\n {counters.map((counter, i) => (\n <li key={i}>\n {counter}\n <button onClick={() => {\n handleIncrementClick(i);\n }}>+1</button>\n </li>\n ))}\n </ul>\n );\n}\n\nShow more\nInserting into an array \n\nSometimes, you may want to insert an item at a particular position that‚Äôs neither at the beginning nor at the end. To do this, you can use the ... array spread syntax together with the slice() method. The slice() method lets you cut a ‚Äúslice‚Äù of the array. To insert an item, you will create an array that spreads the slice before the insertion point, then the new item, and then the rest of the original array.\n\nIn this example, the Insert button always inserts at the index 1:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nlet nextId = 3;\nconst initialArtists = [\n { id: 0, name: 'Marta Colvin Andrade' },\n { id: 1, name: 'Lamidi Olonade Fakeye'},\n { id: 2, name: 'Louise Nevelson'},\n];\n\nexport default function List() {\n const [name, setName] = useState('');\n const [artists, setArtists] = useState(\n initialArtists\n );\n\n function handleClick() {\n const insertAt = 1; // Could be any index\n const nextArtists = [\n // Items before the insertion point:\n ...artists.slice(0, insertAt),\n // New item:\n { id: nextId++, name: name },\n // Items after the insertion point:\n ...artists.slice(insertAt)\n ];\n setArtists(nextArtists);\n setName('');\n }\n\n return (\n <>\n <h1>Inspiring sculptors:</h1>\n <input\n value={name}\n onChange={e => setName(e.target.value)}\n />\n <button onClick={handleClick}>\n Insert\n </button>\n <ul>\n {artists.map(artist => (\n <li key={artist.id}>{artist.name}</li>\n ))}\n </ul>\n </>\n );\n}\n\nShow more\nMaking other changes to an array \n\nThere are some things you can‚Äôt do with the spread syntax and non-mutating methods like map() and filter() alone. For example, you may want to reverse or sort an array. The JavaScript reverse() and sort() methods are mutating the original array, so you can‚Äôt use them directly.\n\nHowever, you can copy the array first, and then make changes to it.\n\nFor example:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nconst initialList = [\n { id: 0, title: 'Big Bellies' },\n { id: 1, title: 'Lunar Landscape' },\n { id: 2, title: 'Terracotta Army' },\n];\n\nexport default function List() {\n const [list, setList] = useState(initialList);\n\n function handleClick() {\n const nextList = [...list];\n nextList.reverse();\n setList(nextList);\n }\n\n return (\n <>\n <button onClick={handleClick}>\n Reverse\n </button>\n <ul>\n {list.map(artwork => (\n <li key={artwork.id}>{artwork.title}</li>\n ))}\n </ul>\n </>\n );\n}\n\nShow more\n\nHere, you use the [...list] spread syntax to create a copy of the original array first. Now that you have a copy, you can use mutating methods like nextList.reverse() or nextList.sort(), or even assign individual items with nextList[0] = \"something\".\n\nHowever, even if you copy an array, you can‚Äôt mutate existing items inside of it directly. This is because copying is shallow‚Äîthe new array will contain the same items as the original one. So if you modify an object inside the copied array, you are mutating the existing state. For example, code like this is a problem.\n\nconst nextList = [...list];\n\nnextList[0].seen = true; // Problem: mutates list[0]\n\nsetList(nextList);\n\nAlthough nextList and list are two different arrays, nextList[0] and list[0] point to the same object. So by changing nextList[0].seen, you are also changing list[0].seen. This is a state mutation, which you should avoid! You can solve this issue in a similar way to updating nested JavaScript objects‚Äîby copying individual items you want to change instead of mutating them. Here‚Äôs how.\n\nUpdating objects inside arrays \n\nObjects are not really located ‚Äúinside‚Äù arrays. They might appear to be ‚Äúinside‚Äù in code, but each object in an array is a separate value, to which the array ‚Äúpoints‚Äù. This is why you need to be careful when changing nested fields like list[0]. Another person‚Äôs artwork list may point to the same element of the array!\n\nWhen updating nested state, you need to create copies from the point where you want to update, and all the way up to the top level. Let‚Äôs see how this works.\n\nIn this example, two separate artwork lists have the same initial state. They are supposed to be isolated, but because of a mutation, their state is accidentally shared, and checking a box in one list affects the other list:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nlet nextId = 3;\nconst initialList = [\n { id: 0, title: 'Big Bellies', seen: false },\n { id: 1, title: 'Lunar Landscape', seen: false },\n { id: 2, title: 'Terracotta Army', seen: true },\n];\n\nexport default function BucketList() {\n const [myList, setMyList] = useState(initialList);\n const [yourList, setYourList] = useState(\n initialList\n );\n\n function handleToggleMyList(artworkId, nextSeen) {\n const myNextList = [...myList];\n const artwork = myNextList.find(\n a => a.id === artworkId\n );\n artwork.seen = nextSeen;\n setMyList(myNextList);\n }\n\n function handleToggleYourList(artworkId, nextSeen) {\n const yourNextList = [...yourList];\n const artwork = yourNextList.find(\n a => a.id === artworkId\n );\n artwork.seen = nextSeen;\n setYourList(yourNextList);\n }\n\n return (\n <>\n <h1>Art Bucket List</h1>\n <h2>My list of art to see:</h2>\n <ItemList\n artworks={myList}\n onToggle={handleToggleMyList} />\n <h2>Your list of art to see:</h2>\n <ItemList\n artworks={yourList}\n onToggle={handleToggleYourList} />\n </>\n );\n}\n\nfunction ItemList({ artworks, onToggle }) {\n return (\n <ul>\n {artworks.map(artwork => (\n <li key={artwork.id}>\n <label>\n <input\n type=\"checkbox\"\n checked={artwork.seen}\n onChange={e => {\n onToggle(\n artwork.id,\n e.target.checked\n );\n }}\n />\n {artwork.title}\n </label>\n </li>\n ))}\n </ul>\n );\n}\n\nShow more\n\nThe problem is in code like this:\n\nconst myNextList = [...myList];\n\nconst artwork = myNextList.find(a => a.id === artworkId);\n\nartwork.seen = nextSeen; // Problem: mutates an existing item\n\nsetMyList(myNextList);\n\nAlthough the myNextList array itself is new, the items themselves are the same as in the original myList array. So changing artwork.seen changes the original artwork item. That artwork item is also in yourList, which causes the bug. Bugs like this can be difficult to think about, but thankfully they disappear if you avoid mutating state.\n\nYou can use map to substitute an old item with its updated version without mutation.\n\nsetMyList(myList.map(artwork => {\n\n if (artwork.id === artworkId) {\n\n // Create a *new* object with changes\n\n return { ...artwork, seen: nextSeen };\n\n } else {\n\n // No changes\n\n return artwork;\n\n }\n\n}));\n\nHere, ... is the object spread syntax used to create a copy of an object.\n\nWith this approach, none of the existing state items are being mutated, and the bug is fixed:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nlet nextId = 3;\nconst initialList = [\n { id: 0, title: 'Big Bellies', seen: false },\n { id: 1, title: 'Lunar Landscape', seen: false },\n { id: 2, title: 'Terracotta Army', seen: true },\n];\n\nexport default function BucketList() {\n const [myList, setMyList] = useState(initialList);\n const [yourList, setYourList] = useState(\n initialList\n );\n\n function handleToggleMyList(artworkId, nextSeen) {\n setMyList(myList.map(artwork => {\n if (artwork.id === artworkId) {\n // Create a *new* object with changes\n return { ...artwork, seen: nextSeen };\n } else {\n // No changes\n return artwork;\n }\n }));\n }\n\n function handleToggleYourList(artworkId, nextSeen) {\n setYourList(yourList.map(artwork => {\n if (artwork.id === artworkId) {\n // Create a *new* object with changes\n return { ...artwork, seen: nextSeen };\n } else {\n // No changes\n return artwork;\n }\n }));\n }\n\n return (\n <>\n <h1>Art Bucket List</h1>\n <h2>My list of art to see:</h2>\n <ItemList\n artworks={myList}\n onToggle={handleToggleMyList} />\n <h2>Your list of art to see:</h2>\n <ItemList\n artworks={yourList}\n onToggle={handleToggleYourList} />\n </>\n );\n}\n\nfunction ItemList({ artworks, onToggle }) {\n return (\n <ul>\n {artworks.map(artwork => (\n <li key={artwork.id}>\n <label>\n <input\n type=\"checkbox\"\n checked={artwork.seen}\n onChange={e => {\n onToggle(\n artwork.id,\n e.target.checked\n );\n }}\n />\n {artwork.title}\n </label>\n </li>\n ))}\n </ul>\n );\n}\n\nShow more\n\nIn general, you should only mutate objects that you have just created. If you were inserting a new artwork, you could mutate it, but if you‚Äôre dealing with something that‚Äôs already in state, you need to make a copy.\n\nWrite concise update logic with Immer \n\nUpdating nested arrays without mutation can get a little bit repetitive. Just as with objects:\n\nGenerally, you shouldn‚Äôt need to update state more than a couple of levels deep. If your state objects are very deep, you might want to restructure them differently so that they are flat.\nIf you don‚Äôt want to change your state structure, you might prefer to use Immer, which lets you write using the convenient but mutating syntax and takes care of producing the copies for you.\n\nHere is the Art Bucket List example rewritten with Immer:\n\npackage.json\nApp.js\nReload\nClear\nFork\n{\n \"dependencies\": {\n \"immer\": \"1.7.3\",\n \"react\": \"latest\",\n \"react-dom\": \"latest\",\n \"react-scripts\": \"latest\",\n \"use-immer\": \"0.5.1\"\n },\n \"scripts\": {\n \"start\": \"react-scripts start\",\n \"build\": \"react-scripts build\",\n \"test\": \"react-scripts test --env=jsdom\",\n \"eject\": \"react-scripts eject\"\n },\n \"devDependencies\": {}\n}\n\nNote how with Immer, mutation like artwork.seen = nextSeen is now okay:\n\nupdateMyTodos(draft => {\n\n const artwork = draft.find(a => a.id === artworkId);\n\n artwork.seen = nextSeen;\n\n});\n\nThis is because you‚Äôre not mutating the original state, but you‚Äôre mutating a special draft object provided by Immer. Similarly, you can apply mutating methods like push() and pop() to the content of the draft.\n\nBehind the scenes, Immer always constructs the next state from scratch according to the changes that you‚Äôve done to the draft. This keeps your event handlers very concise without ever mutating state.\n\nRecap\nYou can put arrays into state, but you can‚Äôt change them.\nInstead of mutating an array, create a new version of it, and update the state to it.\nYou can use the [...arr, newItem] array spread syntax to create arrays with new items.\nYou can use filter() and map() to create new arrays with filtered or transformed items.\nYou can use Immer to keep your code concise.\nTry out some challenges\n1. Update an item in the shopping cart\n2. Remove an item from the shopping cart\n3. Fix the mutations using non-mutative methods\n4. Fix the mutations using Immer\nChallenge 1 of 4: Update an item in the shopping cart \n\nFill in the handleIncreaseClick logic so that pressing ‚Äù+‚Äù increases the corresponding number:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nconst initialProducts = [{\n id: 0,\n name: 'Baklava',\n count: 1,\n}, {\n id: 1,\n name: 'Cheese',\n count: 5,\n}, {\n id: 2,\n name: 'Spaghetti',\n count: 2,\n}];\n\nexport default function ShoppingCart() {\n const [\n products,\n setProducts\n ] = useState(initialProducts)\n\n function handleIncreaseClick(productId) {\n\n }\n\n return (\n <ul>\n {products.map(product => (\n <li key={product.id}>\n {product.name}\n {' '}\n (<b>{product.count}</b>)\n <button onClick={() => {\n handleIncreaseClick(product.id);\n }}>\n +\n </button>\n </li>\n ))}\n </ul>\n );\n}\n\nShow more\nShow solution\nNext Challenge\nPREVIOUS\nUpdating Objects in State\nNEXT\nManaging State",
      "tables": [
        {
          "headers": [
            "",
            "avoid (mutates the array)",
            "prefer (returns a new array)"
          ],
          "rows": [
            [
              "adding",
              "push, unshift",
              "concat, [...arr] spread syntax (example)"
            ],
            [
              "removing",
              "pop, shift, splice",
              "filter, slice (example)"
            ],
            [
              "replacing",
              "splice, arr[i] = ... assignment",
              "map (example)"
            ],
            [
              "sorting",
              "reverse, sort",
              "copy the array first (example)"
            ]
          ]
        }
      ],
      "code_blocks": [
        "arr[0] = 'bird'",
        "arr[i] = ...",
        "import { useState } from 'react';\n\nlet nextId = 0;\n\nexport default function List() {\n  const [name, setName] = useState('');\n  const [artists, setArtists] = useState([]);\n\n  return (\n    <>\n      <h1>Inspiring sculptors:</h1>\n      <input\n        value={name}\n        onChange={e => setName(e.target.value)}\n      />\n      <button onClick={() => {\n        artists.push({\n          id: nextId++,\n          name: name,\n        });\n      }}>Add</button>\n      <ul>\n        {artists.map(artist => (\n          <li key={artist.id}>{artist.name}</li>\n        ))}\n      </ul>\n    </>\n  );\n}",
        "setArtists( // Replace the state\n\n  [ // with a new array\n\n    ...artists, // that contains all the old items\n\n    { id: nextId++, name: name } // and one new item at the end\n\n  ]\n\n);",
        "setArtists( // Replace the state\n\n  [ // with a new array\n\n    ...artists, // that contains all the old items\n\n    { id: nextId++, name: name } // and one new item at the end\n\n  ]\n\n);",
        "import { useState } from 'react';\n\nlet nextId = 0;\n\nexport default function List() {\n  const [name, setName] = useState('');\n  const [artists, setArtists] = useState([]);\n\n  return (\n    <>\n      <h1>Inspiring sculptors:</h1>\n      <input\n        value={name}\n        onChange={e => setName(e.target.value)}\n      />\n      <button onClick={() => {\n        setArtists([\n          ...artists,\n          { id: nextId++, name: name }\n        ]);\n      }}>Add</button>\n      <ul>\n        {artists.map(artist => (\n          <li key={artist.id}>{artist.name}</li>\n        ))}\n      </ul>\n    </>\n  );\n}",
        "setArtists([\n\n  { id: nextId++, name: name },\n\n  ...artists // Put old items at the end\n\n]);",
        "setArtists([\n\n  { id: nextId++, name: name },\n\n  ...artists // Put old items at the end\n\n]);",
        "import { useState } from 'react';\n\nlet initialArtists = [\n  { id: 0, name: 'Marta Colvin Andrade' },\n  { id: 1, name: 'Lamidi Olonade Fakeye'},\n  { id: 2, name: 'Louise Nevelson'},\n];\n\nexport default function List() {\n  const [artists, setArtists] = useState(\n    initialArtists\n  );\n\n  return (\n    <>\n      <h1>Inspiring sculptors:</h1>\n      <ul>\n        {artists.map(artist => (\n          <li key={artist.id}>\n            {artist.name}{' '}\n            <button onClick={() => {\n              setArtists(\n                artists.filter(a =>\n                  a.id !== artist.id\n                )\n              );\n            }}>\n              Delete\n            </button>\n          </li>\n        ))}\n      </ul>\n    </>\n  );\n}",
        "setArtists(\n\n  artists.filter(a => a.id !== artist.id)\n\n);",
        "setArtists(\n\n  artists.filter(a => a.id !== artist.id)\n\n);",
        "artists.filter(a => a.id !== artist.id)",
        "import { useState } from 'react';\n\nlet initialShapes = [\n  { id: 0, type: 'circle', x: 50, y: 100 },\n  { id: 1, type: 'square', x: 150, y: 100 },\n  { id: 2, type: 'circle', x: 250, y: 100 },\n];\n\nexport default function ShapeEditor() {\n  const [shapes, setShapes] = useState(\n    initialShapes\n  );\n\n  function handleClick() {\n    const nextShapes = shapes.map(shape => {\n      if (shape.type === 'square') {\n        // No change\n        return shape;\n      } else {\n        // Return a new circle 50px below\n        return {\n          ...shape,\n          y: shape.y + 50,\n        };\n      }\n    });\n    // Re-render with the new array\n    setShapes(nextShapes);\n  }\n\n  return (\n    <>\n      <button onClick={handleClick}>\n        Move circles down!\n      </button>\n      {shapes.map(shape => (\n        <div\n          key={shape.id}\n          style={{\n          background: 'purple',\n          position: 'absolute',\n          left: shape.x,\n          top: shape.y,\n          borderRadius:\n            shape.type === 'circle'\n              ? '50%' : '',\n          width: 20,\n          height: 20,\n        }} />\n      ))}\n    </>\n  );\n}",
        "arr[0] = 'bird'",
        "import { useState } from 'react';\n\nlet initialCounters = [\n  0, 0, 0\n];\n\nexport default function CounterList() {\n  const [counters, setCounters] = useState(\n    initialCounters\n  );\n\n  function handleIncrementClick(index) {\n    const nextCounters = counters.map((c, i) => {\n      if (i === index) {\n        // Increment the clicked counter\n        return c + 1;\n      } else {\n        // The rest haven't changed\n        return c;\n      }\n    });\n    setCounters(nextCounters);\n  }\n\n  return (\n    <ul>\n      {counters.map((counter, i) => (\n        <li key={i}>\n          {counter}\n          <button onClick={() => {\n            handleIncrementClick(i);\n          }}>+1</button>\n        </li>\n      ))}\n    </ul>\n  );\n}",
        "import { useState } from 'react';\n\nlet nextId = 3;\nconst initialArtists = [\n  { id: 0, name: 'Marta Colvin Andrade' },\n  { id: 1, name: 'Lamidi Olonade Fakeye'},\n  { id: 2, name: 'Louise Nevelson'},\n];\n\nexport default function List() {\n  const [name, setName] = useState('');\n  const [artists, setArtists] = useState(\n    initialArtists\n  );\n\n  function handleClick() {\n    const insertAt = 1; // Could be any index\n    const nextArtists = [\n      // Items before the insertion point:\n      ...artists.slice(0, insertAt),\n      // New item:\n      { id: nextId++, name: name },\n      // Items after the insertion point:\n      ...artists.slice(insertAt)\n    ];\n    setArtists(nextArtists);\n    setName('');\n  }\n\n  return (\n    <>\n      <h1>Inspiring sculptors:</h1>\n      <input\n        value={name}\n        onChange={e => setName(e.target.value)}\n      />\n      <button onClick={handleClick}>\n        Insert\n      </button>\n      <ul>\n        {artists.map(artist => (\n          <li key={artist.id}>{artist.name}</li>\n        ))}\n      </ul>\n    </>\n  );\n}",
        "import { useState } from 'react';\n\nconst initialList = [\n  { id: 0, title: 'Big Bellies' },\n  { id: 1, title: 'Lunar Landscape' },\n  { id: 2, title: 'Terracotta Army' },\n];\n\nexport default function List() {\n  const [list, setList] = useState(initialList);\n\n  function handleClick() {\n    const nextList = [...list];\n    nextList.reverse();\n    setList(nextList);\n  }\n\n  return (\n    <>\n      <button onClick={handleClick}>\n        Reverse\n      </button>\n      <ul>\n        {list.map(artwork => (\n          <li key={artwork.id}>{artwork.title}</li>\n        ))}\n      </ul>\n    </>\n  );\n}",
        "nextList.reverse()",
        "nextList.sort()",
        "nextList[0] = \"something\"",
        "const nextList = [...list];\n\nnextList[0].seen = true; // Problem: mutates list[0]\n\nsetList(nextList);",
        "const nextList = [...list];\n\nnextList[0].seen = true; // Problem: mutates list[0]\n\nsetList(nextList);",
        "nextList[0]",
        "nextList[0].seen",
        "list[0].seen",
        "import { useState } from 'react';\n\nlet nextId = 3;\nconst initialList = [\n  { id: 0, title: 'Big Bellies', seen: false },\n  { id: 1, title: 'Lunar Landscape', seen: false },\n  { id: 2, title: 'Terracotta Army', seen: true },\n];\n\nexport default function BucketList() {\n  const [myList, setMyList] = useState(initialList);\n  const [yourList, setYourList] = useState(\n    initialList\n  );\n\n  function handleToggleMyList(artworkId, nextSeen) {\n    const myNextList = [...myList];\n    const artwork = myNextList.find(\n      a => a.id === artworkId\n    );\n    artwork.seen = nextSeen;\n    setMyList(myNextList);\n  }\n\n  function handleToggleYourList(artworkId, nextSeen) {\n    const yourNextList = [...yourList];\n    const artwork = yourNextList.find(\n      a => a.id === artworkId\n    );\n    artwork.seen = nextSeen;\n    setYourList(yourNextList);\n  }\n\n  return (\n    <>\n      <h1>Art Bucket List</h1>\n      <h2>My list of art to see:</h2>\n      <ItemList\n        artworks={myList}\n        onToggle={handleToggleMyList} />\n      <h2>Your list of art to see:</h2>\n      <ItemList\n        artworks={yourList}\n        onToggle={handleToggleYourList} />\n    </>\n  );\n}\n\nfunction ItemList({ artworks, onToggle }) {\n  return (\n    <ul>\n      {artworks.map(artwork => (\n        <li key={artwork.id}>\n          <label>\n            <input\n              type=\"checkbox\"\n              checked={artwork.seen}\n              onChange={e => {\n                onToggle(\n                  artwork.id,\n                  e.target.checked\n                );\n              }}\n            />\n            {artwork.title}\n          </label>\n        </li>\n      ))}\n    </ul>\n  );\n}",
        "const myNextList = [...myList];\n\nconst artwork = myNextList.find(a => a.id === artworkId);\n\nartwork.seen = nextSeen; // Problem: mutates an existing item\n\nsetMyList(myNextList);",
        "const myNextList = [...myList];\n\nconst artwork = myNextList.find(a => a.id === artworkId);\n\nartwork.seen = nextSeen; // Problem: mutates an existing item\n\nsetMyList(myNextList);",
        "artwork.seen",
        "setMyList(myList.map(artwork => {\n\n  if (artwork.id === artworkId) {\n\n    // Create a *new* object with changes\n\n    return { ...artwork, seen: nextSeen };\n\n  } else {\n\n    // No changes\n\n    return artwork;\n\n  }\n\n}));",
        "setMyList(myList.map(artwork => {\n\n  if (artwork.id === artworkId) {\n\n    // Create a *new* object with changes\n\n    return { ...artwork, seen: nextSeen };\n\n  } else {\n\n    // No changes\n\n    return artwork;\n\n  }\n\n}));",
        "import { useState } from 'react';\n\nlet nextId = 3;\nconst initialList = [\n  { id: 0, title: 'Big Bellies', seen: false },\n  { id: 1, title: 'Lunar Landscape', seen: false },\n  { id: 2, title: 'Terracotta Army', seen: true },\n];\n\nexport default function BucketList() {\n  const [myList, setMyList] = useState(initialList);\n  const [yourList, setYourList] = useState(\n    initialList\n  );\n\n  function handleToggleMyList(artworkId, nextSeen) {\n    setMyList(myList.map(artwork => {\n      if (artwork.id === artworkId) {\n        // Create a *new* object with changes\n        return { ...artwork, seen: nextSeen };\n      } else {\n        // No changes\n        return artwork;\n      }\n    }));\n  }\n\n  function handleToggleYourList(artworkId, nextSeen) {\n    setYourList(yourList.map(artwork => {\n      if (artwork.id === artworkId) {\n        // Create a *new* object with changes\n        return { ...artwork, seen: nextSeen };\n      } else {\n        // No changes\n        return artwork;\n      }\n    }));\n  }\n\n  return (\n    <>\n      <h1>Art Bucket List</h1>\n      <h2>My list of art to see:</h2>\n      <ItemList\n        artworks={myList}\n        onToggle={handleToggleMyList} />\n      <h2>Your list of art to see:</h2>\n      <ItemList\n        artworks={yourList}\n        onToggle={handleToggleYourList} />\n    </>\n  );\n}\n\nfunction ItemList({ artworks, onToggle }) {\n  return (\n    <ul>\n      {artworks.map(artwork => (\n        <li key={artwork.id}>\n          <label>\n            <input\n              type=\"checkbox\"\n              checked={artwork.seen}\n              onChange={e => {\n                onToggle(\n                  artwork.id,\n                  e.target.checked\n                );\n              }}\n            />\n            {artwork.title}\n          </label>\n        </li>\n      ))}\n    </ul>\n  );\n}",
        "{\n  \"dependencies\": {\n    \"immer\": \"1.7.3\",\n    \"react\": \"latest\",\n    \"react-dom\": \"latest\",\n    \"react-scripts\": \"latest\",\n    \"use-immer\": \"0.5.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test --env=jsdom\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"devDependencies\": {}\n}",
        "artwork.seen = nextSeen",
        "updateMyTodos(draft => {\n\n  const artwork = draft.find(a => a.id === artworkId);\n\n  artwork.seen = nextSeen;\n\n});",
        "updateMyTodos(draft => {\n\n  const artwork = draft.find(a => a.id === artworkId);\n\n  artwork.seen = nextSeen;\n\n});",
        "[...arr, newItem]",
        "handleIncreaseClick",
        "import { useState } from 'react';\n\nconst initialProducts = [{\n  id: 0,\n  name: 'Baklava',\n  count: 1,\n}, {\n  id: 1,\n  name: 'Cheese',\n  count: 5,\n}, {\n  id: 2,\n  name: 'Spaghetti',\n  count: 2,\n}];\n\nexport default function ShoppingCart() {\n  const [\n    products,\n    setProducts\n  ] = useState(initialProducts)\n\n  function handleIncreaseClick(productId) {\n\n  }\n\n  return (\n    <ul>\n      {products.map(product => (\n        <li key={product.id}>\n          {product.name}\n          {' '}\n          (<b>{product.count}</b>)\n          <button onClick={() => {\n            handleIncreaseClick(product.id);\n          }}>\n            +\n          </button>\n        </li>\n      ))}\n    </ul>\n  );\n}"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 2961
    },
    {
      "url": "https://react.dev/learn/separating-events-from-effects",
      "title": "Separating Events from Effects",
      "breadcrumb": [],
      "section_path": [
        "Escape Hatches",
        "Separating Events from Effects"
      ],
      "headings": {
        "h1": [
          "Separating Events from Effects"
        ],
        "h2": [
          "Choosing between event handlers and Effects",
          "Reactive values and reactive logic",
          "Extracting non-reactive logic out of Effects",
          "Recap",
          "Try out some challenges"
        ],
        "h3": [
          "You will learn",
          "Event handlers run in response to specific interactions",
          "Effects run whenever synchronization is needed",
          "Logic inside event handlers is not reactive",
          "Logic inside Effects is reactive",
          "Declaring an Effect Event",
          "Reading latest props and state with Effect Events",
          "Note",
          "Limitations of Effect Events"
        ],
        "h4": [
          "Is it okay to suppress the dependency linter instead?",
          "Challenge 1 of 4: Fix a variable that doesn‚Äôt update"
        ],
        "h5": [
          "DEEP DIVE"
        ]
      },
      "text_content": "LEARN REACT\nESCAPE HATCHES\nSeparating Events from Effects\n\nEvent handlers only re-run when you perform the same interaction again. Unlike event handlers, Effects re-synchronize if some value they read, like a prop or a state variable, is different from what it was during the last render. Sometimes, you also want a mix of both behaviors: an Effect that re-runs in response to some values but not others. This page will teach you how to do that.\n\nYou will learn\nHow to choose between an event handler and an Effect\nWhy Effects are reactive, and event handlers are not\nWhat to do when you want a part of your Effect‚Äôs code to not be reactive\nWhat Effect Events are, and how to extract them from your Effects\nHow to read the latest props and state from Effects using Effect Events\nChoosing between event handlers and Effects \n\nFirst, let‚Äôs recap the difference between event handlers and Effects.\n\nImagine you‚Äôre implementing a chat room component. Your requirements look like this:\n\nYour component should automatically connect to the selected chat room.\nWhen you click the ‚ÄúSend‚Äù button, it should send a message to the chat.\n\nLet‚Äôs say you‚Äôve already implemented the code for them, but you‚Äôre not sure where to put it. Should you use event handlers or Effects? Every time you need to answer this question, consider why the code needs to run.\n\nEvent handlers run in response to specific interactions \n\nFrom the user‚Äôs perspective, sending a message should happen because the particular ‚ÄúSend‚Äù button was clicked. The user will get rather upset if you send their message at any other time or for any other reason. This is why sending a message should be an event handler. Event handlers let you handle specific interactions:\n\nfunction ChatRoom({ roomId }) {\n\n const [message, setMessage] = useState('');\n\n // ...\n\n function handleSendClick() {\n\n sendMessage(message);\n\n }\n\n // ...\n\n return (\n\n <>\n\n <input value={message} onChange={e => setMessage(e.target.value)} />\n\n <button onClick={handleSendClick}>Send</button>\n\n </>\n\n );\n\n}\n\nWith an event handler, you can be sure that sendMessage(message) will only run if the user presses the button.\n\nEffects run whenever synchronization is needed \n\nRecall that you also need to keep the component connected to the chat room. Where does that code go?\n\nThe reason to run this code is not some particular interaction. It doesn‚Äôt matter why or how the user navigated to the chat room screen. Now that they‚Äôre looking at it and could interact with it, the component needs to stay connected to the selected chat server. Even if the chat room component was the initial screen of your app, and the user has not performed any interactions at all, you would still need to connect. This is why it‚Äôs an Effect:\n\nfunction ChatRoom({ roomId }) {\n\n // ...\n\n useEffect(() => {\n\n const connection = createConnection(serverUrl, roomId);\n\n connection.connect();\n\n return () => {\n\n connection.disconnect();\n\n };\n\n }, [roomId]);\n\n // ...\n\n}\n\nWith this code, you can be sure that there is always an active connection to the currently selected chat server, regardless of the specific interactions performed by the user. Whether the user has only opened your app, selected a different room, or navigated to another screen and back, your Effect ensures that the component will remain synchronized with the currently selected room, and will re-connect whenever it‚Äôs necessary.\n\nApp.js\nchat.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { createConnection, sendMessage } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n const [message, setMessage] = useState('');\n\n useEffect(() => {\n const connection = createConnection(serverUrl, roomId);\n connection.connect();\n return () => connection.disconnect();\n }, [roomId]);\n\n function handleSendClick() {\n sendMessage(message);\n }\n\n return (\n <>\n <h1>Welcome to the {roomId} room!</h1>\n <input value={message} onChange={e => setMessage(e.target.value)} />\n <button onClick={handleSendClick}>Send</button>\n </>\n );\n}\n\nexport default function App() {\n const [roomId, setRoomId] = useState('general');\n const [show, setShow] = useState(false);\n return (\n <>\n <label>\n Choose the chat room:{' '}\n <select\n value={roomId}\n onChange={e => setRoomId(e.target.value)}\n >\n <option value=\"general\">general</option>\n <option value=\"travel\">travel</option>\n <option value=\"music\">music</option>\n </select>\n </label>\n <button onClick={() => setShow(!show)}>\n {show ? 'Close chat' : 'Open chat'}\n </button>\n {show && <hr />}\n {show && <ChatRoom roomId={roomId} />}\n </>\n );\n}\n\nShow more\nReactive values and reactive logic \n\nIntuitively, you could say that event handlers are always triggered ‚Äúmanually‚Äù, for example by clicking a button. Effects, on the other hand, are ‚Äúautomatic‚Äù: they run and re-run as often as it‚Äôs needed to stay synchronized.\n\nThere is a more precise way to think about this.\n\nProps, state, and variables declared inside your component‚Äôs body are called reactive values. In this example, serverUrl is not a reactive value, but roomId and message are. They participate in the rendering data flow:\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n\n const [message, setMessage] = useState('');\n\n // ...\n\n}\n\nReactive values like these can change due to a re-render. For example, the user may edit the message or choose a different roomId in a dropdown. Event handlers and Effects respond to changes differently:\n\nLogic inside event handlers is not reactive. It will not run again unless the user performs the same interaction (e.g. a click) again. Event handlers can read reactive values without ‚Äúreacting‚Äù to their changes.\nLogic inside Effects is reactive. If your Effect reads a reactive value, you have to specify it as a dependency. Then, if a re-render causes that value to change, React will re-run your Effect‚Äôs logic with the new value.\n\nLet‚Äôs revisit the previous example to illustrate this difference.\n\nLogic inside event handlers is not reactive \n\nTake a look at this line of code. Should this logic be reactive or not?\n\n // ...\n\n sendMessage(message);\n\n // ...\n\nFrom the user‚Äôs perspective, a change to the message does not mean that they want to send a message. It only means that the user is typing. In other words, the logic that sends a message should not be reactive. It should not run again only because the reactive value has changed. That‚Äôs why it belongs in the event handler:\n\n function handleSendClick() {\n\n sendMessage(message);\n\n }\n\nEvent handlers aren‚Äôt reactive, so sendMessage(message) will only run when the user clicks the Send button.\n\nLogic inside Effects is reactive \n\nNow let‚Äôs return to these lines:\n\n // ...\n\n const connection = createConnection(serverUrl, roomId);\n\n connection.connect();\n\n // ...\n\nFrom the user‚Äôs perspective, a change to the roomId does mean that they want to connect to a different room. In other words, the logic for connecting to the room should be reactive. You want these lines of code to ‚Äúkeep up‚Äù with the reactive value, and to run again if that value is different. That‚Äôs why it belongs in an Effect:\n\n useEffect(() => {\n\n const connection = createConnection(serverUrl, roomId);\n\n connection.connect();\n\n return () => {\n\n connection.disconnect()\n\n };\n\n }, [roomId]);\n\nEffects are reactive, so createConnection(serverUrl, roomId) and connection.connect() will run for every distinct value of roomId. Your Effect keeps the chat connection synchronized to the currently selected room.\n\nExtracting non-reactive logic out of Effects \n\nThings get more tricky when you want to mix reactive logic with non-reactive logic.\n\nFor example, imagine that you want to show a notification when the user connects to the chat. You read the current theme (dark or light) from the props so that you can show the notification in the correct color:\n\nfunction ChatRoom({ roomId, theme }) {\n\n useEffect(() => {\n\n const connection = createConnection(serverUrl, roomId);\n\n connection.on('connected', () => {\n\n showNotification('Connected!', theme);\n\n });\n\n connection.connect();\n\n // ...\n\nHowever, theme is a reactive value (it can change as a result of re-rendering), and every reactive value read by an Effect must be declared as its dependency. Now you have to specify theme as a dependency of your Effect:\n\nfunction ChatRoom({ roomId, theme }) {\n\n useEffect(() => {\n\n const connection = createConnection(serverUrl, roomId);\n\n connection.on('connected', () => {\n\n showNotification('Connected!', theme);\n\n });\n\n connection.connect();\n\n return () => {\n\n connection.disconnect()\n\n };\n\n }, [roomId, theme]); // ‚úÖ All dependencies declared\n\n // ...\n\nPlay with this example and see if you can spot the problem with this user experience:\n\nApp.js\nchat.js\nnotifications.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { createConnection, sendMessage } from './chat.js';\nimport { showNotification } from './notifications.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId, theme }) {\n useEffect(() => {\n const connection = createConnection(serverUrl, roomId);\n connection.on('connected', () => {\n showNotification('Connected!', theme);\n });\n connection.connect();\n return () => connection.disconnect();\n }, [roomId, theme]);\n\n return <h1>Welcome to the {roomId} room!</h1>\n}\n\nexport default function App() {\n const [roomId, setRoomId] = useState('general');\n const [isDark, setIsDark] = useState(false);\n return (\n <>\n <label>\n Choose the chat room:{' '}\n <select\n value={roomId}\n onChange={e => setRoomId(e.target.value)}\n >\n <option value=\"general\">general</option>\n <option value=\"travel\">travel</option>\n <option value=\"music\">music</option>\n </select>\n </label>\n <label>\n <input\n type=\"checkbox\"\n checked={isDark}\n onChange={e => setIsDark(e.target.checked)}\n />\n Use dark theme\n </label>\n <hr />\n <ChatRoom\n roomId={roomId}\n theme={isDark ? 'dark' : 'light'}\n />\n </>\n );\n}\n\nShow more\n\nWhen the roomId changes, the chat re-connects as you would expect. But since theme is also a dependency, the chat also re-connects every time you switch between the dark and the light theme. That‚Äôs not great!\n\nIn other words, you don‚Äôt want this line to be reactive, even though it is inside an Effect (which is reactive):\n\n // ...\n\n showNotification('Connected!', theme);\n\n // ...\n\nYou need a way to separate this non-reactive logic from the reactive Effect around it.\n\nDeclaring an Effect Event \n\nUse a special Hook called useEffectEvent to extract this non-reactive logic out of your Effect:\n\nimport { useEffect, useEffectEvent } from 'react';\n\nfunction ChatRoom({ roomId, theme }) {\n\n const onConnected = useEffectEvent(() => {\n\n showNotification('Connected!', theme);\n\n });\n\n // ...\n\nHere, onConnected is called an Effect Event. It‚Äôs a part of your Effect logic, but it behaves a lot more like an event handler. The logic inside it is not reactive, and it always ‚Äúsees‚Äù the latest values of your props and state.\n\nNow you can call the onConnected Effect Event from inside your Effect:\n\nfunction ChatRoom({ roomId, theme }) {\n\n const onConnected = useEffectEvent(() => {\n\n showNotification('Connected!', theme);\n\n });\n\n useEffect(() => {\n\n const connection = createConnection(serverUrl, roomId);\n\n connection.on('connected', () => {\n\n onConnected();\n\n });\n\n connection.connect();\n\n return () => connection.disconnect();\n\n }, [roomId]); // ‚úÖ All dependencies declared\n\n // ...\n\nThis solves the problem. Note that you had to remove theme from the list of your Effect‚Äôs dependencies, because it‚Äôs no longer used in the Effect. You also don‚Äôt need to add onConnected to it, because Effect Events are not reactive and must be omitted from dependencies.\n\nVerify that the new behavior works as you would expect:\n\nApp.js\nchat.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { useEffectEvent } from 'react';\nimport { createConnection, sendMessage } from './chat.js';\nimport { showNotification } from './notifications.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId, theme }) {\n const onConnected = useEffectEvent(() => {\n showNotification('Connected!', theme);\n });\n\n useEffect(() => {\n const connection = createConnection(serverUrl, roomId);\n connection.on('connected', () => {\n onConnected();\n });\n connection.connect();\n return () => connection.disconnect();\n }, [roomId]);\n\n return <h1>Welcome to the {roomId} room!</h1>\n}\n\nexport default function App() {\n const [roomId, setRoomId] = useState('general');\n const [isDark, setIsDark] = useState(false);\n return (\n <>\n <label>\n Choose the chat room:{' '}\n <select\n value={roomId}\n onChange={e => setRoomId(e.target.value)}\n >\n <option value=\"general\">general</option>\n <option value=\"travel\">travel</option>\n <option value=\"music\">music</option>\n </select>\n </label>\n <label>\n <input\n type=\"checkbox\"\n checked={isDark}\n onChange={e => setIsDark(e.target.checked)}\n />\n Use dark theme\n </label>\n <hr />\n <ChatRoom\n roomId={roomId}\n theme={isDark ? 'dark' : 'light'}\n />\n </>\n );\n}\n\nShow more\n\nYou can think of Effect Events as being very similar to event handlers. The main difference is that event handlers run in response to user interactions, whereas Effect Events are triggered by you from Effects. Effect Events let you ‚Äúbreak the chain‚Äù between the reactivity of Effects and code that should not be reactive.\n\nReading latest props and state with Effect Events \n\nEffect Events let you fix many patterns where you might be tempted to suppress the dependency linter.\n\nFor example, say you have an Effect to log the page visits:\n\nfunction Page() {\n\n useEffect(() => {\n\n logVisit();\n\n }, []);\n\n // ...\n\n}\n\nLater, you add multiple routes to your site. Now your Page component receives a url prop with the current path. You want to pass the url as a part of your logVisit call, but the dependency linter complains:\n\nfunction Page({ url }) {\n\n useEffect(() => {\n\n logVisit(url);\n\n }, []); // üî¥ React Hook useEffect has a missing dependency: 'url'\n\n // ...\n\n}\n\nThink about what you want the code to do. You want to log a separate visit for different URLs since each URL represents a different page. In other words, this logVisit call should be reactive with respect to the url. This is why, in this case, it makes sense to follow the dependency linter, and add url as a dependency:\n\nfunction Page({ url }) {\n\n useEffect(() => {\n\n logVisit(url);\n\n }, [url]); // ‚úÖ All dependencies declared\n\n // ...\n\n}\n\nNow let‚Äôs say you want to include the number of items in the shopping cart together with every page visit:\n\nfunction Page({ url }) {\n\n const { items } = useContext(ShoppingCartContext);\n\n const numberOfItems = items.length;\n\n useEffect(() => {\n\n logVisit(url, numberOfItems);\n\n }, [url]); // üî¥ React Hook useEffect has a missing dependency: 'numberOfItems'\n\n // ...\n\n}\n\nYou used numberOfItems inside the Effect, so the linter asks you to add it as a dependency. However, you don‚Äôt want the logVisit call to be reactive with respect to numberOfItems. If the user puts something into the shopping cart, and the numberOfItems changes, this does not mean that the user visited the page again. In other words, visiting the page is, in some sense, an ‚Äúevent‚Äù. It happens at a precise moment in time.\n\nSplit the code in two parts:\n\nfunction Page({ url }) {\n\n const { items } = useContext(ShoppingCartContext);\n\n const numberOfItems = items.length;\n\n const onVisit = useEffectEvent(visitedUrl => {\n\n logVisit(visitedUrl, numberOfItems);\n\n });\n\n useEffect(() => {\n\n onVisit(url);\n\n }, [url]); // ‚úÖ All dependencies declared\n\n // ...\n\n}\n\nHere, onVisit is an Effect Event. The code inside it isn‚Äôt reactive. This is why you can use numberOfItems (or any other reactive value!) without worrying that it will cause the surrounding code to re-execute on changes.\n\nOn the other hand, the Effect itself remains reactive. Code inside the Effect uses the url prop, so the Effect will re-run after every re-render with a different url. This, in turn, will call the onVisit Effect Event.\n\nAs a result, you will call logVisit for every change to the url, and always read the latest numberOfItems. However, if numberOfItems changes on its own, this will not cause any of the code to re-run.\n\nNote\n\nYou might be wondering if you could call onVisit() with no arguments, and read the url inside it:\n\n const onVisit = useEffectEvent(() => {\n\n logVisit(url, numberOfItems);\n\n });\n\n useEffect(() => {\n\n onVisit();\n\n }, [url]);\n\nThis would work, but it‚Äôs better to pass this url to the Effect Event explicitly. By passing url as an argument to your Effect Event, you are saying that visiting a page with a different url constitutes a separate ‚Äúevent‚Äù from the user‚Äôs perspective. The visitedUrl is a part of the ‚Äúevent‚Äù that happened:\n\n const onVisit = useEffectEvent(visitedUrl => {\n\n logVisit(visitedUrl, numberOfItems);\n\n });\n\n useEffect(() => {\n\n onVisit(url);\n\n }, [url]);\n\nSince your Effect Event explicitly ‚Äúasks‚Äù for the visitedUrl, now you can‚Äôt accidentally remove url from the Effect‚Äôs dependencies. If you remove the url dependency (causing distinct page visits to be counted as one), the linter will warn you about it. You want onVisit to be reactive with regards to the url, so instead of reading the url inside (where it wouldn‚Äôt be reactive), you pass it from your Effect.\n\nThis becomes especially important if there is some asynchronous logic inside the Effect:\n\n const onVisit = useEffectEvent(visitedUrl => {\n\n logVisit(visitedUrl, numberOfItems);\n\n });\n\n useEffect(() => {\n\n setTimeout(() => {\n\n onVisit(url);\n\n }, 5000); // Delay logging visits\n\n }, [url]);\n\nHere, url inside onVisit corresponds to the latest url (which could have already changed), but visitedUrl corresponds to the url that originally caused this Effect (and this onVisit call) to run.\n\nDEEP DIVE\nIs it okay to suppress the dependency linter instead? \nShow Details\nLimitations of Effect Events \n\nEffect Events are very limited in how you can use them:\n\nOnly call them from inside Effects.\nNever pass them to other components or Hooks.\n\nFor example, don‚Äôt declare and pass an Effect Event like this:\n\nfunction Timer() {\n\n const [count, setCount] = useState(0);\n\n const onTick = useEffectEvent(() => {\n\n setCount(count + 1);\n\n });\n\n useTimer(onTick, 1000); // üî¥ Avoid: Passing Effect Events\n\n return <h1>{count}</h1>\n\n}\n\nfunction useTimer(callback, delay) {\n\n useEffect(() => {\n\n const id = setInterval(() => {\n\n callback();\n\n }, delay);\n\n return () => {\n\n clearInterval(id);\n\n };\n\n }, [delay, callback]); // Need to specify \"callback\" in dependencies\n\n}\n\nInstead, always declare Effect Events directly next to the Effects that use them:\n\nfunction Timer() {\n\n const [count, setCount] = useState(0);\n\n useTimer(() => {\n\n setCount(count + 1);\n\n }, 1000);\n\n return <h1>{count}</h1>\n\n}\n\nfunction useTimer(callback, delay) {\n\n const onTick = useEffectEvent(() => {\n\n callback();\n\n });\n\n useEffect(() => {\n\n const id = setInterval(() => {\n\n onTick(); // ‚úÖ Good: Only called locally inside an Effect\n\n }, delay);\n\n return () => {\n\n clearInterval(id);\n\n };\n\n }, [delay]); // No need to specify \"onTick\" (an Effect Event) as a dependency\n\n}\n\nEffect Events are non-reactive ‚Äúpieces‚Äù of your Effect code. They should be next to the Effect using them.\n\nRecap\nEvent handlers run in response to specific interactions.\nEffects run whenever synchronization is needed.\nLogic inside event handlers is not reactive.\nLogic inside Effects is reactive.\nYou can move non-reactive logic from Effects into Effect Events.\nOnly call Effect Events from inside Effects.\nDon‚Äôt pass Effect Events to other components or Hooks.\nTry out some challenges\n1. Fix a variable that doesn‚Äôt update\n2. Fix a freezing counter\n3. Fix a non-adjustable delay\n4. Fix a delayed notification\nChallenge 1 of 4: Fix a variable that doesn‚Äôt update \n\nThis Timer component keeps a count state variable which increases every second. The value by which it‚Äôs increasing is stored in the increment state variable. You can control the increment variable with the plus and minus buttons.\n\nHowever, no matter how many times you click the plus button, the counter is still incremented by one every second. What‚Äôs wrong with this code? Why is increment always equal to 1 inside the Effect‚Äôs code? Find the mistake and fix it.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\n\nexport default function Timer() {\n const [count, setCount] = useState(0);\n const [increment, setIncrement] = useState(1);\n\n useEffect(() => {\n const id = setInterval(() => {\n setCount(c => c + increment);\n }, 1000);\n return () => {\n clearInterval(id);\n };\n // eslint-disable-next-line react-hooks/exhaustive-deps\n }, []);\n\n return (\n <>\n <h1>\n Counter: {count}\n <button onClick={() => setCount(0)}>Reset</button>\n </h1>\n <hr />\n <p>\n Every second, increment by:\n <button disabled={increment === 0} onClick={() => {\n setIncrement(i => i - 1);\n }}>‚Äì</button>\n <b>{increment}</b>\n <button onClick={() => {\n setIncrement(i => i + 1);\n }}>+</button>\n </p>\n </>\n );\n}\n\nShow more\nShow hint\nShow solution\nNext Challenge\nPREVIOUS\nLifecycle of Reactive Effects\nNEXT\nRemoving Effect Dependencies",
      "tables": [],
      "code_blocks": [
        "function ChatRoom({ roomId }) {\n\n  const [message, setMessage] = useState('');\n\n  // ...\n\n  function handleSendClick() {\n\n    sendMessage(message);\n\n  }\n\n  // ...\n\n  return (\n\n    <>\n\n      <input value={message} onChange={e => setMessage(e.target.value)} />\n\n      <button onClick={handleSendClick}>Send</button>\n\n    </>\n\n  );\n\n}",
        "function ChatRoom({ roomId }) {\n\n  const [message, setMessage] = useState('');\n\n  // ...\n\n  function handleSendClick() {\n\n    sendMessage(message);\n\n  }\n\n  // ...\n\n  return (\n\n    <>\n\n      <input value={message} onChange={e => setMessage(e.target.value)} />\n\n      <button onClick={handleSendClick}>Send</button>\n\n    </>\n\n  );\n\n}",
        "sendMessage(message)",
        "function ChatRoom({ roomId }) {\n\n  // ...\n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.connect();\n\n    return () => {\n\n      connection.disconnect();\n\n    };\n\n  }, [roomId]);\n\n  // ...\n\n}",
        "function ChatRoom({ roomId }) {\n\n  // ...\n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.connect();\n\n    return () => {\n\n      connection.disconnect();\n\n    };\n\n  }, [roomId]);\n\n  // ...\n\n}",
        "import { useState, useEffect } from 'react';\nimport { createConnection, sendMessage } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  const [message, setMessage] = useState('');\n\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId);\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId]);\n\n  function handleSendClick() {\n    sendMessage(message);\n  }\n\n  return (\n    <>\n      <h1>Welcome to the {roomId} room!</h1>\n      <input value={message} onChange={e => setMessage(e.target.value)} />\n      <button onClick={handleSendClick}>Send</button>\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  const [show, setShow] = useState(false);\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <button onClick={() => setShow(!show)}>\n        {show ? 'Close chat' : 'Open chat'}\n      </button>\n      {show && <hr />}\n      {show && <ChatRoom roomId={roomId} />}\n    </>\n  );\n}",
        "const serverUrl = 'https://localhost:1234';\n\n\n\nfunction ChatRoom({ roomId }) {\n\n  const [message, setMessage] = useState('');\n\n\n\n  // ...\n\n}",
        "const serverUrl = 'https://localhost:1234';\n\n\n\nfunction ChatRoom({ roomId }) {\n\n  const [message, setMessage] = useState('');\n\n\n\n  // ...\n\n}",
        "// ...\n\n    sendMessage(message);\n\n    // ...",
        "// ...\n\n    sendMessage(message);\n\n    // ...",
        "function handleSendClick() {\n\n    sendMessage(message);\n\n  }",
        "function handleSendClick() {\n\n    sendMessage(message);\n\n  }",
        "sendMessage(message)",
        "// ...\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.connect();\n\n    // ...",
        "// ...\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.connect();\n\n    // ...",
        "useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.connect();\n\n    return () => {\n\n      connection.disconnect()\n\n    };\n\n  }, [roomId]);",
        "useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.connect();\n\n    return () => {\n\n      connection.disconnect()\n\n    };\n\n  }, [roomId]);",
        "createConnection(serverUrl, roomId)",
        "connection.connect()",
        "function ChatRoom({ roomId, theme }) {\n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.on('connected', () => {\n\n      showNotification('Connected!', theme);\n\n    });\n\n    connection.connect();\n\n    // ...",
        "function ChatRoom({ roomId, theme }) {\n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.on('connected', () => {\n\n      showNotification('Connected!', theme);\n\n    });\n\n    connection.connect();\n\n    // ...",
        "function ChatRoom({ roomId, theme }) {\n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.on('connected', () => {\n\n      showNotification('Connected!', theme);\n\n    });\n\n    connection.connect();\n\n    return () => {\n\n      connection.disconnect()\n\n    };\n\n  }, [roomId, theme]); // ‚úÖ All dependencies declared\n\n  // ...",
        "function ChatRoom({ roomId, theme }) {\n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.on('connected', () => {\n\n      showNotification('Connected!', theme);\n\n    });\n\n    connection.connect();\n\n    return () => {\n\n      connection.disconnect()\n\n    };\n\n  }, [roomId, theme]); // ‚úÖ All dependencies declared\n\n  // ...",
        "import { useState, useEffect } from 'react';\nimport { createConnection, sendMessage } from './chat.js';\nimport { showNotification } from './notifications.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId, theme }) {\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId);\n    connection.on('connected', () => {\n      showNotification('Connected!', theme);\n    });\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId, theme]);\n\n  return <h1>Welcome to the {roomId} room!</h1>\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  const [isDark, setIsDark] = useState(false);\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={isDark}\n          onChange={e => setIsDark(e.target.checked)}\n        />\n        Use dark theme\n      </label>\n      <hr />\n      <ChatRoom\n        roomId={roomId}\n        theme={isDark ? 'dark' : 'light'}\n      />\n    </>\n  );\n}",
        "// ...\n\n      showNotification('Connected!', theme);\n\n      // ...",
        "// ...\n\n      showNotification('Connected!', theme);\n\n      // ...",
        "useEffectEvent",
        "import { useEffect, useEffectEvent } from 'react';\n\n\n\nfunction ChatRoom({ roomId, theme }) {\n\n  const onConnected = useEffectEvent(() => {\n\n    showNotification('Connected!', theme);\n\n  });\n\n  // ...",
        "import { useEffect, useEffectEvent } from 'react';\n\n\n\nfunction ChatRoom({ roomId, theme }) {\n\n  const onConnected = useEffectEvent(() => {\n\n    showNotification('Connected!', theme);\n\n  });\n\n  // ...",
        "onConnected",
        "onConnected",
        "function ChatRoom({ roomId, theme }) {\n\n  const onConnected = useEffectEvent(() => {\n\n    showNotification('Connected!', theme);\n\n  });\n\n\n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.on('connected', () => {\n\n      onConnected();\n\n    });\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, [roomId]); // ‚úÖ All dependencies declared\n\n  // ...",
        "function ChatRoom({ roomId, theme }) {\n\n  const onConnected = useEffectEvent(() => {\n\n    showNotification('Connected!', theme);\n\n  });\n\n\n\n  useEffect(() => {\n\n    const connection = createConnection(serverUrl, roomId);\n\n    connection.on('connected', () => {\n\n      onConnected();\n\n    });\n\n    connection.connect();\n\n    return () => connection.disconnect();\n\n  }, [roomId]); // ‚úÖ All dependencies declared\n\n  // ...",
        "onConnected",
        "import { useState, useEffect } from 'react';\nimport { useEffectEvent } from 'react';\nimport { createConnection, sendMessage } from './chat.js';\nimport { showNotification } from './notifications.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId, theme }) {\n  const onConnected = useEffectEvent(() => {\n    showNotification('Connected!', theme);\n  });\n\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId);\n    connection.on('connected', () => {\n      onConnected();\n    });\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId]);\n\n  return <h1>Welcome to the {roomId} room!</h1>\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  const [isDark, setIsDark] = useState(false);\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={isDark}\n          onChange={e => setIsDark(e.target.checked)}\n        />\n        Use dark theme\n      </label>\n      <hr />\n      <ChatRoom\n        roomId={roomId}\n        theme={isDark ? 'dark' : 'light'}\n      />\n    </>\n  );\n}",
        "function Page() {\n\n  useEffect(() => {\n\n    logVisit();\n\n  }, []);\n\n  // ...\n\n}",
        "function Page() {\n\n  useEffect(() => {\n\n    logVisit();\n\n  }, []);\n\n  // ...\n\n}",
        "function Page({ url }) {\n\n  useEffect(() => {\n\n    logVisit(url);\n\n  }, []); // üî¥ React Hook useEffect has a missing dependency: 'url'\n\n  // ...\n\n}",
        "function Page({ url }) {\n\n  useEffect(() => {\n\n    logVisit(url);\n\n  }, []); // üî¥ React Hook useEffect has a missing dependency: 'url'\n\n  // ...\n\n}",
        "function Page({ url }) {\n\n  useEffect(() => {\n\n    logVisit(url);\n\n  }, [url]); // ‚úÖ All dependencies declared\n\n  // ...\n\n}",
        "function Page({ url }) {\n\n  useEffect(() => {\n\n    logVisit(url);\n\n  }, [url]); // ‚úÖ All dependencies declared\n\n  // ...\n\n}",
        "function Page({ url }) {\n\n  const { items } = useContext(ShoppingCartContext);\n\n  const numberOfItems = items.length;\n\n\n\n  useEffect(() => {\n\n    logVisit(url, numberOfItems);\n\n  }, [url]); // üî¥ React Hook useEffect has a missing dependency: 'numberOfItems'\n\n  // ...\n\n}",
        "function Page({ url }) {\n\n  const { items } = useContext(ShoppingCartContext);\n\n  const numberOfItems = items.length;\n\n\n\n  useEffect(() => {\n\n    logVisit(url, numberOfItems);\n\n  }, [url]); // üî¥ React Hook useEffect has a missing dependency: 'numberOfItems'\n\n  // ...\n\n}",
        "numberOfItems",
        "numberOfItems",
        "numberOfItems",
        "function Page({ url }) {\n\n  const { items } = useContext(ShoppingCartContext);\n\n  const numberOfItems = items.length;\n\n\n\n  const onVisit = useEffectEvent(visitedUrl => {\n\n    logVisit(visitedUrl, numberOfItems);\n\n  });\n\n\n\n  useEffect(() => {\n\n    onVisit(url);\n\n  }, [url]); // ‚úÖ All dependencies declared\n\n  // ...\n\n}",
        "function Page({ url }) {\n\n  const { items } = useContext(ShoppingCartContext);\n\n  const numberOfItems = items.length;\n\n\n\n  const onVisit = useEffectEvent(visitedUrl => {\n\n    logVisit(visitedUrl, numberOfItems);\n\n  });\n\n\n\n  useEffect(() => {\n\n    onVisit(url);\n\n  }, [url]); // ‚úÖ All dependencies declared\n\n  // ...\n\n}",
        "numberOfItems",
        "numberOfItems",
        "numberOfItems",
        "const onVisit = useEffectEvent(() => {\n\n    logVisit(url, numberOfItems);\n\n  });\n\n\n\n  useEffect(() => {\n\n    onVisit();\n\n  }, [url]);",
        "const onVisit = useEffectEvent(() => {\n\n    logVisit(url, numberOfItems);\n\n  });\n\n\n\n  useEffect(() => {\n\n    onVisit();\n\n  }, [url]);",
        "const onVisit = useEffectEvent(visitedUrl => {\n\n    logVisit(visitedUrl, numberOfItems);\n\n  });\n\n\n\n  useEffect(() => {\n\n    onVisit(url);\n\n  }, [url]);",
        "const onVisit = useEffectEvent(visitedUrl => {\n\n    logVisit(visitedUrl, numberOfItems);\n\n  });\n\n\n\n  useEffect(() => {\n\n    onVisit(url);\n\n  }, [url]);",
        "const onVisit = useEffectEvent(visitedUrl => {\n\n    logVisit(visitedUrl, numberOfItems);\n\n  });\n\n\n\n  useEffect(() => {\n\n    setTimeout(() => {\n\n      onVisit(url);\n\n    }, 5000); // Delay logging visits\n\n  }, [url]);",
        "const onVisit = useEffectEvent(visitedUrl => {\n\n    logVisit(visitedUrl, numberOfItems);\n\n  });\n\n\n\n  useEffect(() => {\n\n    setTimeout(() => {\n\n      onVisit(url);\n\n    }, 5000); // Delay logging visits\n\n  }, [url]);",
        "function Timer() {\n\n  const [count, setCount] = useState(0);\n\n\n\n  const onTick = useEffectEvent(() => {\n\n    setCount(count + 1);\n\n  });\n\n\n\n  useTimer(onTick, 1000); // üî¥ Avoid: Passing Effect Events\n\n\n\n  return <h1>{count}</h1>\n\n}\n\n\n\nfunction useTimer(callback, delay) {\n\n  useEffect(() => {\n\n    const id = setInterval(() => {\n\n      callback();\n\n    }, delay);\n\n    return () => {\n\n      clearInterval(id);\n\n    };\n\n  }, [delay, callback]); // Need to specify \"callback\" in dependencies\n\n}",
        "function Timer() {\n\n  const [count, setCount] = useState(0);\n\n\n\n  const onTick = useEffectEvent(() => {\n\n    setCount(count + 1);\n\n  });\n\n\n\n  useTimer(onTick, 1000); // üî¥ Avoid: Passing Effect Events\n\n\n\n  return <h1>{count}</h1>\n\n}\n\n\n\nfunction useTimer(callback, delay) {\n\n  useEffect(() => {\n\n    const id = setInterval(() => {\n\n      callback();\n\n    }, delay);\n\n    return () => {\n\n      clearInterval(id);\n\n    };\n\n  }, [delay, callback]); // Need to specify \"callback\" in dependencies\n\n}",
        "function Timer() {\n\n  const [count, setCount] = useState(0);\n\n  useTimer(() => {\n\n    setCount(count + 1);\n\n  }, 1000);\n\n  return <h1>{count}</h1>\n\n}\n\n\n\nfunction useTimer(callback, delay) {\n\n  const onTick = useEffectEvent(() => {\n\n    callback();\n\n  });\n\n\n\n  useEffect(() => {\n\n    const id = setInterval(() => {\n\n      onTick(); // ‚úÖ Good: Only called locally inside an Effect\n\n    }, delay);\n\n    return () => {\n\n      clearInterval(id);\n\n    };\n\n  }, [delay]); // No need to specify \"onTick\" (an Effect Event) as a dependency\n\n}",
        "function Timer() {\n\n  const [count, setCount] = useState(0);\n\n  useTimer(() => {\n\n    setCount(count + 1);\n\n  }, 1000);\n\n  return <h1>{count}</h1>\n\n}\n\n\n\nfunction useTimer(callback, delay) {\n\n  const onTick = useEffectEvent(() => {\n\n    callback();\n\n  });\n\n\n\n  useEffect(() => {\n\n    const id = setInterval(() => {\n\n      onTick(); // ‚úÖ Good: Only called locally inside an Effect\n\n    }, delay);\n\n    return () => {\n\n      clearInterval(id);\n\n    };\n\n  }, [delay]); // No need to specify \"onTick\" (an Effect Event) as a dependency\n\n}",
        "import { useState, useEffect } from 'react';\n\nexport default function Timer() {\n  const [count, setCount] = useState(0);\n  const [increment, setIncrement] = useState(1);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(c => c + increment);\n    }, 1000);\n    return () => {\n      clearInterval(id);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return (\n    <>\n      <h1>\n        Counter: {count}\n        <button onClick={() => setCount(0)}>Reset</button>\n      </h1>\n      <hr />\n      <p>\n        Every second, increment by:\n        <button disabled={increment === 0} onClick={() => {\n          setIncrement(i => i - 1);\n        }}>‚Äì</button>\n        <b>{increment}</b>\n        <button onClick={() => {\n          setIncrement(i => i + 1);\n        }}>+</button>\n      </p>\n    </>\n  );\n}"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 3137
    },
    {
      "url": "https://react.dev/learn/state-as-a-snapshot",
      "title": "State as a Snapshot",
      "breadcrumb": [],
      "section_path": [
        "Adding Interactivity",
        "State as a Snapshot"
      ],
      "headings": {
        "h1": [
          "State as a Snapshot"
        ],
        "h2": [
          "Setting state triggers renders",
          "Rendering takes a snapshot in time",
          "State over time",
          "Recap",
          "Try out some challenges"
        ],
        "h3": [
          "You will learn"
        ],
        "h4": [
          "Challenge 1 of 1: Implement a traffic light"
        ]
      },
      "text_content": "LEARN REACT\nADDING INTERACTIVITY\nState as a Snapshot\n\nState variables might look like regular JavaScript variables that you can read and write to. However, state behaves more like a snapshot. Setting it does not change the state variable you already have, but instead triggers a re-render.\n\nYou will learn\nHow setting state triggers re-renders\nWhen and how state updates\nWhy state does not update immediately after you set it\nHow event handlers access a ‚Äúsnapshot‚Äù of the state\nSetting state triggers renders \n\nYou might think of your user interface as changing directly in response to the user event like a click. In React, it works a little differently from this mental model. On the previous page, you saw that setting state requests a re-render from React. This means that for an interface to react to the event, you need to update the state.\n\nIn this example, when you press ‚Äúsend‚Äù, setIsSent(true) tells React to re-render the UI:\n\nApp.js\nDownload\nReload\nClear\nFork\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nimport { useState } from 'react';\n\nexport default function Form() {\n const [isSent, setIsSent] = useState(false);\n const [message, setMessage] = useState('Hi!');\n if (isSent) {\n return <h1>Your message is on its way!</h1>\n }\n return (\n <form onSubmit={(e) => {\n e.preventDefault();\n setIsSent(true);\n sendMessage(message);\n }}>\n <textarea\n placeholder=\"Message\"\n value={message}\n onChange={e => setMessage(e.target.value)}\n />\n <button type=\"submit\">Send</button>\n </form>\n );\n}\n\nfunction sendMessage(message) {\n // ...\n}\n\nShow more\n\nHere‚Äôs what happens when you click the button:\n\nThe onSubmit event handler executes.\nsetIsSent(true) sets isSent to true and queues a new render.\nReact re-renders the component according to the new isSent value.\n\nLet‚Äôs take a closer look at the relationship between state and rendering.\n\nRendering takes a snapshot in time \n\n‚ÄúRendering‚Äù means that React is calling your component, which is a function. The JSX you return from that function is like a snapshot of the UI in time. Its props, event handlers, and local variables were all calculated using its state at the time of the render.\n\nUnlike a photograph or a movie frame, the UI ‚Äúsnapshot‚Äù you return is interactive. It includes logic like event handlers that specify what happens in response to inputs. React updates the screen to match this snapshot and connects the event handlers. As a result, pressing a button will trigger the click handler from your JSX.\n\nWhen React re-renders a component:\n\nReact calls your function again.\nYour function returns a new JSX snapshot.\nReact then updates the screen to match the snapshot your function returned.\nReact executing the function\nCalculating the snapshot\nUpdating the DOM tree\n\nIllustrated by Rachel Lee Nabors\n\nAs a component‚Äôs memory, state is not like a regular variable that disappears after your function returns. State actually ‚Äúlives‚Äù in React itself‚Äîas if on a shelf!‚Äîoutside of your function. When React calls your component, it gives you a snapshot of the state for that particular render. Your component returns a snapshot of the UI with a fresh set of props and event handlers in its JSX, all calculated using the state values from that render!\n\nYou tell React to update the state\nReact updates the state value\nReact passes a snapshot of the state value into the component\n\nIllustrated by Rachel Lee Nabors\n\nHere‚Äôs a little experiment to show you how this works. In this example, you might expect that clicking the ‚Äú+3‚Äù button would increment the counter three times because it calls setNumber(number + 1) three times.\n\nSee what happens when you click the ‚Äú+3‚Äù button:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function Counter() {\n const [number, setNumber] = useState(0);\n\n return (\n <>\n <h1>{number}</h1>\n <button onClick={() => {\n setNumber(number + 1);\n setNumber(number + 1);\n setNumber(number + 1);\n }}>+3</button>\n </>\n )\n}\n\nShow more\n\nNotice that number only increments once per click!\n\nSetting state only changes it for the next render. During the first render, number was 0. This is why, in that render‚Äôs onClick handler, the value of number is still 0 even after setNumber(number + 1) was called:\n\n<button onClick={() => {\n\n setNumber(number + 1);\n\n setNumber(number + 1);\n\n setNumber(number + 1);\n\n}}>+3</button>\n\nHere is what this button‚Äôs click handler tells React to do:\n\nsetNumber(number + 1): number is 0 so setNumber(0 + 1).\nReact prepares to change number to 1 on the next render.\nsetNumber(number + 1): number is 0 so setNumber(0 + 1).\nReact prepares to change number to 1 on the next render.\nsetNumber(number + 1): number is 0 so setNumber(0 + 1).\nReact prepares to change number to 1 on the next render.\n\nEven though you called setNumber(number + 1) three times, in this render‚Äôs event handler number is always 0, so you set the state to 1 three times. This is why, after your event handler finishes, React re-renders the component with number equal to 1 rather than 3.\n\nYou can also visualize this by mentally substituting state variables with their values in your code. Since the number state variable is 0 for this render, its event handler looks like this:\n\n<button onClick={() => {\n\n setNumber(0 + 1);\n\n setNumber(0 + 1);\n\n setNumber(0 + 1);\n\n}}>+3</button>\n\nFor the next render, number is 1, so that render‚Äôs click handler looks like this:\n\n<button onClick={() => {\n\n setNumber(1 + 1);\n\n setNumber(1 + 1);\n\n setNumber(1 + 1);\n\n}}>+3</button>\n\nThis is why clicking the button again will set the counter to 2, then to 3 on the next click, and so on.\n\nState over time \n\nWell, that was fun. Try to guess what clicking this button will alert:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function Counter() {\n const [number, setNumber] = useState(0);\n\n return (\n <>\n <h1>{number}</h1>\n <button onClick={() => {\n setNumber(number + 5);\n alert(number);\n }}>+5</button>\n </>\n )\n}\n\nIf you use the substitution method from before, you can guess that the alert shows ‚Äú0‚Äù:\n\nsetNumber(0 + 5);\n\nalert(0);\n\nBut what if you put a timer on the alert, so it only fires after the component re-rendered? Would it say ‚Äú0‚Äù or ‚Äú5‚Äù? Have a guess!\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function Counter() {\n const [number, setNumber] = useState(0);\n\n return (\n <>\n <h1>{number}</h1>\n <button onClick={() => {\n setNumber(number + 5);\n setTimeout(() => {\n alert(number);\n }, 3000);\n }}>+5</button>\n </>\n )\n}\n\nShow more\n\nSurprised? If you use the substitution method, you can see the ‚Äúsnapshot‚Äù of the state passed to the alert.\n\nsetNumber(0 + 5);\n\nsetTimeout(() => {\n\n alert(0);\n\n}, 3000);\n\nThe state stored in React may have changed by the time the alert runs, but it was scheduled using a snapshot of the state at the time the user interacted with it!\n\nA state variable‚Äôs value never changes within a render, even if its event handler‚Äôs code is asynchronous. Inside that render‚Äôs onClick, the value of number continues to be 0 even after setNumber(number + 5) was called. Its value was ‚Äúfixed‚Äù when React ‚Äútook the snapshot‚Äù of the UI by calling your component.\n\nHere is an example of how that makes your event handlers less prone to timing mistakes. Below is a form that sends a message with a five-second delay. Imagine this scenario:\n\nYou press the ‚ÄúSend‚Äù button, sending ‚ÄúHello‚Äù to Alice.\nBefore the five-second delay ends, you change the value of the ‚ÄúTo‚Äù field to ‚ÄúBob‚Äù.\n\nWhat do you expect the alert to display? Would it display, ‚ÄúYou said Hello to Alice‚Äù? Or would it display, ‚ÄúYou said Hello to Bob‚Äù? Make a guess based on what you know, and then try it:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function Form() {\n const [to, setTo] = useState('Alice');\n const [message, setMessage] = useState('Hello');\n\n function handleSubmit(e) {\n e.preventDefault();\n setTimeout(() => {\n alert(`You said ${message} to ${to}`);\n }, 5000);\n }\n\n return (\n <form onSubmit={handleSubmit}>\n <label>\n To:{' '}\n <select\n value={to}\n onChange={e => setTo(e.target.value)}>\n <option value=\"Alice\">Alice</option>\n <option value=\"Bob\">Bob</option>\n </select>\n </label>\n <textarea\n placeholder=\"Message\"\n value={message}\n onChange={e => setMessage(e.target.value)}\n />\n <button type=\"submit\">Send</button>\n </form>\n );\n}\n\nShow more\n\nReact keeps the state values ‚Äúfixed‚Äù within one render‚Äôs event handlers. You don‚Äôt need to worry whether the state has changed while the code is running.\n\nBut what if you wanted to read the latest state before a re-render? You‚Äôll want to use a state updater function, covered on the next page!\n\nRecap\nSetting state requests a new render.\nReact stores state outside of your component, as if on a shelf.\nWhen you call useState, React gives you a snapshot of the state for that render.\nVariables and event handlers don‚Äôt ‚Äúsurvive‚Äù re-renders. Every render has its own event handlers.\nEvery render (and functions inside it) will always ‚Äúsee‚Äù the snapshot of the state that React gave to that render.\nYou can mentally substitute state in event handlers, similarly to how you think about the rendered JSX.\nEvent handlers created in the past have the state values from the render in which they were created.\nTry out some challenges\nChallenge 1 of 1: Implement a traffic light \n\nHere is a crosswalk light component that toggles when the button is pressed:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function TrafficLight() {\n const [walk, setWalk] = useState(true);\n\n function handleClick() {\n setWalk(!walk);\n }\n\n return (\n <>\n <button onClick={handleClick}>\n Change to {walk ? 'Stop' : 'Walk'}\n </button>\n <h1 style={{\n color: walk ? 'darkgreen' : 'darkred'\n }}>\n {walk ? 'Walk' : 'Stop'}\n </h1>\n </>\n );\n}\n\nShow more\n\nAdd an alert to the click handler. When the light is green and says ‚ÄúWalk‚Äù, clicking the button should say ‚ÄúStop is next‚Äù. When the light is red and says ‚ÄúStop‚Äù, clicking the button should say ‚ÄúWalk is next‚Äù.\n\nDoes it make a difference whether you put the alert before or after the setWalk call?\n\nShow solution\nPREVIOUS\nRender and Commit\nNEXT\nQueueing a Series of State Updates",
      "tables": [],
      "code_blocks": [
        "setIsSent(true)",
        "setIsSent(true)",
        "setNumber(number + 1)",
        "import { useState } from 'react';\n\nexport default function Counter() {\n  const [number, setNumber] = useState(0);\n\n  return (\n    <>\n      <h1>{number}</h1>\n      <button onClick={() => {\n        setNumber(number + 1);\n        setNumber(number + 1);\n        setNumber(number + 1);\n      }}>+3</button>\n    </>\n  )\n}",
        "setNumber(number + 1)",
        "<button onClick={() => {\n\n  setNumber(number + 1);\n\n  setNumber(number + 1);\n\n  setNumber(number + 1);\n\n}}>+3</button>",
        "<button onClick={() => {\n\n  setNumber(number + 1);\n\n  setNumber(number + 1);\n\n  setNumber(number + 1);\n\n}}>+3</button>",
        "setNumber(number + 1)",
        "setNumber(0 + 1)",
        "setNumber(number + 1)",
        "setNumber(0 + 1)",
        "setNumber(number + 1)",
        "setNumber(0 + 1)",
        "setNumber(number + 1)",
        "<button onClick={() => {\n\n  setNumber(0 + 1);\n\n  setNumber(0 + 1);\n\n  setNumber(0 + 1);\n\n}}>+3</button>",
        "<button onClick={() => {\n\n  setNumber(0 + 1);\n\n  setNumber(0 + 1);\n\n  setNumber(0 + 1);\n\n}}>+3</button>",
        "<button onClick={() => {\n\n  setNumber(1 + 1);\n\n  setNumber(1 + 1);\n\n  setNumber(1 + 1);\n\n}}>+3</button>",
        "<button onClick={() => {\n\n  setNumber(1 + 1);\n\n  setNumber(1 + 1);\n\n  setNumber(1 + 1);\n\n}}>+3</button>",
        "import { useState } from 'react';\n\nexport default function Counter() {\n  const [number, setNumber] = useState(0);\n\n  return (\n    <>\n      <h1>{number}</h1>\n      <button onClick={() => {\n        setNumber(number + 5);\n        alert(number);\n      }}>+5</button>\n    </>\n  )\n}",
        "setNumber(0 + 5);\n\nalert(0);",
        "setNumber(0 + 5);\n\nalert(0);",
        "import { useState } from 'react';\n\nexport default function Counter() {\n  const [number, setNumber] = useState(0);\n\n  return (\n    <>\n      <h1>{number}</h1>\n      <button onClick={() => {\n        setNumber(number + 5);\n        setTimeout(() => {\n          alert(number);\n        }, 3000);\n      }}>+5</button>\n    </>\n  )\n}",
        "setNumber(0 + 5);\n\nsetTimeout(() => {\n\n  alert(0);\n\n}, 3000);",
        "setNumber(0 + 5);\n\nsetTimeout(() => {\n\n  alert(0);\n\n}, 3000);",
        "setNumber(number + 5)",
        "import { useState } from 'react';\n\nexport default function Form() {\n  const [to, setTo] = useState('Alice');\n  const [message, setMessage] = useState('Hello');\n\n  function handleSubmit(e) {\n    e.preventDefault();\n    setTimeout(() => {\n      alert(`You said ${message} to ${to}`);\n    }, 5000);\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        To:{' '}\n        <select\n          value={to}\n          onChange={e => setTo(e.target.value)}>\n          <option value=\"Alice\">Alice</option>\n          <option value=\"Bob\">Bob</option>\n        </select>\n      </label>\n      <textarea\n        placeholder=\"Message\"\n        value={message}\n        onChange={e => setMessage(e.target.value)}\n      />\n      <button type=\"submit\">Send</button>\n    </form>\n  );\n}",
        "import { useState } from 'react';\n\nexport default function TrafficLight() {\n  const [walk, setWalk] = useState(true);\n\n  function handleClick() {\n    setWalk(!walk);\n  }\n\n  return (\n    <>\n      <button onClick={handleClick}>\n        Change to {walk ? 'Stop' : 'Walk'}\n      </button>\n      <h1 style={{\n        color: walk ? 'darkgreen' : 'darkred'\n      }}>\n        {walk ? 'Walk' : 'Stop'}\n      </h1>\n    </>\n  );\n}"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 1649
    },
    {
      "url": "https://react.dev/learn/build-a-react-app-from-scratch",
      "title": "Build a React app from Scratch",
      "breadcrumb": [],
      "section_path": [
        "Installation",
        "Build a React App from Scratch"
      ],
      "headings": {
        "h1": [
          "Build a React app from Scratch"
        ],
        "h2": [
          "Step 1: Install a build tool",
          "Step 2: Build Common Application Patterns"
        ],
        "h3": [
          "Vite",
          "Parcel",
          "Rsbuild",
          "Note",
          "Routing",
          "Data Fetching",
          "Code-splitting",
          "Improving Application Performance",
          "And more‚Ä¶"
        ],
        "h4": [
          "Consider using a framework",
          "Metro for React Native"
        ],
        "h5": [
          "DEEP DIVE"
        ]
      },
      "text_content": "LEARN REACT\nINSTALLATION\nBuild a React app from Scratch\n\nIf your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, you can build a React app from scratch.\n\nDEEP DIVE\nConsider using a framework \nShow Details\nStep 1: Install a build tool \n\nThe first step is to install a build tool like vite, parcel, or rsbuild. These build tools provide features to package and run source code, provide a development server for local development and a build command to deploy your app to a production server.\n\nVite \n\nVite is a build tool that aims to provide a faster and leaner development experience for modern web projects.\n\n Terminal\n Copy\nnpm create vite@latest my-app -- --template react-ts\n\nVite is opinionated and comes with sensible defaults out of the box. Vite has a rich ecosystem of plugins to support fast refresh, JSX, Babel/SWC, and other common features. See Vite‚Äôs React plugin or React SWC plugin and React SSR example project to get started.\n\nVite is already being used as a build tool in one of our recommended frameworks: React Router.\n\nParcel \n\nParcel combines a great out-of-the-box development experience with a scalable architecture that can take your project from just getting started to massive production applications.\n\n Terminal\n Copy\nnpm install --save-dev parcel\n\nParcel supports fast refresh, JSX, TypeScript, Flow, and styling out of the box. See Parcel‚Äôs React recipe to get started.\n\nRsbuild \n\nRsbuild is an Rspack-powered build tool that provides a seamless development experience for React applications. It comes with carefully tuned defaults and performance optimizations ready to use.\n\n Terminal\n Copy\nnpx create-rsbuild --template react\n\nRsbuild includes built-in support for React features like fast refresh, JSX, TypeScript, and styling. See Rsbuild‚Äôs React guide to get started.\n\nNote\nMetro for React Native \n\nIf you‚Äôre starting from scratch with React Native you‚Äôll need to use Metro, the JavaScript bundler for React Native. Metro supports bundling for platforms like iOS and Android, but lacks many features when compared to the tools here. We recommend starting with Vite, Parcel, or Rsbuild unless your project requires React Native support.\n\nStep 2: Build Common Application Patterns \n\nThe build tools listed above start off with a client-only, single-page app (SPA), but don‚Äôt include any further solutions for common functionality like routing, data fetching, or styling.\n\nThe React ecosystem includes many tools for these problems. We‚Äôve listed a few that are widely used as a starting point, but feel free to choose other tools if those work better for you.\n\nRouting \n\nRouting determines what content or pages to display when a user visits a particular URL. You need to set up a router to map URLs to different parts of your app. You‚Äôll also need to handle nested routes, route parameters, and query parameters. Routers can be configured within your code, or defined based on your component folder and file structures.\n\nRouters are a core part of modern applications, and are usually integrated with data fetching (including prefetching data for a whole page for faster loading), code splitting (to minimize client bundle sizes), and page rendering approaches (to decide how each page gets generated).\n\nWe suggest using:\n\nReact Router\nTanstack Router\nData Fetching \n\nFetching data from a server or other data source is a key part of most applications. Doing this properly requires handling loading states, error states, and caching the fetched data, which can be complex.\n\nPurpose-built data fetching libraries do the hard work of fetching and caching the data for you, letting you focus on what data your app needs and how to display it. These libraries are typically used directly in your components, but can also be integrated into routing loaders for faster pre-fetching and better performance, and in server rendering as well.\n\nNote that fetching data directly in components can lead to slower loading times due to network request waterfalls, so we recommend prefetching data in router loaders or on the server as much as possible! This allows a page‚Äôs data to be fetched all at once as the page is being displayed.\n\nIf you‚Äôre fetching data from most backends or REST-style APIs, we suggest using:\n\nTanStack Query\nSWR\nRTK Query\n\nIf you‚Äôre fetching data from a GraphQL API, we suggest using:\n\nApollo\nRelay\nCode-splitting \n\nCode-splitting is the process of breaking your app into smaller bundles that can be loaded on demand. An app‚Äôs code size increases with every new feature and additional dependency. Apps can become slow to load because all of the code for the entire app needs to be sent before it can be used. Caching, reducing features/dependencies, and moving some code to run on the server can help mitigate slow loading but are incomplete solutions that can sacrifice functionality if overused.\n\nSimilarly, if you rely on the apps using your framework to split the code, you might encounter situations where loading becomes slower than if no code splitting were happening at all. For example, lazily loading a chart delays sending the code needed to render the chart, splitting the chart code from the rest of the app. Parcel supports code splitting with React.lazy. However, if the chart loads its data after it has been initially rendered you are now waiting twice. This is a waterfall: rather than fetching the data for the chart and sending the code to render it simultaneously, you must wait for each step to complete one after the other.\n\nSplitting code by route, when integrated with bundling and data fetching, can reduce the initial load time of your app and the time it takes for the largest visible content of the app to render (Largest Contentful Paint).\n\nFor code-splitting instructions, see your build tool docs:\n\nVite build optimizations\nParcel code splitting\nRsbuild code splitting\nImproving Application Performance \n\nSince the build tool you select only supports single page apps (SPAs), you‚Äôll need to implement other rendering patterns like server-side rendering (SSR), static site generation (SSG), and/or React Server Components (RSC). Even if you don‚Äôt need these features at first, in the future there may be some routes that would benefit SSR, SSG or RSC.\n\nSingle-page apps (SPA) load a single HTML page and dynamically updates the page as the user interacts with the app. SPAs are easier to get started with, but they can have slower initial load times. SPAs are the default architecture for most build tools.\n\nStreaming Server-side rendering (SSR) renders a page on the server and sends the fully rendered page to the client. SSR can improve performance, but it can be more complex to set up and maintain than a single-page app. With the addition of streaming, SSR can be very complex to set up and maintain. See Vite‚Äôs SSR guide.\n\nStatic site generation (SSG) generates static HTML files for your app at build time. SSG can improve performance, but it can be more complex to set up and maintain than server-side rendering. See Vite‚Äôs SSG guide.\n\nReact Server Components (RSC) lets you mix build-time, server-only, and interactive components in a single React tree. RSC can improve performance, but it currently requires deep expertise to set up and maintain. See Parcel‚Äôs RSC examples.\n\nYour rendering strategies need to integrate with your router so apps built with your framework can choose the rendering strategy on a per-route level. This will enable different rendering strategies without having to rewrite your whole app. For example, the landing page for your app might benefit from being statically generated (SSG), while a page with a content feed might perform best with server-side rendering.\n\nUsing the right rendering strategy for the right routes can decrease the time it takes for the first byte of content to be loaded (Time to First Byte), the first piece of content to render (First Contentful Paint), and the largest visible content of the app to render (Largest Contentful Paint).\n\nAnd more‚Ä¶ \n\nThese are just a few examples of the features a new app will need to consider when building from scratch. Many limitations you‚Äôll hit can be difficult to solve as each problem is interconnected with the others and can require deep expertise in problem areas you may not be familiar with.\n\nIf you don‚Äôt want to solve these problems on your own, you can get started with a framework that provides these features out of the box.\n\nPREVIOUS\nCreating a React App\nNEXT\nAdd React to an Existing Project",
      "tables": [],
      "code_blocks": [
        "npm create vite@latest my-app -- --template react-ts",
        "npm create vite@latest my-app -- --template react-ts",
        "npm install --save-dev parcel",
        "npm install --save-dev parcel",
        "npx create-rsbuild --template react",
        "npx create-rsbuild --template react"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 1402
    },
    {
      "url": "https://react.dev/learn/you-might-not-need-an-effect",
      "title": "You Might Not Need an Effect",
      "breadcrumb": [],
      "section_path": [
        "Escape Hatches",
        "You Might Not Need an Effect"
      ],
      "headings": {
        "h1": [
          "You Might Not Need an Effect"
        ],
        "h2": [
          "How to remove unnecessary Effects",
          "Recap",
          "Try out some challenges"
        ],
        "h3": [
          "You will learn",
          "Updating state based on props or state",
          "Caching expensive calculations",
          "Note",
          "Resetting all state when a prop changes",
          "Adjusting some state when a prop changes",
          "Sharing logic between event handlers",
          "Sending a POST request",
          "Chains of computations",
          "Initializing the application",
          "Notifying parent components about state changes",
          "Passing data to the parent",
          "Subscribing to an external store",
          "Fetching data"
        ],
        "h4": [
          "How to tell if a calculation is expensive?",
          "Challenge 1 of 4: Transform data without Effects"
        ],
        "h5": [
          "DEEP DIVE"
        ]
      },
      "text_content": "LEARN REACT\nESCAPE HATCHES\nYou Might Not Need an Effect\n\nEffects are an escape hatch from the React paradigm. They let you ‚Äústep outside‚Äù of React and synchronize your components with some external system like a non-React widget, network, or the browser DOM. If there is no external system involved (for example, if you want to update a component‚Äôs state when some props or state change), you shouldn‚Äôt need an Effect. Removing unnecessary Effects will make your code easier to follow, faster to run, and less error-prone.\n\nYou will learn\nWhy and how to remove unnecessary Effects from your components\nHow to cache expensive computations without Effects\nHow to reset and adjust component state without Effects\nHow to share logic between event handlers\nWhich logic should be moved to event handlers\nHow to notify parent components about changes\nHow to remove unnecessary Effects \n\nThere are two common cases in which you don‚Äôt need Effects:\n\nYou don‚Äôt need Effects to transform data for rendering. For example, let‚Äôs say you want to filter a list before displaying it. You might feel tempted to write an Effect that updates a state variable when the list changes. However, this is inefficient. When you update the state, React will first call your component functions to calculate what should be on the screen. Then React will ‚Äúcommit‚Äù these changes to the DOM, updating the screen. Then React will run your Effects. If your Effect also immediately updates the state, this restarts the whole process from scratch! To avoid the unnecessary render passes, transform all the data at the top level of your components. That code will automatically re-run whenever your props or state change.\nYou don‚Äôt need Effects to handle user events. For example, let‚Äôs say you want to send an /api/buy POST request and show a notification when the user buys a product. In the Buy button click event handler, you know exactly what happened. By the time an Effect runs, you don‚Äôt know what the user did (for example, which button was clicked). This is why you‚Äôll usually handle user events in the corresponding event handlers.\n\nYou do need Effects to synchronize with external systems. For example, you can write an Effect that keeps a jQuery widget synchronized with the React state. You can also fetch data with Effects: for example, you can synchronize the search results with the current search query. Keep in mind that modern frameworks provide more efficient built-in data fetching mechanisms than writing Effects directly in your components.\n\nTo help you gain the right intuition, let‚Äôs look at some common concrete examples!\n\nUpdating state based on props or state \n\nSuppose you have a component with two state variables: firstName and lastName. You want to calculate a fullName from them by concatenating them. Moreover, you‚Äôd like fullName to update whenever firstName or lastName change. Your first instinct might be to add a fullName state variable and update it in an Effect:\n\nfunction Form() {\n\n const [firstName, setFirstName] = useState('Taylor');\n\n const [lastName, setLastName] = useState('Swift');\n\n // üî¥ Avoid: redundant state and unnecessary Effect\n\n const [fullName, setFullName] = useState('');\n\n useEffect(() => {\n\n setFullName(firstName + ' ' + lastName);\n\n }, [firstName, lastName]);\n\n // ...\n\n}\n\nThis is more complicated than necessary. It is inefficient too: it does an entire render pass with a stale value for fullName, then immediately re-renders with the updated value. Remove the state variable and the Effect:\n\nfunction Form() {\n\n const [firstName, setFirstName] = useState('Taylor');\n\n const [lastName, setLastName] = useState('Swift');\n\n // ‚úÖ Good: calculated during rendering\n\n const fullName = firstName + ' ' + lastName;\n\n // ...\n\n}\n\nWhen something can be calculated from the existing props or state, don‚Äôt put it in state. Instead, calculate it during rendering. This makes your code faster (you avoid the extra ‚Äúcascading‚Äù updates), simpler (you remove some code), and less error-prone (you avoid bugs caused by different state variables getting out of sync with each other). If this approach feels new to you, Thinking in React explains what should go into state.\n\nCaching expensive calculations \n\nThis component computes visibleTodos by taking the todos it receives by props and filtering them according to the filter prop. You might feel tempted to store the result in state and update it from an Effect:\n\nfunction TodoList({ todos, filter }) {\n\n const [newTodo, setNewTodo] = useState('');\n\n // üî¥ Avoid: redundant state and unnecessary Effect\n\n const [visibleTodos, setVisibleTodos] = useState([]);\n\n useEffect(() => {\n\n setVisibleTodos(getFilteredTodos(todos, filter));\n\n }, [todos, filter]);\n\n // ...\n\n}\n\nLike in the earlier example, this is both unnecessary and inefficient. First, remove the state and the Effect:\n\nfunction TodoList({ todos, filter }) {\n\n const [newTodo, setNewTodo] = useState('');\n\n // ‚úÖ This is fine if getFilteredTodos() is not slow.\n\n const visibleTodos = getFilteredTodos(todos, filter);\n\n // ...\n\n}\n\nUsually, this code is fine! But maybe getFilteredTodos() is slow or you have a lot of todos. In that case you don‚Äôt want to recalculate getFilteredTodos() if some unrelated state variable like newTodo has changed.\n\nYou can cache (or ‚Äúmemoize‚Äù) an expensive calculation by wrapping it in a useMemo Hook:\n\nNote\n\nReact Compiler can automatically memoize expensive calculations for you, eliminating the need for manual useMemo in many cases.\n\nimport { useMemo, useState } from 'react';\n\nfunction TodoList({ todos, filter }) {\n\n const [newTodo, setNewTodo] = useState('');\n\n const visibleTodos = useMemo(() => {\n\n // ‚úÖ Does not re-run unless todos or filter change\n\n return getFilteredTodos(todos, filter);\n\n }, [todos, filter]);\n\n // ...\n\n}\n\nOr, written as a single line:\n\nimport { useMemo, useState } from 'react';\n\nfunction TodoList({ todos, filter }) {\n\n const [newTodo, setNewTodo] = useState('');\n\n // ‚úÖ Does not re-run getFilteredTodos() unless todos or filter change\n\n const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);\n\n // ...\n\n}\n\nThis tells React that you don‚Äôt want the inner function to re-run unless either todos or filter have changed. React will remember the return value of getFilteredTodos() during the initial render. During the next renders, it will check if todos or filter are different. If they‚Äôre the same as last time, useMemo will return the last result it has stored. But if they are different, React will call the inner function again (and store its result).\n\nThe function you wrap in useMemo runs during rendering, so this only works for pure calculations.\n\nDEEP DIVE\nHow to tell if a calculation is expensive? \nShow Details\nResetting all state when a prop changes \n\nThis ProfilePage component receives a userId prop. The page contains a comment input, and you use a comment state variable to hold its value. One day, you notice a problem: when you navigate from one profile to another, the comment state does not get reset. As a result, it‚Äôs easy to accidentally post a comment on a wrong user‚Äôs profile. To fix the issue, you want to clear out the comment state variable whenever the userId changes:\n\nexport default function ProfilePage({ userId }) {\n\n const [comment, setComment] = useState('');\n\n // üî¥ Avoid: Resetting state on prop change in an Effect\n\n useEffect(() => {\n\n setComment('');\n\n }, [userId]);\n\n // ...\n\n}\n\nThis is inefficient because ProfilePage and its children will first render with the stale value, and then render again. It is also complicated because you‚Äôd need to do this in every component that has some state inside ProfilePage. For example, if the comment UI is nested, you‚Äôd want to clear out nested comment state too.\n\nInstead, you can tell React that each user‚Äôs profile is conceptually a different profile by giving it an explicit key. Split your component in two and pass a key attribute from the outer component to the inner one:\n\nexport default function ProfilePage({ userId }) {\n\n return (\n\n <Profile\n\n userId={userId}\n\n key={userId}\n\n />\n\n );\n\n}\n\nfunction Profile({ userId }) {\n\n // ‚úÖ This and any other state below will reset on key change automatically\n\n const [comment, setComment] = useState('');\n\n // ...\n\n}\n\nNormally, React preserves the state when the same component is rendered in the same spot. By passing userId as a key to the Profile component, you‚Äôre asking React to treat two Profile components with different userId as two different components that should not share any state. Whenever the key (which you‚Äôve set to userId) changes, React will recreate the DOM and reset the state of the Profile component and all of its children. Now the comment field will clear out automatically when navigating between profiles.\n\nNote that in this example, only the outer ProfilePage component is exported and visible to other files in the project. Components rendering ProfilePage don‚Äôt need to pass the key to it: they pass userId as a regular prop. The fact ProfilePage passes it as a key to the inner Profile component is an implementation detail.\n\nAdjusting some state when a prop changes \n\nSometimes, you might want to reset or adjust a part of the state on a prop change, but not all of it.\n\nThis List component receives a list of items as a prop, and maintains the selected item in the selection state variable. You want to reset the selection to null whenever the items prop receives a different array:\n\nfunction List({ items }) {\n\n const [isReverse, setIsReverse] = useState(false);\n\n const [selection, setSelection] = useState(null);\n\n // üî¥ Avoid: Adjusting state on prop change in an Effect\n\n useEffect(() => {\n\n setSelection(null);\n\n }, [items]);\n\n // ...\n\n}\n\nThis, too, is not ideal. Every time the items change, the List and its child components will render with a stale selection value at first. Then React will update the DOM and run the Effects. Finally, the setSelection(null) call will cause another re-render of the List and its child components, restarting this whole process again.\n\nStart by deleting the Effect. Instead, adjust the state directly during rendering:\n\nfunction List({ items }) {\n\n const [isReverse, setIsReverse] = useState(false);\n\n const [selection, setSelection] = useState(null);\n\n // Better: Adjust the state while rendering\n\n const [prevItems, setPrevItems] = useState(items);\n\n if (items !== prevItems) {\n\n setPrevItems(items);\n\n setSelection(null);\n\n }\n\n // ...\n\n}\n\nStoring information from previous renders like this can be hard to understand, but it‚Äôs better than updating the same state in an Effect. In the above example, setSelection is called directly during a render. React will re-render the List immediately after it exits with a return statement. React has not rendered the List children or updated the DOM yet, so this lets the List children skip rendering the stale selection value.\n\nWhen you update a component during rendering, React throws away the returned JSX and immediately retries rendering. To avoid very slow cascading retries, React only lets you update the same component‚Äôs state during a render. If you update another component‚Äôs state during a render, you‚Äôll see an error. A condition like items !== prevItems is necessary to avoid loops. You may adjust state like this, but any other side effects (like changing the DOM or setting timeouts) should stay in event handlers or Effects to keep components pure.\n\nAlthough this pattern is more efficient than an Effect, most components shouldn‚Äôt need it either. No matter how you do it, adjusting state based on props or other state makes your data flow more difficult to understand and debug. Always check whether you can reset all state with a key or calculate everything during rendering instead. For example, instead of storing (and resetting) the selected item, you can store the selected item ID:\n\nfunction List({ items }) {\n\n const [isReverse, setIsReverse] = useState(false);\n\n const [selectedId, setSelectedId] = useState(null);\n\n // ‚úÖ Best: Calculate everything during rendering\n\n const selection = items.find(item => item.id === selectedId) ?? null;\n\n // ...\n\n}\n\nNow there is no need to ‚Äúadjust‚Äù the state at all. If the item with the selected ID is in the list, it remains selected. If it‚Äôs not, the selection calculated during rendering will be null because no matching item was found. This behavior is different, but arguably better because most changes to items preserve the selection.\n\nSharing logic between event handlers \n\nLet‚Äôs say you have a product page with two buttons (Buy and Checkout) that both let you buy that product. You want to show a notification whenever the user puts the product in the cart. Calling showNotification() in both buttons‚Äô click handlers feels repetitive so you might be tempted to place this logic in an Effect:\n\nfunction ProductPage({ product, addToCart }) {\n\n // üî¥ Avoid: Event-specific logic inside an Effect\n\n useEffect(() => {\n\n if (product.isInCart) {\n\n showNotification(`Added ${product.name} to the shopping cart!`);\n\n }\n\n }, [product]);\n\n function handleBuyClick() {\n\n addToCart(product);\n\n }\n\n function handleCheckoutClick() {\n\n addToCart(product);\n\n navigateTo('/checkout');\n\n }\n\n // ...\n\n}\n\nThis Effect is unnecessary. It will also most likely cause bugs. For example, let‚Äôs say that your app ‚Äúremembers‚Äù the shopping cart between the page reloads. If you add a product to the cart once and refresh the page, the notification will appear again. It will keep appearing every time you refresh that product‚Äôs page. This is because product.isInCart will already be true on the page load, so the Effect above will call showNotification().\n\nWhen you‚Äôre not sure whether some code should be in an Effect or in an event handler, ask yourself why this code needs to run. Use Effects only for code that should run because the component was displayed to the user. In this example, the notification should appear because the user pressed the button, not because the page was displayed! Delete the Effect and put the shared logic into a function called from both event handlers:\n\nfunction ProductPage({ product, addToCart }) {\n\n // ‚úÖ Good: Event-specific logic is called from event handlers\n\n function buyProduct() {\n\n addToCart(product);\n\n showNotification(`Added ${product.name} to the shopping cart!`);\n\n }\n\n function handleBuyClick() {\n\n buyProduct();\n\n }\n\n function handleCheckoutClick() {\n\n buyProduct();\n\n navigateTo('/checkout');\n\n }\n\n // ...\n\n}\n\nThis both removes the unnecessary Effect and fixes the bug.\n\nSending a POST request \n\nThis Form component sends two kinds of POST requests. It sends an analytics event when it mounts. When you fill in the form and click the Submit button, it will send a POST request to the /api/register endpoint:\n\nfunction Form() {\n\n const [firstName, setFirstName] = useState('');\n\n const [lastName, setLastName] = useState('');\n\n // ‚úÖ Good: This logic should run because the component was displayed\n\n useEffect(() => {\n\n post('/analytics/event', { eventName: 'visit_form' });\n\n }, []);\n\n // üî¥ Avoid: Event-specific logic inside an Effect\n\n const [jsonToSubmit, setJsonToSubmit] = useState(null);\n\n useEffect(() => {\n\n if (jsonToSubmit !== null) {\n\n post('/api/register', jsonToSubmit);\n\n }\n\n }, [jsonToSubmit]);\n\n function handleSubmit(e) {\n\n e.preventDefault();\n\n setJsonToSubmit({ firstName, lastName });\n\n }\n\n // ...\n\n}\n\nLet‚Äôs apply the same criteria as in the example before.\n\nThe analytics POST request should remain in an Effect. This is because the reason to send the analytics event is that the form was displayed. (It would fire twice in development, but see here for how to deal with that.)\n\nHowever, the /api/register POST request is not caused by the form being displayed. You only want to send the request at one specific moment in time: when the user presses the button. It should only ever happen on that particular interaction. Delete the second Effect and move that POST request into the event handler:\n\nfunction Form() {\n\n const [firstName, setFirstName] = useState('');\n\n const [lastName, setLastName] = useState('');\n\n // ‚úÖ Good: This logic runs because the component was displayed\n\n useEffect(() => {\n\n post('/analytics/event', { eventName: 'visit_form' });\n\n }, []);\n\n function handleSubmit(e) {\n\n e.preventDefault();\n\n // ‚úÖ Good: Event-specific logic is in the event handler\n\n post('/api/register', { firstName, lastName });\n\n }\n\n // ...\n\n}\n\nWhen you choose whether to put some logic into an event handler or an Effect, the main question you need to answer is what kind of logic it is from the user‚Äôs perspective. If this logic is caused by a particular interaction, keep it in the event handler. If it‚Äôs caused by the user seeing the component on the screen, keep it in the Effect.\n\nChains of computations \n\nSometimes you might feel tempted to chain Effects that each adjust a piece of state based on other state:\n\nfunction Game() {\n\n const [card, setCard] = useState(null);\n\n const [goldCardCount, setGoldCardCount] = useState(0);\n\n const [round, setRound] = useState(1);\n\n const [isGameOver, setIsGameOver] = useState(false);\n\n // üî¥ Avoid: Chains of Effects that adjust the state solely to trigger each other\n\n useEffect(() => {\n\n if (card !== null && card.gold) {\n\n setGoldCardCount(c => c + 1);\n\n }\n\n }, [card]);\n\n useEffect(() => {\n\n if (goldCardCount > 3) {\n\n setRound(r => r + 1)\n\n setGoldCardCount(0);\n\n }\n\n }, [goldCardCount]);\n\n useEffect(() => {\n\n if (round > 5) {\n\n setIsGameOver(true);\n\n }\n\n }, [round]);\n\n useEffect(() => {\n\n alert('Good game!');\n\n }, [isGameOver]);\n\n function handlePlaceCard(nextCard) {\n\n if (isGameOver) {\n\n throw Error('Game already ended.');\n\n } else {\n\n setCard(nextCard);\n\n }\n\n }\n\n // ...\n\nThere are two problems with this code.\n\nThe first problem is that it is very inefficient: the component (and its children) have to re-render between each set call in the chain. In the example above, in the worst case (setCard ‚Üí render ‚Üí setGoldCardCount ‚Üí render ‚Üí setRound ‚Üí render ‚Üí setIsGameOver ‚Üí render) there are three unnecessary re-renders of the tree below.\n\nThe second problem is that even if it weren‚Äôt slow, as your code evolves, you will run into cases where the ‚Äúchain‚Äù you wrote doesn‚Äôt fit the new requirements. Imagine you are adding a way to step through the history of the game moves. You‚Äôd do it by updating each state variable to a value from the past. However, setting the card state to a value from the past would trigger the Effect chain again and change the data you‚Äôre showing. Such code is often rigid and fragile.\n\nIn this case, it‚Äôs better to calculate what you can during rendering, and adjust the state in the event handler:\n\nfunction Game() {\n\n const [card, setCard] = useState(null);\n\n const [goldCardCount, setGoldCardCount] = useState(0);\n\n const [round, setRound] = useState(1);\n\n // ‚úÖ Calculate what you can during rendering\n\n const isGameOver = round > 5;\n\n function handlePlaceCard(nextCard) {\n\n if (isGameOver) {\n\n throw Error('Game already ended.');\n\n }\n\n // ‚úÖ Calculate all the next state in the event handler\n\n setCard(nextCard);\n\n if (nextCard.gold) {\n\n if (goldCardCount < 3) {\n\n setGoldCardCount(goldCardCount + 1);\n\n } else {\n\n setGoldCardCount(0);\n\n setRound(round + 1);\n\n if (round === 5) {\n\n alert('Good game!');\n\n }\n\n }\n\n }\n\n }\n\n // ...\n\nThis is a lot more efficient. Also, if you implement a way to view game history, now you will be able to set each state variable to a move from the past without triggering the Effect chain that adjusts every other value. If you need to reuse logic between several event handlers, you can extract a function and call it from those handlers.\n\nRemember that inside event handlers, state behaves like a snapshot. For example, even after you call setRound(round + 1), the round variable will reflect the value at the time the user clicked the button. If you need to use the next value for calculations, define it manually like const nextRound = round + 1.\n\nIn some cases, you can‚Äôt calculate the next state directly in the event handler. For example, imagine a form with multiple dropdowns where the options of the next dropdown depend on the selected value of the previous dropdown. Then, a chain of Effects is appropriate because you are synchronizing with network.\n\nInitializing the application \n\nSome logic should only run once when the app loads.\n\nYou might be tempted to place it in an Effect in the top-level component:\n\nfunction App() {\n\n // üî¥ Avoid: Effects with logic that should only ever run once\n\n useEffect(() => {\n\n loadDataFromLocalStorage();\n\n checkAuthToken();\n\n }, []);\n\n // ...\n\n}\n\nHowever, you‚Äôll quickly discover that it runs twice in development. This can cause issues‚Äîfor example, maybe it invalidates the authentication token because the function wasn‚Äôt designed to be called twice. In general, your components should be resilient to being remounted. This includes your top-level App component.\n\nAlthough it may not ever get remounted in practice in production, following the same constraints in all components makes it easier to move and reuse code. If some logic must run once per app load rather than once per component mount, add a top-level variable to track whether it has already executed:\n\nlet didInit = false;\n\nfunction App() {\n\n useEffect(() => {\n\n if (!didInit) {\n\n didInit = true;\n\n // ‚úÖ Only runs once per app load\n\n loadDataFromLocalStorage();\n\n checkAuthToken();\n\n }\n\n }, []);\n\n // ...\n\n}\n\nYou can also run it during module initialization and before the app renders:\n\nif (typeof window !== 'undefined') { // Check if we're running in the browser.\n\n // ‚úÖ Only runs once per app load\n\n checkAuthToken();\n\n loadDataFromLocalStorage();\n\n}\n\nfunction App() {\n\n // ...\n\n}\n\nCode at the top level runs once when your component is imported‚Äîeven if it doesn‚Äôt end up being rendered. To avoid slowdown or surprising behavior when importing arbitrary components, don‚Äôt overuse this pattern. Keep app-wide initialization logic to root component modules like App.js or in your application‚Äôs entry point.\n\nNotifying parent components about state changes \n\nLet‚Äôs say you‚Äôre writing a Toggle component with an internal isOn state which can be either true or false. There are a few different ways to toggle it (by clicking or dragging). You want to notify the parent component whenever the Toggle internal state changes, so you expose an onChange event and call it from an Effect:\n\nfunction Toggle({ onChange }) {\n\n const [isOn, setIsOn] = useState(false);\n\n // üî¥ Avoid: The onChange handler runs too late\n\n useEffect(() => {\n\n onChange(isOn);\n\n }, [isOn, onChange])\n\n function handleClick() {\n\n setIsOn(!isOn);\n\n }\n\n function handleDragEnd(e) {\n\n if (isCloserToRightEdge(e)) {\n\n setIsOn(true);\n\n } else {\n\n setIsOn(false);\n\n }\n\n }\n\n // ...\n\n}\n\nLike earlier, this is not ideal. The Toggle updates its state first, and React updates the screen. Then React runs the Effect, which calls the onChange function passed from a parent component. Now the parent component will update its own state, starting another render pass. It would be better to do everything in a single pass.\n\nDelete the Effect and instead update the state of both components within the same event handler:\n\nfunction Toggle({ onChange }) {\n\n const [isOn, setIsOn] = useState(false);\n\n function updateToggle(nextIsOn) {\n\n // ‚úÖ Good: Perform all updates during the event that caused them\n\n setIsOn(nextIsOn);\n\n onChange(nextIsOn);\n\n }\n\n function handleClick() {\n\n updateToggle(!isOn);\n\n }\n\n function handleDragEnd(e) {\n\n if (isCloserToRightEdge(e)) {\n\n updateToggle(true);\n\n } else {\n\n updateToggle(false);\n\n }\n\n }\n\n // ...\n\n}\n\nWith this approach, both the Toggle component and its parent component update their state during the event. React batches updates from different components together, so there will only be one render pass.\n\nYou might also be able to remove the state altogether, and instead receive isOn from the parent component:\n\n// ‚úÖ Also good: the component is fully controlled by its parent\n\nfunction Toggle({ isOn, onChange }) {\n\n function handleClick() {\n\n onChange(!isOn);\n\n }\n\n function handleDragEnd(e) {\n\n if (isCloserToRightEdge(e)) {\n\n onChange(true);\n\n } else {\n\n onChange(false);\n\n }\n\n }\n\n // ...\n\n}\n\n‚ÄúLifting state up‚Äù lets the parent component fully control the Toggle by toggling the parent‚Äôs own state. This means the parent component will have to contain more logic, but there will be less state overall to worry about. Whenever you try to keep two different state variables synchronized, try lifting state up instead!\n\nPassing data to the parent \n\nThis Child component fetches some data and then passes it to the Parent component in an Effect:\n\nfunction Parent() {\n\n const [data, setData] = useState(null);\n\n // ...\n\n return <Child onFetched={setData} />;\n\n}\n\nfunction Child({ onFetched }) {\n\n const data = useSomeAPI();\n\n // üî¥ Avoid: Passing data to the parent in an Effect\n\n useEffect(() => {\n\n if (data) {\n\n onFetched(data);\n\n }\n\n }, [onFetched, data]);\n\n // ...\n\n}\n\nIn React, data flows from the parent components to their children. When you see something wrong on the screen, you can trace where the information comes from by going up the component chain until you find which component passes the wrong prop or has the wrong state. When child components update the state of their parent components in Effects, the data flow becomes very difficult to trace. Since both the child and the parent need the same data, let the parent component fetch that data, and pass it down to the child instead:\n\nfunction Parent() {\n\n const data = useSomeAPI();\n\n // ...\n\n // ‚úÖ Good: Passing data down to the child\n\n return <Child data={data} />;\n\n}\n\nfunction Child({ data }) {\n\n // ...\n\n}\n\nThis is simpler and keeps the data flow predictable: the data flows down from the parent to the child.\n\nSubscribing to an external store \n\nSometimes, your components may need to subscribe to some data outside of the React state. This data could be from a third-party library or a built-in browser API. Since this data can change without React‚Äôs knowledge, you need to manually subscribe your components to it. This is often done with an Effect, for example:\n\nfunction useOnlineStatus() {\n\n // Not ideal: Manual store subscription in an Effect\n\n const [isOnline, setIsOnline] = useState(true);\n\n useEffect(() => {\n\n function updateState() {\n\n setIsOnline(navigator.onLine);\n\n }\n\n updateState();\n\n window.addEventListener('online', updateState);\n\n window.addEventListener('offline', updateState);\n\n return () => {\n\n window.removeEventListener('online', updateState);\n\n window.removeEventListener('offline', updateState);\n\n };\n\n }, []);\n\n return isOnline;\n\n}\n\nfunction ChatIndicator() {\n\n const isOnline = useOnlineStatus();\n\n // ...\n\n}\n\nHere, the component subscribes to an external data store (in this case, the browser navigator.onLine API). Since this API does not exist on the server (so it can‚Äôt be used for the initial HTML), initially the state is set to true. Whenever the value of that data store changes in the browser, the component updates its state.\n\nAlthough it‚Äôs common to use Effects for this, React has a purpose-built Hook for subscribing to an external store that is preferred instead. Delete the Effect and replace it with a call to useSyncExternalStore:\n\nfunction subscribe(callback) {\n\n window.addEventListener('online', callback);\n\n window.addEventListener('offline', callback);\n\n return () => {\n\n window.removeEventListener('online', callback);\n\n window.removeEventListener('offline', callback);\n\n };\n\n}\n\nfunction useOnlineStatus() {\n\n // ‚úÖ Good: Subscribing to an external store with a built-in Hook\n\n return useSyncExternalStore(\n\n subscribe, // React won't resubscribe for as long as you pass the same function\n\n () => navigator.onLine, // How to get the value on the client\n\n () => true // How to get the value on the server\n\n );\n\n}\n\nfunction ChatIndicator() {\n\n const isOnline = useOnlineStatus();\n\n // ...\n\n}\n\nThis approach is less error-prone than manually syncing mutable data to React state with an Effect. Typically, you‚Äôll write a custom Hook like useOnlineStatus() above so that you don‚Äôt need to repeat this code in the individual components. Read more about subscribing to external stores from React components.\n\nFetching data \n\nMany apps use Effects to kick off data fetching. It is quite common to write a data fetching Effect like this:\n\nfunction SearchResults({ query }) {\n\n const [results, setResults] = useState([]);\n\n const [page, setPage] = useState(1);\n\n useEffect(() => {\n\n // üî¥ Avoid: Fetching without cleanup logic\n\n fetchResults(query, page).then(json => {\n\n setResults(json);\n\n });\n\n }, [query, page]);\n\n function handleNextPageClick() {\n\n setPage(page + 1);\n\n }\n\n // ...\n\n}\n\nYou don‚Äôt need to move this fetch to an event handler.\n\nThis might seem like a contradiction with the earlier examples where you needed to put the logic into the event handlers! However, consider that it‚Äôs not the typing event that‚Äôs the main reason to fetch. Search inputs are often prepopulated from the URL, and the user might navigate Back and Forward without touching the input.\n\nIt doesn‚Äôt matter where page and query come from. While this component is visible, you want to keep results synchronized with data from the network for the current page and query. This is why it‚Äôs an Effect.\n\nHowever, the code above has a bug. Imagine you type \"hello\" fast. Then the query will change from \"h\", to \"he\", \"hel\", \"hell\", and \"hello\". This will kick off separate fetches, but there is no guarantee about which order the responses will arrive in. For example, the \"hell\" response may arrive after the \"hello\" response. Since it will call setResults() last, you will be displaying the wrong search results. This is called a ‚Äúrace condition‚Äù: two different requests ‚Äúraced‚Äù against each other and came in a different order than you expected.\n\nTo fix the race condition, you need to add a cleanup function to ignore stale responses:\n\nfunction SearchResults({ query }) {\n\n const [results, setResults] = useState([]);\n\n const [page, setPage] = useState(1);\n\n useEffect(() => {\n\n let ignore = false;\n\n fetchResults(query, page).then(json => {\n\n if (!ignore) {\n\n setResults(json);\n\n }\n\n });\n\n return () => {\n\n ignore = true;\n\n };\n\n }, [query, page]);\n\n function handleNextPageClick() {\n\n setPage(page + 1);\n\n }\n\n // ...\n\n}\n\nThis ensures that when your Effect fetches data, all responses except the last requested one will be ignored.\n\nHandling race conditions is not the only difficulty with implementing data fetching. You might also want to think about caching responses (so that the user can click Back and see the previous screen instantly), how to fetch data on the server (so that the initial server-rendered HTML contains the fetched content instead of a spinner), and how to avoid network waterfalls (so that a child can fetch data without waiting for every parent).\n\nThese issues apply to any UI library, not just React. Solving them is not trivial, which is why modern frameworks provide more efficient built-in data fetching mechanisms than fetching data in Effects.\n\nIf you don‚Äôt use a framework (and don‚Äôt want to build your own) but would like to make data fetching from Effects more ergonomic, consider extracting your fetching logic into a custom Hook like in this example:\n\nfunction SearchResults({ query }) {\n\n const [page, setPage] = useState(1);\n\n const params = new URLSearchParams({ query, page });\n\n const results = useData(`/api/search?${params}`);\n\n function handleNextPageClick() {\n\n setPage(page + 1);\n\n }\n\n // ...\n\n}\n\nfunction useData(url) {\n\n const [data, setData] = useState(null);\n\n useEffect(() => {\n\n let ignore = false;\n\n fetch(url)\n\n .then(response => response.json())\n\n .then(json => {\n\n if (!ignore) {\n\n setData(json);\n\n }\n\n });\n\n return () => {\n\n ignore = true;\n\n };\n\n }, [url]);\n\n return data;\n\n}\n\nYou‚Äôll likely also want to add some logic for error handling and to track whether the content is loading. You can build a Hook like this yourself or use one of the many solutions already available in the React ecosystem. Although this alone won‚Äôt be as efficient as using a framework‚Äôs built-in data fetching mechanism, moving the data fetching logic into a custom Hook will make it easier to adopt an efficient data fetching strategy later.\n\nIn general, whenever you have to resort to writing Effects, keep an eye out for when you can extract a piece of functionality into a custom Hook with a more declarative and purpose-built API like useData above. The fewer raw useEffect calls you have in your components, the easier you will find to maintain your application.\n\nRecap\nIf you can calculate something during render, you don‚Äôt need an Effect.\nTo cache expensive calculations, add useMemo instead of useEffect.\nTo reset the state of an entire component tree, pass a different key to it.\nTo reset a particular bit of state in response to a prop change, set it during rendering.\nCode that runs because a component was displayed should be in Effects, the rest should be in events.\nIf you need to update the state of several components, it‚Äôs better to do it during a single event.\nWhenever you try to synchronize state variables in different components, consider lifting state up.\nYou can fetch data with Effects, but you need to implement cleanup to avoid race conditions.\nTry out some challenges\n1. Transform data without Effects\n2. Cache a calculation without Effects\n3. Reset state without Effects\n4. Submit a form without Effects\nChallenge 1 of 4: Transform data without Effects \n\nThe TodoList below displays a list of todos. When the ‚ÄúShow only active todos‚Äù checkbox is ticked, completed todos are not displayed in the list. Regardless of which todos are visible, the footer displays the count of todos that are not yet completed.\n\nSimplify this component by removing all the unnecessary state and Effects.\n\nApp.js\ntodos.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { initialTodos, createTodo } from './todos.js';\n\nexport default function TodoList() {\n const [todos, setTodos] = useState(initialTodos);\n const [showActive, setShowActive] = useState(false);\n const [activeTodos, setActiveTodos] = useState([]);\n const [visibleTodos, setVisibleTodos] = useState([]);\n const [footer, setFooter] = useState(null);\n\n useEffect(() => {\n setActiveTodos(todos.filter(todo => !todo.completed));\n }, [todos]);\n\n useEffect(() => {\n setVisibleTodos(showActive ? activeTodos : todos);\n }, [showActive, todos, activeTodos]);\n\n useEffect(() => {\n setFooter(\n <footer>\n {activeTodos.length} todos left\n </footer>\n );\n }, [activeTodos]);\n\n return (\n <>\n <label>\n <input\n type=\"checkbox\"\n checked={showActive}\n onChange={e => setShowActive(e.target.checked)}\n />\n Show only active todos\n </label>\n <NewTodo onAdd={newTodo => setTodos([...todos, newTodo])} />\n <ul>\n {visibleTodos.map(todo => (\n <li key={todo.id}>\n {todo.completed ? <s>{todo.text}</s> : todo.text}\n </li>\n ))}\n </ul>\n {footer}\n </>\n );\n}\n\nfunction NewTodo({ onAdd }) {\n const [text, setText] = useState('');\n\n function handleAddClick() {\n setText('');\n onAdd(createTodo(text));\n }\n\n return (\n <>\n <input value={text} onChange={e => setText(e.target.value)} />\n <button onClick={handleAddClick}>\n Add\n </button>\n </>\n );\n}\n\nShow more\nShow hint\nShow solution\nNext Challenge\nPREVIOUS\nSynchronizing with Effects\nNEXT\nLifecycle of Reactive Effects",
      "tables": [],
      "code_blocks": [
        "function Form() {\n\n  const [firstName, setFirstName] = useState('Taylor');\n\n  const [lastName, setLastName] = useState('Swift');\n\n\n\n  // üî¥ Avoid: redundant state and unnecessary Effect\n\n  const [fullName, setFullName] = useState('');\n\n  useEffect(() => {\n\n    setFullName(firstName + ' ' + lastName);\n\n  }, [firstName, lastName]);\n\n  // ...\n\n}",
        "function Form() {\n\n  const [firstName, setFirstName] = useState('Taylor');\n\n  const [lastName, setLastName] = useState('Swift');\n\n\n\n  // üî¥ Avoid: redundant state and unnecessary Effect\n\n  const [fullName, setFullName] = useState('');\n\n  useEffect(() => {\n\n    setFullName(firstName + ' ' + lastName);\n\n  }, [firstName, lastName]);\n\n  // ...\n\n}",
        "function Form() {\n\n  const [firstName, setFirstName] = useState('Taylor');\n\n  const [lastName, setLastName] = useState('Swift');\n\n  // ‚úÖ Good: calculated during rendering\n\n  const fullName = firstName + ' ' + lastName;\n\n  // ...\n\n}",
        "function Form() {\n\n  const [firstName, setFirstName] = useState('Taylor');\n\n  const [lastName, setLastName] = useState('Swift');\n\n  // ‚úÖ Good: calculated during rendering\n\n  const fullName = firstName + ' ' + lastName;\n\n  // ...\n\n}",
        "visibleTodos",
        "function TodoList({ todos, filter }) {\n\n  const [newTodo, setNewTodo] = useState('');\n\n\n\n  // üî¥ Avoid: redundant state and unnecessary Effect\n\n  const [visibleTodos, setVisibleTodos] = useState([]);\n\n  useEffect(() => {\n\n    setVisibleTodos(getFilteredTodos(todos, filter));\n\n  }, [todos, filter]);\n\n\n\n  // ...\n\n}",
        "function TodoList({ todos, filter }) {\n\n  const [newTodo, setNewTodo] = useState('');\n\n\n\n  // üî¥ Avoid: redundant state and unnecessary Effect\n\n  const [visibleTodos, setVisibleTodos] = useState([]);\n\n  useEffect(() => {\n\n    setVisibleTodos(getFilteredTodos(todos, filter));\n\n  }, [todos, filter]);\n\n\n\n  // ...\n\n}",
        "function TodoList({ todos, filter }) {\n\n  const [newTodo, setNewTodo] = useState('');\n\n  // ‚úÖ This is fine if getFilteredTodos() is not slow.\n\n  const visibleTodos = getFilteredTodos(todos, filter);\n\n  // ...\n\n}",
        "function TodoList({ todos, filter }) {\n\n  const [newTodo, setNewTodo] = useState('');\n\n  // ‚úÖ This is fine if getFilteredTodos() is not slow.\n\n  const visibleTodos = getFilteredTodos(todos, filter);\n\n  // ...\n\n}",
        "getFilteredTodos()",
        "getFilteredTodos()",
        "import { useMemo, useState } from 'react';\n\n\n\nfunction TodoList({ todos, filter }) {\n\n  const [newTodo, setNewTodo] = useState('');\n\n  const visibleTodos = useMemo(() => {\n\n    // ‚úÖ Does not re-run unless todos or filter change\n\n    return getFilteredTodos(todos, filter);\n\n  }, [todos, filter]);\n\n  // ...\n\n}",
        "import { useMemo, useState } from 'react';\n\n\n\nfunction TodoList({ todos, filter }) {\n\n  const [newTodo, setNewTodo] = useState('');\n\n  const visibleTodos = useMemo(() => {\n\n    // ‚úÖ Does not re-run unless todos or filter change\n\n    return getFilteredTodos(todos, filter);\n\n  }, [todos, filter]);\n\n  // ...\n\n}",
        "import { useMemo, useState } from 'react';\n\n\n\nfunction TodoList({ todos, filter }) {\n\n  const [newTodo, setNewTodo] = useState('');\n\n  // ‚úÖ Does not re-run getFilteredTodos() unless todos or filter change\n\n  const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);\n\n  // ...\n\n}",
        "import { useMemo, useState } from 'react';\n\n\n\nfunction TodoList({ todos, filter }) {\n\n  const [newTodo, setNewTodo] = useState('');\n\n  // ‚úÖ Does not re-run getFilteredTodos() unless todos or filter change\n\n  const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);\n\n  // ...\n\n}",
        "getFilteredTodos()",
        "ProfilePage",
        "export default function ProfilePage({ userId }) {\n\n  const [comment, setComment] = useState('');\n\n\n\n  // üî¥ Avoid: Resetting state on prop change in an Effect\n\n  useEffect(() => {\n\n    setComment('');\n\n  }, [userId]);\n\n  // ...\n\n}",
        "export default function ProfilePage({ userId }) {\n\n  const [comment, setComment] = useState('');\n\n\n\n  // üî¥ Avoid: Resetting state on prop change in an Effect\n\n  useEffect(() => {\n\n    setComment('');\n\n  }, [userId]);\n\n  // ...\n\n}",
        "ProfilePage",
        "ProfilePage",
        "export default function ProfilePage({ userId }) {\n\n  return (\n\n    <Profile\n\n      userId={userId}\n\n      key={userId}\n\n    />\n\n  );\n\n}\n\n\n\nfunction Profile({ userId }) {\n\n  // ‚úÖ This and any other state below will reset on key change automatically\n\n  const [comment, setComment] = useState('');\n\n  // ...\n\n}",
        "export default function ProfilePage({ userId }) {\n\n  return (\n\n    <Profile\n\n      userId={userId}\n\n      key={userId}\n\n    />\n\n  );\n\n}\n\n\n\nfunction Profile({ userId }) {\n\n  // ‚úÖ This and any other state below will reset on key change automatically\n\n  const [comment, setComment] = useState('');\n\n  // ...\n\n}",
        "ProfilePage",
        "ProfilePage",
        "ProfilePage",
        "function List({ items }) {\n\n  const [isReverse, setIsReverse] = useState(false);\n\n  const [selection, setSelection] = useState(null);\n\n\n\n  // üî¥ Avoid: Adjusting state on prop change in an Effect\n\n  useEffect(() => {\n\n    setSelection(null);\n\n  }, [items]);\n\n  // ...\n\n}",
        "function List({ items }) {\n\n  const [isReverse, setIsReverse] = useState(false);\n\n  const [selection, setSelection] = useState(null);\n\n\n\n  // üî¥ Avoid: Adjusting state on prop change in an Effect\n\n  useEffect(() => {\n\n    setSelection(null);\n\n  }, [items]);\n\n  // ...\n\n}",
        "setSelection(null)",
        "function List({ items }) {\n\n  const [isReverse, setIsReverse] = useState(false);\n\n  const [selection, setSelection] = useState(null);\n\n\n\n  // Better: Adjust the state while rendering\n\n  const [prevItems, setPrevItems] = useState(items);\n\n  if (items !== prevItems) {\n\n    setPrevItems(items);\n\n    setSelection(null);\n\n  }\n\n  // ...\n\n}",
        "function List({ items }) {\n\n  const [isReverse, setIsReverse] = useState(false);\n\n  const [selection, setSelection] = useState(null);\n\n\n\n  // Better: Adjust the state while rendering\n\n  const [prevItems, setPrevItems] = useState(items);\n\n  if (items !== prevItems) {\n\n    setPrevItems(items);\n\n    setSelection(null);\n\n  }\n\n  // ...\n\n}",
        "setSelection",
        "items !== prevItems",
        "function List({ items }) {\n\n  const [isReverse, setIsReverse] = useState(false);\n\n  const [selectedId, setSelectedId] = useState(null);\n\n  // ‚úÖ Best: Calculate everything during rendering\n\n  const selection = items.find(item => item.id === selectedId) ?? null;\n\n  // ...\n\n}",
        "function List({ items }) {\n\n  const [isReverse, setIsReverse] = useState(false);\n\n  const [selectedId, setSelectedId] = useState(null);\n\n  // ‚úÖ Best: Calculate everything during rendering\n\n  const selection = items.find(item => item.id === selectedId) ?? null;\n\n  // ...\n\n}",
        "showNotification()",
        "function ProductPage({ product, addToCart }) {\n\n  // üî¥ Avoid: Event-specific logic inside an Effect\n\n  useEffect(() => {\n\n    if (product.isInCart) {\n\n      showNotification(`Added ${product.name} to the shopping cart!`);\n\n    }\n\n  }, [product]);\n\n\n\n  function handleBuyClick() {\n\n    addToCart(product);\n\n  }\n\n\n\n  function handleCheckoutClick() {\n\n    addToCart(product);\n\n    navigateTo('/checkout');\n\n  }\n\n  // ...\n\n}",
        "function ProductPage({ product, addToCart }) {\n\n  // üî¥ Avoid: Event-specific logic inside an Effect\n\n  useEffect(() => {\n\n    if (product.isInCart) {\n\n      showNotification(`Added ${product.name} to the shopping cart!`);\n\n    }\n\n  }, [product]);\n\n\n\n  function handleBuyClick() {\n\n    addToCart(product);\n\n  }\n\n\n\n  function handleCheckoutClick() {\n\n    addToCart(product);\n\n    navigateTo('/checkout');\n\n  }\n\n  // ...\n\n}",
        "product.isInCart",
        "showNotification()",
        "function ProductPage({ product, addToCart }) {\n\n  // ‚úÖ Good: Event-specific logic is called from event handlers\n\n  function buyProduct() {\n\n    addToCart(product);\n\n    showNotification(`Added ${product.name} to the shopping cart!`);\n\n  }\n\n\n\n  function handleBuyClick() {\n\n    buyProduct();\n\n  }\n\n\n\n  function handleCheckoutClick() {\n\n    buyProduct();\n\n    navigateTo('/checkout');\n\n  }\n\n  // ...\n\n}",
        "function ProductPage({ product, addToCart }) {\n\n  // ‚úÖ Good: Event-specific logic is called from event handlers\n\n  function buyProduct() {\n\n    addToCart(product);\n\n    showNotification(`Added ${product.name} to the shopping cart!`);\n\n  }\n\n\n\n  function handleBuyClick() {\n\n    buyProduct();\n\n  }\n\n\n\n  function handleCheckoutClick() {\n\n    buyProduct();\n\n    navigateTo('/checkout');\n\n  }\n\n  // ...\n\n}",
        "/api/register",
        "function Form() {\n\n  const [firstName, setFirstName] = useState('');\n\n  const [lastName, setLastName] = useState('');\n\n\n\n  // ‚úÖ Good: This logic should run because the component was displayed\n\n  useEffect(() => {\n\n    post('/analytics/event', { eventName: 'visit_form' });\n\n  }, []);\n\n\n\n  // üî¥ Avoid: Event-specific logic inside an Effect\n\n  const [jsonToSubmit, setJsonToSubmit] = useState(null);\n\n  useEffect(() => {\n\n    if (jsonToSubmit !== null) {\n\n      post('/api/register', jsonToSubmit);\n\n    }\n\n  }, [jsonToSubmit]);\n\n\n\n  function handleSubmit(e) {\n\n    e.preventDefault();\n\n    setJsonToSubmit({ firstName, lastName });\n\n  }\n\n  // ...\n\n}",
        "function Form() {\n\n  const [firstName, setFirstName] = useState('');\n\n  const [lastName, setLastName] = useState('');\n\n\n\n  // ‚úÖ Good: This logic should run because the component was displayed\n\n  useEffect(() => {\n\n    post('/analytics/event', { eventName: 'visit_form' });\n\n  }, []);\n\n\n\n  // üî¥ Avoid: Event-specific logic inside an Effect\n\n  const [jsonToSubmit, setJsonToSubmit] = useState(null);\n\n  useEffect(() => {\n\n    if (jsonToSubmit !== null) {\n\n      post('/api/register', jsonToSubmit);\n\n    }\n\n  }, [jsonToSubmit]);\n\n\n\n  function handleSubmit(e) {\n\n    e.preventDefault();\n\n    setJsonToSubmit({ firstName, lastName });\n\n  }\n\n  // ...\n\n}",
        "/api/register",
        "function Form() {\n\n  const [firstName, setFirstName] = useState('');\n\n  const [lastName, setLastName] = useState('');\n\n\n\n  // ‚úÖ Good: This logic runs because the component was displayed\n\n  useEffect(() => {\n\n    post('/analytics/event', { eventName: 'visit_form' });\n\n  }, []);\n\n\n\n  function handleSubmit(e) {\n\n    e.preventDefault();\n\n    // ‚úÖ Good: Event-specific logic is in the event handler\n\n    post('/api/register', { firstName, lastName });\n\n  }\n\n  // ...\n\n}",
        "function Form() {\n\n  const [firstName, setFirstName] = useState('');\n\n  const [lastName, setLastName] = useState('');\n\n\n\n  // ‚úÖ Good: This logic runs because the component was displayed\n\n  useEffect(() => {\n\n    post('/analytics/event', { eventName: 'visit_form' });\n\n  }, []);\n\n\n\n  function handleSubmit(e) {\n\n    e.preventDefault();\n\n    // ‚úÖ Good: Event-specific logic is in the event handler\n\n    post('/api/register', { firstName, lastName });\n\n  }\n\n  // ...\n\n}",
        "function Game() {\n\n  const [card, setCard] = useState(null);\n\n  const [goldCardCount, setGoldCardCount] = useState(0);\n\n  const [round, setRound] = useState(1);\n\n  const [isGameOver, setIsGameOver] = useState(false);\n\n\n\n  // üî¥ Avoid: Chains of Effects that adjust the state solely to trigger each other\n\n  useEffect(() => {\n\n    if (card !== null && card.gold) {\n\n      setGoldCardCount(c => c + 1);\n\n    }\n\n  }, [card]);\n\n\n\n  useEffect(() => {\n\n    if (goldCardCount > 3) {\n\n      setRound(r => r + 1)\n\n      setGoldCardCount(0);\n\n    }\n\n  }, [goldCardCount]);\n\n\n\n  useEffect(() => {\n\n    if (round > 5) {\n\n      setIsGameOver(true);\n\n    }\n\n  }, [round]);\n\n\n\n  useEffect(() => {\n\n    alert('Good game!');\n\n  }, [isGameOver]);\n\n\n\n  function handlePlaceCard(nextCard) {\n\n    if (isGameOver) {\n\n      throw Error('Game already ended.');\n\n    } else {\n\n      setCard(nextCard);\n\n    }\n\n  }\n\n\n\n  // ...",
        "function Game() {\n\n  const [card, setCard] = useState(null);\n\n  const [goldCardCount, setGoldCardCount] = useState(0);\n\n  const [round, setRound] = useState(1);\n\n  const [isGameOver, setIsGameOver] = useState(false);\n\n\n\n  // üî¥ Avoid: Chains of Effects that adjust the state solely to trigger each other\n\n  useEffect(() => {\n\n    if (card !== null && card.gold) {\n\n      setGoldCardCount(c => c + 1);\n\n    }\n\n  }, [card]);\n\n\n\n  useEffect(() => {\n\n    if (goldCardCount > 3) {\n\n      setRound(r => r + 1)\n\n      setGoldCardCount(0);\n\n    }\n\n  }, [goldCardCount]);\n\n\n\n  useEffect(() => {\n\n    if (round > 5) {\n\n      setIsGameOver(true);\n\n    }\n\n  }, [round]);\n\n\n\n  useEffect(() => {\n\n    alert('Good game!');\n\n  }, [isGameOver]);\n\n\n\n  function handlePlaceCard(nextCard) {\n\n    if (isGameOver) {\n\n      throw Error('Game already ended.');\n\n    } else {\n\n      setCard(nextCard);\n\n    }\n\n  }\n\n\n\n  // ...",
        "setGoldCardCount",
        "setIsGameOver",
        "function Game() {\n\n  const [card, setCard] = useState(null);\n\n  const [goldCardCount, setGoldCardCount] = useState(0);\n\n  const [round, setRound] = useState(1);\n\n\n\n  // ‚úÖ Calculate what you can during rendering\n\n  const isGameOver = round > 5;\n\n\n\n  function handlePlaceCard(nextCard) {\n\n    if (isGameOver) {\n\n      throw Error('Game already ended.');\n\n    }\n\n\n\n    // ‚úÖ Calculate all the next state in the event handler\n\n    setCard(nextCard);\n\n    if (nextCard.gold) {\n\n      if (goldCardCount < 3) {\n\n        setGoldCardCount(goldCardCount + 1);\n\n      } else {\n\n        setGoldCardCount(0);\n\n        setRound(round + 1);\n\n        if (round === 5) {\n\n          alert('Good game!');\n\n        }\n\n      }\n\n    }\n\n  }\n\n\n\n  // ...",
        "function Game() {\n\n  const [card, setCard] = useState(null);\n\n  const [goldCardCount, setGoldCardCount] = useState(0);\n\n  const [round, setRound] = useState(1);\n\n\n\n  // ‚úÖ Calculate what you can during rendering\n\n  const isGameOver = round > 5;\n\n\n\n  function handlePlaceCard(nextCard) {\n\n    if (isGameOver) {\n\n      throw Error('Game already ended.');\n\n    }\n\n\n\n    // ‚úÖ Calculate all the next state in the event handler\n\n    setCard(nextCard);\n\n    if (nextCard.gold) {\n\n      if (goldCardCount < 3) {\n\n        setGoldCardCount(goldCardCount + 1);\n\n      } else {\n\n        setGoldCardCount(0);\n\n        setRound(round + 1);\n\n        if (round === 5) {\n\n          alert('Good game!');\n\n        }\n\n      }\n\n    }\n\n  }\n\n\n\n  // ...",
        "setRound(round + 1)",
        "const nextRound = round + 1",
        "function App() {\n\n  // üî¥ Avoid: Effects with logic that should only ever run once\n\n  useEffect(() => {\n\n    loadDataFromLocalStorage();\n\n    checkAuthToken();\n\n  }, []);\n\n  // ...\n\n}",
        "function App() {\n\n  // üî¥ Avoid: Effects with logic that should only ever run once\n\n  useEffect(() => {\n\n    loadDataFromLocalStorage();\n\n    checkAuthToken();\n\n  }, []);\n\n  // ...\n\n}",
        "let didInit = false;\n\n\n\nfunction App() {\n\n  useEffect(() => {\n\n    if (!didInit) {\n\n      didInit = true;\n\n      // ‚úÖ Only runs once per app load\n\n      loadDataFromLocalStorage();\n\n      checkAuthToken();\n\n    }\n\n  }, []);\n\n  // ...\n\n}",
        "let didInit = false;\n\n\n\nfunction App() {\n\n  useEffect(() => {\n\n    if (!didInit) {\n\n      didInit = true;\n\n      // ‚úÖ Only runs once per app load\n\n      loadDataFromLocalStorage();\n\n      checkAuthToken();\n\n    }\n\n  }, []);\n\n  // ...\n\n}",
        "if (typeof window !== 'undefined') { // Check if we're running in the browser.\n\n   // ‚úÖ Only runs once per app load\n\n  checkAuthToken();\n\n  loadDataFromLocalStorage();\n\n}\n\n\n\nfunction App() {\n\n  // ...\n\n}",
        "if (typeof window !== 'undefined') { // Check if we're running in the browser.\n\n   // ‚úÖ Only runs once per app load\n\n  checkAuthToken();\n\n  loadDataFromLocalStorage();\n\n}\n\n\n\nfunction App() {\n\n  // ...\n\n}",
        "function Toggle({ onChange }) {\n\n  const [isOn, setIsOn] = useState(false);\n\n\n\n  // üî¥ Avoid: The onChange handler runs too late\n\n  useEffect(() => {\n\n    onChange(isOn);\n\n  }, [isOn, onChange])\n\n\n\n  function handleClick() {\n\n    setIsOn(!isOn);\n\n  }\n\n\n\n  function handleDragEnd(e) {\n\n    if (isCloserToRightEdge(e)) {\n\n      setIsOn(true);\n\n    } else {\n\n      setIsOn(false);\n\n    }\n\n  }\n\n\n\n  // ...\n\n}",
        "function Toggle({ onChange }) {\n\n  const [isOn, setIsOn] = useState(false);\n\n\n\n  // üî¥ Avoid: The onChange handler runs too late\n\n  useEffect(() => {\n\n    onChange(isOn);\n\n  }, [isOn, onChange])\n\n\n\n  function handleClick() {\n\n    setIsOn(!isOn);\n\n  }\n\n\n\n  function handleDragEnd(e) {\n\n    if (isCloserToRightEdge(e)) {\n\n      setIsOn(true);\n\n    } else {\n\n      setIsOn(false);\n\n    }\n\n  }\n\n\n\n  // ...\n\n}",
        "function Toggle({ onChange }) {\n\n  const [isOn, setIsOn] = useState(false);\n\n\n\n  function updateToggle(nextIsOn) {\n\n    // ‚úÖ Good: Perform all updates during the event that caused them\n\n    setIsOn(nextIsOn);\n\n    onChange(nextIsOn);\n\n  }\n\n\n\n  function handleClick() {\n\n    updateToggle(!isOn);\n\n  }\n\n\n\n  function handleDragEnd(e) {\n\n    if (isCloserToRightEdge(e)) {\n\n      updateToggle(true);\n\n    } else {\n\n      updateToggle(false);\n\n    }\n\n  }\n\n\n\n  // ...\n\n}",
        "function Toggle({ onChange }) {\n\n  const [isOn, setIsOn] = useState(false);\n\n\n\n  function updateToggle(nextIsOn) {\n\n    // ‚úÖ Good: Perform all updates during the event that caused them\n\n    setIsOn(nextIsOn);\n\n    onChange(nextIsOn);\n\n  }\n\n\n\n  function handleClick() {\n\n    updateToggle(!isOn);\n\n  }\n\n\n\n  function handleDragEnd(e) {\n\n    if (isCloserToRightEdge(e)) {\n\n      updateToggle(true);\n\n    } else {\n\n      updateToggle(false);\n\n    }\n\n  }\n\n\n\n  // ...\n\n}",
        "// ‚úÖ Also good: the component is fully controlled by its parent\n\nfunction Toggle({ isOn, onChange }) {\n\n  function handleClick() {\n\n    onChange(!isOn);\n\n  }\n\n\n\n  function handleDragEnd(e) {\n\n    if (isCloserToRightEdge(e)) {\n\n      onChange(true);\n\n    } else {\n\n      onChange(false);\n\n    }\n\n  }\n\n\n\n  // ...\n\n}",
        "// ‚úÖ Also good: the component is fully controlled by its parent\n\nfunction Toggle({ isOn, onChange }) {\n\n  function handleClick() {\n\n    onChange(!isOn);\n\n  }\n\n\n\n  function handleDragEnd(e) {\n\n    if (isCloserToRightEdge(e)) {\n\n      onChange(true);\n\n    } else {\n\n      onChange(false);\n\n    }\n\n  }\n\n\n\n  // ...\n\n}",
        "function Parent() {\n\n  const [data, setData] = useState(null);\n\n  // ...\n\n  return <Child onFetched={setData} />;\n\n}\n\n\n\nfunction Child({ onFetched }) {\n\n  const data = useSomeAPI();\n\n  // üî¥ Avoid: Passing data to the parent in an Effect\n\n  useEffect(() => {\n\n    if (data) {\n\n      onFetched(data);\n\n    }\n\n  }, [onFetched, data]);\n\n  // ...\n\n}",
        "function Parent() {\n\n  const [data, setData] = useState(null);\n\n  // ...\n\n  return <Child onFetched={setData} />;\n\n}\n\n\n\nfunction Child({ onFetched }) {\n\n  const data = useSomeAPI();\n\n  // üî¥ Avoid: Passing data to the parent in an Effect\n\n  useEffect(() => {\n\n    if (data) {\n\n      onFetched(data);\n\n    }\n\n  }, [onFetched, data]);\n\n  // ...\n\n}",
        "function Parent() {\n\n  const data = useSomeAPI();\n\n  // ...\n\n  // ‚úÖ Good: Passing data down to the child\n\n  return <Child data={data} />;\n\n}\n\n\n\nfunction Child({ data }) {\n\n  // ...\n\n}",
        "function Parent() {\n\n  const data = useSomeAPI();\n\n  // ...\n\n  // ‚úÖ Good: Passing data down to the child\n\n  return <Child data={data} />;\n\n}\n\n\n\nfunction Child({ data }) {\n\n  // ...\n\n}",
        "function useOnlineStatus() {\n\n  // Not ideal: Manual store subscription in an Effect\n\n  const [isOnline, setIsOnline] = useState(true);\n\n  useEffect(() => {\n\n    function updateState() {\n\n      setIsOnline(navigator.onLine);\n\n    }\n\n\n\n    updateState();\n\n\n\n    window.addEventListener('online', updateState);\n\n    window.addEventListener('offline', updateState);\n\n    return () => {\n\n      window.removeEventListener('online', updateState);\n\n      window.removeEventListener('offline', updateState);\n\n    };\n\n  }, []);\n\n  return isOnline;\n\n}\n\n\n\nfunction ChatIndicator() {\n\n  const isOnline = useOnlineStatus();\n\n  // ...\n\n}",
        "function useOnlineStatus() {\n\n  // Not ideal: Manual store subscription in an Effect\n\n  const [isOnline, setIsOnline] = useState(true);\n\n  useEffect(() => {\n\n    function updateState() {\n\n      setIsOnline(navigator.onLine);\n\n    }\n\n\n\n    updateState();\n\n\n\n    window.addEventListener('online', updateState);\n\n    window.addEventListener('offline', updateState);\n\n    return () => {\n\n      window.removeEventListener('online', updateState);\n\n      window.removeEventListener('offline', updateState);\n\n    };\n\n  }, []);\n\n  return isOnline;\n\n}\n\n\n\nfunction ChatIndicator() {\n\n  const isOnline = useOnlineStatus();\n\n  // ...\n\n}",
        "navigator.onLine",
        "useSyncExternalStore",
        "function subscribe(callback) {\n\n  window.addEventListener('online', callback);\n\n  window.addEventListener('offline', callback);\n\n  return () => {\n\n    window.removeEventListener('online', callback);\n\n    window.removeEventListener('offline', callback);\n\n  };\n\n}\n\n\n\nfunction useOnlineStatus() {\n\n  // ‚úÖ Good: Subscribing to an external store with a built-in Hook\n\n  return useSyncExternalStore(\n\n    subscribe, // React won't resubscribe for as long as you pass the same function\n\n    () => navigator.onLine, // How to get the value on the client\n\n    () => true // How to get the value on the server\n\n  );\n\n}\n\n\n\nfunction ChatIndicator() {\n\n  const isOnline = useOnlineStatus();\n\n  // ...\n\n}",
        "function subscribe(callback) {\n\n  window.addEventListener('online', callback);\n\n  window.addEventListener('offline', callback);\n\n  return () => {\n\n    window.removeEventListener('online', callback);\n\n    window.removeEventListener('offline', callback);\n\n  };\n\n}\n\n\n\nfunction useOnlineStatus() {\n\n  // ‚úÖ Good: Subscribing to an external store with a built-in Hook\n\n  return useSyncExternalStore(\n\n    subscribe, // React won't resubscribe for as long as you pass the same function\n\n    () => navigator.onLine, // How to get the value on the client\n\n    () => true // How to get the value on the server\n\n  );\n\n}\n\n\n\nfunction ChatIndicator() {\n\n  const isOnline = useOnlineStatus();\n\n  // ...\n\n}",
        "useOnlineStatus()",
        "function SearchResults({ query }) {\n\n  const [results, setResults] = useState([]);\n\n  const [page, setPage] = useState(1);\n\n\n\n  useEffect(() => {\n\n    // üî¥ Avoid: Fetching without cleanup logic\n\n    fetchResults(query, page).then(json => {\n\n      setResults(json);\n\n    });\n\n  }, [query, page]);\n\n\n\n  function handleNextPageClick() {\n\n    setPage(page + 1);\n\n  }\n\n  // ...\n\n}",
        "function SearchResults({ query }) {\n\n  const [results, setResults] = useState([]);\n\n  const [page, setPage] = useState(1);\n\n\n\n  useEffect(() => {\n\n    // üî¥ Avoid: Fetching without cleanup logic\n\n    fetchResults(query, page).then(json => {\n\n      setResults(json);\n\n    });\n\n  }, [query, page]);\n\n\n\n  function handleNextPageClick() {\n\n    setPage(page + 1);\n\n  }\n\n  // ...\n\n}",
        "setResults()",
        "function SearchResults({ query }) {\n\n  const [results, setResults] = useState([]);\n\n  const [page, setPage] = useState(1);\n\n  useEffect(() => {\n\n    let ignore = false;\n\n    fetchResults(query, page).then(json => {\n\n      if (!ignore) {\n\n        setResults(json);\n\n      }\n\n    });\n\n    return () => {\n\n      ignore = true;\n\n    };\n\n  }, [query, page]);\n\n\n\n  function handleNextPageClick() {\n\n    setPage(page + 1);\n\n  }\n\n  // ...\n\n}",
        "function SearchResults({ query }) {\n\n  const [results, setResults] = useState([]);\n\n  const [page, setPage] = useState(1);\n\n  useEffect(() => {\n\n    let ignore = false;\n\n    fetchResults(query, page).then(json => {\n\n      if (!ignore) {\n\n        setResults(json);\n\n      }\n\n    });\n\n    return () => {\n\n      ignore = true;\n\n    };\n\n  }, [query, page]);\n\n\n\n  function handleNextPageClick() {\n\n    setPage(page + 1);\n\n  }\n\n  // ...\n\n}",
        "function SearchResults({ query }) {\n\n  const [page, setPage] = useState(1);\n\n  const params = new URLSearchParams({ query, page });\n\n  const results = useData(`/api/search?${params}`);\n\n\n\n  function handleNextPageClick() {\n\n    setPage(page + 1);\n\n  }\n\n  // ...\n\n}\n\n\n\nfunction useData(url) {\n\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n\n    let ignore = false;\n\n    fetch(url)\n\n      .then(response => response.json())\n\n      .then(json => {\n\n        if (!ignore) {\n\n          setData(json);\n\n        }\n\n      });\n\n    return () => {\n\n      ignore = true;\n\n    };\n\n  }, [url]);\n\n  return data;\n\n}",
        "function SearchResults({ query }) {\n\n  const [page, setPage] = useState(1);\n\n  const params = new URLSearchParams({ query, page });\n\n  const results = useData(`/api/search?${params}`);\n\n\n\n  function handleNextPageClick() {\n\n    setPage(page + 1);\n\n  }\n\n  // ...\n\n}\n\n\n\nfunction useData(url) {\n\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n\n    let ignore = false;\n\n    fetch(url)\n\n      .then(response => response.json())\n\n      .then(json => {\n\n        if (!ignore) {\n\n          setData(json);\n\n        }\n\n      });\n\n    return () => {\n\n      ignore = true;\n\n    };\n\n  }, [url]);\n\n  return data;\n\n}",
        "import { useState, useEffect } from 'react';\nimport { initialTodos, createTodo } from './todos.js';\n\nexport default function TodoList() {\n  const [todos, setTodos] = useState(initialTodos);\n  const [showActive, setShowActive] = useState(false);\n  const [activeTodos, setActiveTodos] = useState([]);\n  const [visibleTodos, setVisibleTodos] = useState([]);\n  const [footer, setFooter] = useState(null);\n\n  useEffect(() => {\n    setActiveTodos(todos.filter(todo => !todo.completed));\n  }, [todos]);\n\n  useEffect(() => {\n    setVisibleTodos(showActive ? activeTodos : todos);\n  }, [showActive, todos, activeTodos]);\n\n  useEffect(() => {\n    setFooter(\n      <footer>\n        {activeTodos.length} todos left\n      </footer>\n    );\n  }, [activeTodos]);\n\n  return (\n    <>\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={showActive}\n          onChange={e => setShowActive(e.target.checked)}\n        />\n        Show only active todos\n      </label>\n      <NewTodo onAdd={newTodo => setTodos([...todos, newTodo])} />\n      <ul>\n        {visibleTodos.map(todo => (\n          <li key={todo.id}>\n            {todo.completed ? <s>{todo.text}</s> : todo.text}\n          </li>\n        ))}\n      </ul>\n      {footer}\n    </>\n  );\n}\n\nfunction NewTodo({ onAdd }) {\n  const [text, setText] = useState('');\n\n  function handleAddClick() {\n    setText('');\n    onAdd(createTodo(text));\n  }\n\n  return (\n    <>\n      <input value={text} onChange={e => setText(e.target.value)} />\n      <button onClick={handleAddClick}>\n        Add\n      </button>\n    </>\n  );\n}"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 5449
    },
    {
      "url": "https://react.dev/learn/importing-and-exporting-components",
      "title": "Importing and Exporting Components",
      "breadcrumb": [],
      "section_path": [
        "Describing the UI",
        "Importing and Exporting Components"
      ],
      "headings": {
        "h1": [
          "Importing and Exporting Components"
        ],
        "h2": [
          "The root component file",
          "Exporting and importing a component",
          "Exporting and importing multiple components from the same file",
          "Recap",
          "Try out some challenges"
        ],
        "h3": [
          "You will learn",
          "Note",
          "Note"
        ],
        "h4": [
          "Default vs named exports",
          "Challenge 1 of 1: Split the components further"
        ],
        "h5": [
          "DEEP DIVE"
        ]
      },
      "text_content": "LEARN REACT\nDESCRIBING THE UI\nImporting and Exporting Components\n\nThe magic of components lies in their reusability: you can create components that are composed of other components. But as you nest more and more components, it often makes sense to start splitting them into different files. This lets you keep your files easy to scan and reuse components in more places.\n\nYou will learn\nWhat a root component file is\nHow to import and export a component\nWhen to use default and named imports and exports\nHow to import and export multiple components from one file\nHow to split components into multiple files\nThe root component file \n\nIn Your First Component, you made a Profile component and a Gallery component that renders it:\n\nApp.js\nDownload\nReload\nClear\nFork\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nfunction Profile() {\n return (\n <img\n src=\"https://i.imgur.com/MK3eW3As.jpg\"\n alt=\"Katherine Johnson\"\n />\n );\n}\n\nexport default function Gallery() {\n return (\n <section>\n <h1>Amazing scientists</h1>\n <Profile />\n <Profile />\n <Profile />\n </section>\n );\n}\n\nShow more\n\nThese currently live in a root component file, named App.js in this example. Depending on your setup, your root component could be in another file, though. If you use a framework with file-based routing, such as Next.js, your root component will be different for every page.\n\nExporting and importing a component \n\nWhat if you want to change the landing screen in the future and put a list of science books there? Or place all the profiles somewhere else? It makes sense to move Gallery and Profile out of the root component file. This will make them more modular and reusable in other files. You can move a component in three steps:\n\nMake a new JS file to put the components in.\nExport your function component from that file (using either default or named exports).\nImport it in the file where you‚Äôll use the component (using the corresponding technique for importing default or named exports).\n\nHere both Profile and Gallery have been moved out of App.js into a new file called Gallery.js. Now you can change App.js to import Gallery from Gallery.js:\n\nApp.js\nGallery.js\nReload\nClear\nFork\nimport Gallery from './Gallery.js';\n\nexport default function App() {\n return (\n <Gallery />\n );\n}\n\nNotice how this example is broken down into two component files now:\n\nGallery.js:\nDefines the Profile component which is only used within the same file and is not exported.\nExports the Gallery component as a default export.\nApp.js:\nImports Gallery as a default import from Gallery.js.\nExports the root App component as a default export.\nNote\n\nYou may encounter files that leave off the .js file extension like so:\n\nimport Gallery from './Gallery';\n\nEither './Gallery.js' or './Gallery' will work with React, though the former is closer to how native ES Modules work.\n\nDEEP DIVE\nDefault vs named exports \nShow Details\nExporting and importing multiple components from the same file \n\nWhat if you want to show just one Profile instead of a gallery? You can export the Profile component, too. But Gallery.js already has a default export, and you can‚Äôt have two default exports. You could create a new file with a default export, or you could add a named export for Profile. A file can only have one default export, but it can have numerous named exports!\n\nNote\n\nTo reduce the potential confusion between default and named exports, some teams choose to only stick to one style (default or named), or avoid mixing them in a single file. Do what works best for you!\n\nFirst, export Profile from Gallery.js using a named export (no default keyword):\n\nexport function Profile() {\n\n // ...\n\n}\n\nThen, import Profile from Gallery.js to App.js using a named import (with the curly braces):\n\nimport { Profile } from './Gallery.js';\n\nFinally, render <Profile /> from the App component:\n\nexport default function App() {\n\n return <Profile />;\n\n}\n\nNow Gallery.js contains two exports: a default Gallery export, and a named Profile export. App.js imports both of them. Try editing <Profile /> to <Gallery /> and back in this example:\n\nApp.js\nGallery.js\nReload\nClear\nFork\nimport Gallery from './Gallery.js';\nimport { Profile } from './Gallery.js';\n\nexport default function App() {\n return (\n <Profile />\n );\n}\n\nNow you‚Äôre using a mix of default and named exports:\n\nGallery.js:\nExports the Profile component as a named export called Profile.\nExports the Gallery component as a default export.\nApp.js:\nImports Profile as a named import called Profile from Gallery.js.\nImports Gallery as a default import from Gallery.js.\nExports the root App component as a default export.\nRecap\n\nOn this page you learned:\n\nWhat a root component file is\nHow to import and export a component\nWhen and how to use default and named imports and exports\nHow to export multiple components from the same file\nTry out some challenges\nChallenge 1 of 1: Split the components further \n\nCurrently, Gallery.js exports both Profile and Gallery, which is a bit confusing.\n\nMove the Profile component to its own Profile.js, and then change the App component to render both <Profile /> and <Gallery /> one after another.\n\nYou may use either a default or a named export for Profile, but make sure that you use the corresponding import syntax in both App.js and Gallery.js! You can refer to the table from the deep dive above:\n\nSyntax\tExport statement\tImport statement\nDefault\texport default function Button() {}\timport Button from './Button.js';\nNamed\texport function Button() {}\timport { Button } from './Button.js';\nApp.js\nGallery.js\nProfile.js\nReload\nClear\nFork\n// Move me to Profile.js!\nexport function Profile() {\n return (\n <img\n src=\"https://i.imgur.com/QIrZWGIs.jpg\"\n alt=\"Alan L. Hart\"\n />\n );\n}\n\nexport default function Gallery() {\n return (\n <section>\n <h1>Amazing scientists</h1>\n <Profile />\n <Profile />\n <Profile />\n </section>\n );\n}\n\nShow more\n\nAfter you get it working with one kind of exports, make it work with the other kind.\n\nShow hint\nShow solution\nPREVIOUS\nYour First Component\nNEXT\nWriting Markup with JSX",
      "tables": [
        {
          "headers": [
            "",
            "",
            ""
          ],
          "rows": [
            [
              "",
              "",
              ""
            ],
            [
              "",
              "",
              ""
            ]
          ]
        },
        {
          "headers": [
            "Syntax",
            "Export statement",
            "Import statement"
          ],
          "rows": [
            [
              "Default",
              "export default function Button() {}",
              "import Button from './Button.js';"
            ],
            [
              "Named",
              "export function Button() {}",
              "import { Button } from './Button.js';"
            ]
          ]
        }
      ],
      "code_blocks": [
        "import Gallery from './Gallery.js';\n\nexport default function App() {\n  return (\n    <Gallery />\n  );\n}",
        "import Gallery from './Gallery';",
        "import Gallery from './Gallery';",
        "'./Gallery.js'",
        "'./Gallery'",
        "export function Profile() {\n\n  // ...\n\n}",
        "export function Profile() {\n\n  // ...\n\n}",
        "import { Profile } from './Gallery.js';",
        "import { Profile } from './Gallery.js';",
        "<Profile />",
        "export default function App() {\n\n  return <Profile />;\n\n}",
        "export default function App() {\n\n  return <Profile />;\n\n}",
        "<Profile />",
        "<Gallery />",
        "import Gallery from './Gallery.js';\nimport { Profile } from './Gallery.js';\n\nexport default function App() {\n  return (\n    <Profile />\n  );\n}",
        "<Profile />",
        "<Gallery />",
        "export default function Button() {}",
        "import Button from './Button.js';",
        "export function Button() {}",
        "import { Button } from './Button.js';",
        "// Move me to Profile.js!\nexport function Profile() {\n  return (\n    <img\n      src=\"https://i.imgur.com/QIrZWGIs.jpg\"\n      alt=\"Alan L. Hart\"\n    />\n  );\n}\n\nexport default function Gallery() {\n  return (\n    <section>\n      <h1>Amazing scientists</h1>\n      <Profile />\n      <Profile />\n      <Profile />\n    </section>\n  );\n}"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 995
    },
    {
      "url": "https://react.dev/learn/extracting-state-logic-into-a-reducer",
      "title": "Extracting State Logic into a Reducer",
      "breadcrumb": [],
      "section_path": [
        "Managing State",
        "Extracting State Logic into a Reducer"
      ],
      "headings": {
        "h1": [
          "Extracting State Logic into a Reducer"
        ],
        "h2": [
          "Consolidate state logic with a reducer",
          "Comparing useState and useReducer",
          "Writing reducers well",
          "Writing concise reducers with Immer",
          "Recap",
          "Try out some challenges"
        ],
        "h3": [
          "You will learn",
          "Step 1: Move from setting state to dispatching actions",
          "Note",
          "Step 2: Write a reducer function",
          "Note",
          "Step 3: Use the reducer from your component"
        ],
        "h4": [
          "Why are reducers called this way?",
          "Challenge 1 of 4: Dispatch actions from event handlers"
        ],
        "h5": [
          "DEEP DIVE"
        ]
      },
      "text_content": "LEARN REACT\nMANAGING STATE\nExtracting State Logic into a Reducer\n\nComponents with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called a reducer.\n\nYou will learn\nWhat a reducer function is\nHow to refactor useState to useReducer\nWhen to use a reducer\nHow to write one well\nConsolidate state logic with a reducer \n\nAs your components grow in complexity, it can get harder to see at a glance all the different ways in which a component‚Äôs state gets updated. For example, the TaskApp component below holds an array of tasks in state and uses three different event handlers to add, remove, and edit tasks:\n\nApp.js\nReload\nClear\nFork\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\nimport { useState } from 'react';\nimport AddTask from './AddTask.js';\nimport TaskList from './TaskList.js';\n\nexport default function TaskApp() {\n const [tasks, setTasks] = useState(initialTasks);\n\n function handleAddTask(text) {\n setTasks([\n ...tasks,\n {\n id: nextId++,\n text: text,\n done: false,\n },\n ]);\n }\n\n function handleChangeTask(task) {\n setTasks(\n tasks.map((t) => {\n if (t.id === task.id) {\n return task;\n } else {\n return t;\n }\n })\n );\n }\n\n function handleDeleteTask(taskId) {\n setTasks(tasks.filter((t) => t.id !== taskId));\n }\n\n return (\n <>\nShow more\n\nEach of its event handlers calls setTasks in order to update the state. As this component grows, so does the amount of state logic sprinkled throughout it. To reduce this complexity and keep all your logic in one easy-to-access place, you can move that state logic into a single function outside your component, called a ‚Äúreducer‚Äù.\n\nReducers are a different way to handle state. You can migrate from useState to useReducer in three steps:\n\nMove from setting state to dispatching actions.\nWrite a reducer function.\nUse the reducer from your component.\nStep 1: Move from setting state to dispatching actions \n\nYour event handlers currently specify what to do by setting state:\n\nfunction handleAddTask(text) {\n\n setTasks([\n\n ...tasks,\n\n {\n\n id: nextId++,\n\n text: text,\n\n done: false,\n\n },\n\n ]);\n\n}\n\nfunction handleChangeTask(task) {\n\n setTasks(\n\n tasks.map((t) => {\n\n if (t.id === task.id) {\n\n return task;\n\n } else {\n\n return t;\n\n }\n\n })\n\n );\n\n}\n\nfunction handleDeleteTask(taskId) {\n\n setTasks(tasks.filter((t) => t.id !== taskId));\n\n}\n\nRemove all the state setting logic. What you are left with are three event handlers:\n\nhandleAddTask(text) is called when the user presses ‚ÄúAdd‚Äù.\nhandleChangeTask(task) is called when the user toggles a task or presses ‚ÄúSave‚Äù.\nhandleDeleteTask(taskId) is called when the user presses ‚ÄúDelete‚Äù.\n\nManaging state with reducers is slightly different from directly setting state. Instead of telling React ‚Äúwhat to do‚Äù by setting state, you specify ‚Äúwhat the user just did‚Äù by dispatching ‚Äúactions‚Äù from your event handlers. (The state update logic will live elsewhere!) So instead of ‚Äúsetting tasks‚Äù via an event handler, you‚Äôre dispatching an ‚Äúadded/changed/deleted a task‚Äù action. This is more descriptive of the user‚Äôs intent.\n\nfunction handleAddTask(text) {\n\n dispatch({\n\n type: 'added',\n\n id: nextId++,\n\n text: text,\n\n });\n\n}\n\nfunction handleChangeTask(task) {\n\n dispatch({\n\n type: 'changed',\n\n task: task,\n\n });\n\n}\n\nfunction handleDeleteTask(taskId) {\n\n dispatch({\n\n type: 'deleted',\n\n id: taskId,\n\n });\n\n}\n\nThe object you pass to dispatch is called an ‚Äúaction‚Äù:\n\nfunction handleDeleteTask(taskId) {\n\n dispatch(\n\n // \"action\" object:\n\n {\n\n type: 'deleted',\n\n id: taskId,\n\n }\n\n );\n\n}\n\nIt is a regular JavaScript object. You decide what to put in it, but generally it should contain the minimal information about what happened. (You will add the dispatch function itself in a later step.)\n\nNote\n\nAn action object can have any shape.\n\nBy convention, it is common to give it a string type that describes what happened, and pass any additional information in other fields. The type is specific to a component, so in this example either 'added' or 'added_task' would be fine. Choose a name that says what happened!\n\ndispatch({\n\n // specific to component\n\n type: 'what_happened',\n\n // other fields go here\n\n});\nStep 2: Write a reducer function \n\nA reducer function is where you will put your state logic. It takes two arguments, the current state and the action object, and it returns the next state:\n\nfunction yourReducer(state, action) {\n\n // return next state for React to set\n\n}\n\nReact will set the state to what you return from the reducer.\n\nTo move your state setting logic from your event handlers to a reducer function in this example, you will:\n\nDeclare the current state (tasks) as the first argument.\nDeclare the action object as the second argument.\nReturn the next state from the reducer (which React will set the state to).\n\nHere is all the state setting logic migrated to a reducer function:\n\nfunction tasksReducer(tasks, action) {\n\n if (action.type === 'added') {\n\n return [\n\n ...tasks,\n\n {\n\n id: action.id,\n\n text: action.text,\n\n done: false,\n\n },\n\n ];\n\n } else if (action.type === 'changed') {\n\n return tasks.map((t) => {\n\n if (t.id === action.task.id) {\n\n return action.task;\n\n } else {\n\n return t;\n\n }\n\n });\n\n } else if (action.type === 'deleted') {\n\n return tasks.filter((t) => t.id !== action.id);\n\n } else {\n\n throw Error('Unknown action: ' + action.type);\n\n }\n\n}\n\nBecause the reducer function takes state (tasks) as an argument, you can declare it outside of your component. This decreases the indentation level and can make your code easier to read.\n\nNote\n\nThe code above uses if/else statements, but it‚Äôs a convention to use switch statements inside reducers. The result is the same, but it can be easier to read switch statements at a glance.\n\nWe‚Äôll be using them throughout the rest of this documentation like so:\n\nfunction tasksReducer(tasks, action) {\n\n switch (action.type) {\n\n case 'added': {\n\n return [\n\n ...tasks,\n\n {\n\n id: action.id,\n\n text: action.text,\n\n done: false,\n\n },\n\n ];\n\n }\n\n case 'changed': {\n\n return tasks.map((t) => {\n\n if (t.id === action.task.id) {\n\n return action.task;\n\n } else {\n\n return t;\n\n }\n\n });\n\n }\n\n case 'deleted': {\n\n return tasks.filter((t) => t.id !== action.id);\n\n }\n\n default: {\n\n throw Error('Unknown action: ' + action.type);\n\n }\n\n }\n\n}\n\nWe recommend wrapping each case block into the { and } curly braces so that variables declared inside of different cases don‚Äôt clash with each other. Also, a case should usually end with a return. If you forget to return, the code will ‚Äúfall through‚Äù to the next case, which can lead to mistakes!\n\nIf you‚Äôre not yet comfortable with switch statements, using if/else is completely fine.\n\nDEEP DIVE\nWhy are reducers called this way? \nShow Details\nStep 3: Use the reducer from your component \n\nFinally, you need to hook up the tasksReducer to your component. Import the useReducer Hook from React:\n\nimport { useReducer } from 'react';\n\nThen you can replace useState:\n\nconst [tasks, setTasks] = useState(initialTasks);\n\nwith useReducer like so:\n\nconst [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\nThe useReducer Hook is similar to useState‚Äîyou must pass it an initial state and it returns a stateful value and a way to set state (in this case, the dispatch function). But it‚Äôs a little different.\n\nThe useReducer Hook takes two arguments:\n\nA reducer function\nAn initial state\n\nAnd it returns:\n\nA stateful value\nA dispatch function (to ‚Äúdispatch‚Äù user actions to the reducer)\n\nNow it‚Äôs fully wired up! Here, the reducer is declared at the bottom of the component file:\n\nApp.js\nReload\nClear\nFork\nimport { useReducer } from 'react';\nimport AddTask from './AddTask.js';\nimport TaskList from './TaskList.js';\n\nexport default function TaskApp() {\n const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\n function handleAddTask(text) {\n dispatch({\n type: 'added',\n id: nextId++,\n text: text,\n });\n }\n\n function handleChangeTask(task) {\n dispatch({\n type: 'changed',\n task: task,\n });\n }\n\n function handleDeleteTask(taskId) {\n dispatch({\n type: 'deleted',\n id: taskId,\n });\n }\n\n return (\n <>\n <h1>Prague itinerary</h1>\n <AddTask onAddTask={handleAddTask} />\n <TaskList\n tasks={tasks}\n onChangeTask={handleChangeTask}\n onDeleteTask={handleDeleteTask}\n />\n </>\n );\n}\n\nfunction tasksReducer(tasks, action) {\n switch (action.type) {\n case 'added': {\n return [\n ...tasks,\n {\n id: action.id,\n text: action.text,\n done: false,\n },\n ];\n }\n case 'changed': {\n return tasks.map((t) => {\n if (t.id === action.task.id) {\n return action.task;\n } else {\n return t;\n }\n });\n }\n case 'deleted': {\n return tasks.filter((t) => t.id !== action.id);\n }\n default: {\n throw Error('Unknown action: ' + action.type);\n }\n }\n}\n\nlet nextId = 3;\nconst initialTasks = [\n {id: 0, text: 'Visit Kafka Museum', done: true},\n {id: 1, text: 'Watch a puppet show', done: false},\n {id: 2, text: 'Lennon Wall pic', done: false},\n];\n\nShow more\n\nIf you want, you can even move the reducer to a different file:\n\nApp.js\ntasksReducer.js\nReload\nClear\nFork\nimport { useReducer } from 'react';\nimport AddTask from './AddTask.js';\nimport TaskList from './TaskList.js';\nimport tasksReducer from './tasksReducer.js';\n\nexport default function TaskApp() {\n const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\n function handleAddTask(text) {\n dispatch({\n type: 'added',\n id: nextId++,\n text: text,\n });\n }\n\n function handleChangeTask(task) {\n dispatch({\n type: 'changed',\n task: task,\n });\n }\n\n function handleDeleteTask(taskId) {\n dispatch({\n type: 'deleted',\n id: taskId,\n });\n }\n\n return (\n <>\n <h1>Prague itinerary</h1>\n <AddTask onAddTask={handleAddTask} />\n <TaskList\n tasks={tasks}\n onChangeTask={handleChangeTask}\n onDeleteTask={handleDeleteTask}\n />\n </>\n );\n}\n\nlet nextId = 3;\nconst initialTasks = [\n {id: 0, text: 'Visit Kafka Museum', done: true},\n {id: 1, text: 'Watch a puppet show', done: false},\n {id: 2, text: 'Lennon Wall pic', done: false},\n];\n\nShow more\n\nComponent logic can be easier to read when you separate concerns like this. Now the event handlers only specify what happened by dispatching actions, and the reducer function determines how the state updates in response to them.\n\nComparing useState and useReducer \n\nReducers are not without downsides! Here‚Äôs a few ways you can compare them:\n\nCode size: Generally, with useState you have to write less code upfront. With useReducer, you have to write both a reducer function and dispatch actions. However, useReducer can help cut down on the code if many event handlers modify state in a similar way.\nReadability: useState is very easy to read when the state updates are simple. When they get more complex, they can bloat your component‚Äôs code and make it difficult to scan. In this case, useReducer lets you cleanly separate the how of update logic from the what happened of event handlers.\nDebugging: When you have a bug with useState, it can be difficult to tell where the state was set incorrectly, and why. With useReducer, you can add a console log into your reducer to see every state update, and why it happened (due to which action). If each action is correct, you‚Äôll know that the mistake is in the reducer logic itself. However, you have to step through more code than with useState.\nTesting: A reducer is a pure function that doesn‚Äôt depend on your component. This means that you can export and test it separately in isolation. While generally it‚Äôs best to test components in a more realistic environment, for complex state update logic it can be useful to assert that your reducer returns a particular state for a particular initial state and action.\nPersonal preference: Some people like reducers, others don‚Äôt. That‚Äôs okay. It‚Äôs a matter of preference. You can always convert between useState and useReducer back and forth: they are equivalent!\n\nWe recommend using a reducer if you often encounter bugs due to incorrect state updates in some component, and want to introduce more structure to its code. You don‚Äôt have to use reducers for everything: feel free to mix and match! You can even useState and useReducer in the same component.\n\nWriting reducers well \n\nKeep these two tips in mind when writing reducers:\n\nReducers must be pure. Similar to state updater functions, reducers run during rendering! (Actions are queued until the next render.) This means that reducers must be pure‚Äîsame inputs always result in the same output. They should not send requests, schedule timeouts, or perform any side effects (operations that impact things outside the component). They should update objects and arrays without mutations.\nEach action describes a single user interaction, even if that leads to multiple changes in the data. For example, if a user presses ‚ÄúReset‚Äù on a form with five fields managed by a reducer, it makes more sense to dispatch one reset_form action rather than five separate set_field actions. If you log every action in a reducer, that log should be clear enough for you to reconstruct what interactions or responses happened in what order. This helps with debugging!\nWriting concise reducers with Immer \n\nJust like with updating objects and arrays in regular state, you can use the Immer library to make reducers more concise. Here, useImmerReducer lets you mutate the state with push or arr[i] = assignment:\n\npackage.json\nApp.js\nReload\nClear\nFork\n{\n \"dependencies\": {\n \"immer\": \"1.7.3\",\n \"react\": \"latest\",\n \"react-dom\": \"latest\",\n \"react-scripts\": \"latest\",\n \"use-immer\": \"0.5.1\"\n },\n \"scripts\": {\n \"start\": \"react-scripts start\",\n \"build\": \"react-scripts build\",\n \"test\": \"react-scripts test --env=jsdom\",\n \"eject\": \"react-scripts eject\"\n },\n \"devDependencies\": {}\n}\n\nReducers must be pure, so they shouldn‚Äôt mutate state. But Immer provides you with a special draft object which is safe to mutate. Under the hood, Immer will create a copy of your state with the changes you made to the draft. This is why reducers managed by useImmerReducer can mutate their first argument and don‚Äôt need to return state.\n\nRecap\nTo convert from useState to useReducer:\nDispatch actions from event handlers.\nWrite a reducer function that returns the next state for a given state and action.\nReplace useState with useReducer.\nReducers require you to write a bit more code, but they help with debugging and testing.\nReducers must be pure.\nEach action describes a single user interaction.\nUse Immer if you want to write reducers in a mutating style.\nTry out some challenges\n1. Dispatch actions from event handlers\n2. Clear the input on sending a message\n3. Restore input values when switching between tabs\n4. Implement useReducer from scratch\nChallenge 1 of 4: Dispatch actions from event handlers \n\nCurrently, the event handlers in ContactList.js and Chat.js have // TODO comments. This is why typing into the input doesn‚Äôt work, and clicking on the buttons doesn‚Äôt change the selected recipient.\n\nReplace these two // TODOs with the code to dispatch the corresponding actions. To see the expected shape and the type of the actions, check the reducer in messengerReducer.js. The reducer is already written so you won‚Äôt need to change it. You only need to dispatch the actions in ContactList.js and Chat.js.\n\nApp.js\nmessengerReducer.js\nContactList.js\nChat.js\nReload\nClear\nFork\nimport { useReducer } from 'react';\nimport Chat from './Chat.js';\nimport ContactList from './ContactList.js';\nimport { initialState, messengerReducer } from './messengerReducer';\n\nexport default function Messenger() {\n const [state, dispatch] = useReducer(messengerReducer, initialState);\n const message = state.message;\n const contact = contacts.find((c) => c.id === state.selectedId);\n return (\n <div>\n <ContactList\n contacts={contacts}\n selectedId={state.selectedId}\n dispatch={dispatch}\n />\n <Chat\n key={contact.id}\n message={message}\n contact={contact}\n dispatch={dispatch}\n />\n </div>\n );\n}\n\nconst contacts = [\n {id: 0, name: 'Taylor', email: 'taylor@mail.com'},\n {id: 1, name: 'Alice', email: 'alice@mail.com'},\n {id: 2, name: 'Bob', email: 'bob@mail.com'},\n];\n\nShow more\nShow hint\nShow solution\nNext Challenge\nPREVIOUS\nPreserving and Resetting State\nNEXT\nPassing Data Deeply with Context",
      "tables": [],
      "code_blocks": [
        "function handleAddTask(text) {\n\n  setTasks([\n\n    ...tasks,\n\n    {\n\n      id: nextId++,\n\n      text: text,\n\n      done: false,\n\n    },\n\n  ]);\n\n}\n\n\n\nfunction handleChangeTask(task) {\n\n  setTasks(\n\n    tasks.map((t) => {\n\n      if (t.id === task.id) {\n\n        return task;\n\n      } else {\n\n        return t;\n\n      }\n\n    })\n\n  );\n\n}\n\n\n\nfunction handleDeleteTask(taskId) {\n\n  setTasks(tasks.filter((t) => t.id !== taskId));\n\n}",
        "function handleAddTask(text) {\n\n  setTasks([\n\n    ...tasks,\n\n    {\n\n      id: nextId++,\n\n      text: text,\n\n      done: false,\n\n    },\n\n  ]);\n\n}\n\n\n\nfunction handleChangeTask(task) {\n\n  setTasks(\n\n    tasks.map((t) => {\n\n      if (t.id === task.id) {\n\n        return task;\n\n      } else {\n\n        return t;\n\n      }\n\n    })\n\n  );\n\n}\n\n\n\nfunction handleDeleteTask(taskId) {\n\n  setTasks(tasks.filter((t) => t.id !== taskId));\n\n}",
        "handleAddTask(text)",
        "handleChangeTask(task)",
        "handleDeleteTask(taskId)",
        "function handleAddTask(text) {\n\n  dispatch({\n\n    type: 'added',\n\n    id: nextId++,\n\n    text: text,\n\n  });\n\n}\n\n\n\nfunction handleChangeTask(task) {\n\n  dispatch({\n\n    type: 'changed',\n\n    task: task,\n\n  });\n\n}\n\n\n\nfunction handleDeleteTask(taskId) {\n\n  dispatch({\n\n    type: 'deleted',\n\n    id: taskId,\n\n  });\n\n}",
        "function handleAddTask(text) {\n\n  dispatch({\n\n    type: 'added',\n\n    id: nextId++,\n\n    text: text,\n\n  });\n\n}\n\n\n\nfunction handleChangeTask(task) {\n\n  dispatch({\n\n    type: 'changed',\n\n    task: task,\n\n  });\n\n}\n\n\n\nfunction handleDeleteTask(taskId) {\n\n  dispatch({\n\n    type: 'deleted',\n\n    id: taskId,\n\n  });\n\n}",
        "function handleDeleteTask(taskId) {\n\n  dispatch(\n\n    // \"action\" object:\n\n    {\n\n      type: 'deleted',\n\n      id: taskId,\n\n    }\n\n  );\n\n}",
        "function handleDeleteTask(taskId) {\n\n  dispatch(\n\n    // \"action\" object:\n\n    {\n\n      type: 'deleted',\n\n      id: taskId,\n\n    }\n\n  );\n\n}",
        "'added_task'",
        "dispatch({\n\n  // specific to component\n\n  type: 'what_happened',\n\n  // other fields go here\n\n});",
        "dispatch({\n\n  // specific to component\n\n  type: 'what_happened',\n\n  // other fields go here\n\n});",
        "function yourReducer(state, action) {\n\n  // return next state for React to set\n\n}",
        "function yourReducer(state, action) {\n\n  // return next state for React to set\n\n}",
        "function tasksReducer(tasks, action) {\n\n  if (action.type === 'added') {\n\n    return [\n\n      ...tasks,\n\n      {\n\n        id: action.id,\n\n        text: action.text,\n\n        done: false,\n\n      },\n\n    ];\n\n  } else if (action.type === 'changed') {\n\n    return tasks.map((t) => {\n\n      if (t.id === action.task.id) {\n\n        return action.task;\n\n      } else {\n\n        return t;\n\n      }\n\n    });\n\n  } else if (action.type === 'deleted') {\n\n    return tasks.filter((t) => t.id !== action.id);\n\n  } else {\n\n    throw Error('Unknown action: ' + action.type);\n\n  }\n\n}",
        "function tasksReducer(tasks, action) {\n\n  if (action.type === 'added') {\n\n    return [\n\n      ...tasks,\n\n      {\n\n        id: action.id,\n\n        text: action.text,\n\n        done: false,\n\n      },\n\n    ];\n\n  } else if (action.type === 'changed') {\n\n    return tasks.map((t) => {\n\n      if (t.id === action.task.id) {\n\n        return action.task;\n\n      } else {\n\n        return t;\n\n      }\n\n    });\n\n  } else if (action.type === 'deleted') {\n\n    return tasks.filter((t) => t.id !== action.id);\n\n  } else {\n\n    throw Error('Unknown action: ' + action.type);\n\n  }\n\n}",
        "function tasksReducer(tasks, action) {\n\n  switch (action.type) {\n\n    case 'added': {\n\n      return [\n\n        ...tasks,\n\n        {\n\n          id: action.id,\n\n          text: action.text,\n\n          done: false,\n\n        },\n\n      ];\n\n    }\n\n    case 'changed': {\n\n      return tasks.map((t) => {\n\n        if (t.id === action.task.id) {\n\n          return action.task;\n\n        } else {\n\n          return t;\n\n        }\n\n      });\n\n    }\n\n    case 'deleted': {\n\n      return tasks.filter((t) => t.id !== action.id);\n\n    }\n\n    default: {\n\n      throw Error('Unknown action: ' + action.type);\n\n    }\n\n  }\n\n}",
        "function tasksReducer(tasks, action) {\n\n  switch (action.type) {\n\n    case 'added': {\n\n      return [\n\n        ...tasks,\n\n        {\n\n          id: action.id,\n\n          text: action.text,\n\n          done: false,\n\n        },\n\n      ];\n\n    }\n\n    case 'changed': {\n\n      return tasks.map((t) => {\n\n        if (t.id === action.task.id) {\n\n          return action.task;\n\n        } else {\n\n          return t;\n\n        }\n\n      });\n\n    }\n\n    case 'deleted': {\n\n      return tasks.filter((t) => t.id !== action.id);\n\n    }\n\n    default: {\n\n      throw Error('Unknown action: ' + action.type);\n\n    }\n\n  }\n\n}",
        "tasksReducer",
        "import { useReducer } from 'react';",
        "import { useReducer } from 'react';",
        "const [tasks, setTasks] = useState(initialTasks);",
        "const [tasks, setTasks] = useState(initialTasks);",
        "const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);",
        "const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);",
        "import { useReducer } from 'react';\nimport AddTask from './AddTask.js';\nimport TaskList from './TaskList.js';\n\nexport default function TaskApp() {\n  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\n  function handleAddTask(text) {\n    dispatch({\n      type: 'added',\n      id: nextId++,\n      text: text,\n    });\n  }\n\n  function handleChangeTask(task) {\n    dispatch({\n      type: 'changed',\n      task: task,\n    });\n  }\n\n  function handleDeleteTask(taskId) {\n    dispatch({\n      type: 'deleted',\n      id: taskId,\n    });\n  }\n\n  return (\n    <>\n      <h1>Prague itinerary</h1>\n      <AddTask onAddTask={handleAddTask} />\n      <TaskList\n        tasks={tasks}\n        onChangeTask={handleChangeTask}\n        onDeleteTask={handleDeleteTask}\n      />\n    </>\n  );\n}\n\nfunction tasksReducer(tasks, action) {\n  switch (action.type) {\n    case 'added': {\n      return [\n        ...tasks,\n        {\n          id: action.id,\n          text: action.text,\n          done: false,\n        },\n      ];\n    }\n    case 'changed': {\n      return tasks.map((t) => {\n        if (t.id === action.task.id) {\n          return action.task;\n        } else {\n          return t;\n        }\n      });\n    }\n    case 'deleted': {\n      return tasks.filter((t) => t.id !== action.id);\n    }\n    default: {\n      throw Error('Unknown action: ' + action.type);\n    }\n  }\n}\n\nlet nextId = 3;\nconst initialTasks = [\n  {id: 0, text: 'Visit Kafka Museum', done: true},\n  {id: 1, text: 'Watch a puppet show', done: false},\n  {id: 2, text: 'Lennon Wall pic', done: false},\n];",
        "import { useReducer } from 'react';\nimport AddTask from './AddTask.js';\nimport TaskList from './TaskList.js';\nimport tasksReducer from './tasksReducer.js';\n\nexport default function TaskApp() {\n  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\n  function handleAddTask(text) {\n    dispatch({\n      type: 'added',\n      id: nextId++,\n      text: text,\n    });\n  }\n\n  function handleChangeTask(task) {\n    dispatch({\n      type: 'changed',\n      task: task,\n    });\n  }\n\n  function handleDeleteTask(taskId) {\n    dispatch({\n      type: 'deleted',\n      id: taskId,\n    });\n  }\n\n  return (\n    <>\n      <h1>Prague itinerary</h1>\n      <AddTask onAddTask={handleAddTask} />\n      <TaskList\n        tasks={tasks}\n        onChangeTask={handleChangeTask}\n        onDeleteTask={handleDeleteTask}\n      />\n    </>\n  );\n}\n\nlet nextId = 3;\nconst initialTasks = [\n  {id: 0, text: 'Visit Kafka Museum', done: true},\n  {id: 1, text: 'Watch a puppet show', done: false},\n  {id: 2, text: 'Lennon Wall pic', done: false},\n];",
        "useImmerReducer",
        "{\n  \"dependencies\": {\n    \"immer\": \"1.7.3\",\n    \"react\": \"latest\",\n    \"react-dom\": \"latest\",\n    \"react-scripts\": \"latest\",\n    \"use-immer\": \"0.5.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test --env=jsdom\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"devDependencies\": {}\n}",
        "useImmerReducer",
        "ContactList.js",
        "messengerReducer.js",
        "ContactList.js",
        "import { useReducer } from 'react';\nimport Chat from './Chat.js';\nimport ContactList from './ContactList.js';\nimport { initialState, messengerReducer } from './messengerReducer';\n\nexport default function Messenger() {\n  const [state, dispatch] = useReducer(messengerReducer, initialState);\n  const message = state.message;\n  const contact = contacts.find((c) => c.id === state.selectedId);\n  return (\n    <div>\n      <ContactList\n        contacts={contacts}\n        selectedId={state.selectedId}\n        dispatch={dispatch}\n      />\n      <Chat\n        key={contact.id}\n        message={message}\n        contact={contact}\n        dispatch={dispatch}\n      />\n    </div>\n  );\n}\n\nconst contacts = [\n  {id: 0, name: 'Taylor', email: 'taylor@mail.com'},\n  {id: 1, name: 'Alice', email: 'alice@mail.com'},\n  {id: 2, name: 'Bob', email: 'bob@mail.com'},\n];"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 2477
    },
    {
      "url": "https://react.dev/learn/typescript",
      "title": "Using TypeScript",
      "breadcrumb": [],
      "section_path": [
        "Setup",
        "Using TypeScript"
      ],
      "headings": {
        "h1": [
          "Using TypeScript"
        ],
        "h2": [
          "Installation",
          "TypeScript with React Components",
          "Example Hooks",
          "Useful Types",
          "Further learning"
        ],
        "h3": [
          "You will learn",
          "Adding TypeScript to an existing React project",
          "Note",
          "Note",
          "useState",
          "useReducer",
          "useContext",
          "useMemo",
          "Note",
          "useCallback",
          "Note",
          "DOM Events",
          "Children",
          "Style Props"
        ]
      },
      "text_content": "LEARN REACT\nSETUP\nUsing TypeScript\n\nTypeScript is a popular way to add type definitions to JavaScript codebases. Out of the box, TypeScript supports JSX and you can get full React Web support by adding @types/react and @types/react-dom to your project.\n\nYou will learn\nTypeScript with React Components\nExamples of typing with Hooks\nCommon types from @types/react\nFurther learning locations\nInstallation \n\nAll production-grade React frameworks offer support for using TypeScript. Follow the framework specific guide for installation:\n\nNext.js\nRemix\nGatsby\nExpo\nAdding TypeScript to an existing React project \n\nTo install the latest version of React‚Äôs type definitions:\n\n Terminal\n Copy\nnpm install --save-dev @types/react @types/react-dom\n\nThe following compiler options need to be set in your tsconfig.json:\n\ndom must be included in lib (Note: If no lib option is specified, dom is included by default).\njsx must be set to one of the valid options. preserve should suffice for most applications. If you‚Äôre publishing a library, consult the jsx documentation on what value to choose.\nTypeScript with React Components \nNote\n\nEvery file containing JSX must use the .tsx file extension. This is a TypeScript-specific extension that tells TypeScript that this file contains JSX.\n\nWriting TypeScript with React is very similar to writing JavaScript with React. The key difference when working with a component is that you can provide types for your component‚Äôs props. These types can be used for correctness checking and providing inline documentation in editors.\n\nTaking the MyButton component from the Quick Start guide, we can add a type describing the title for the button:\n\nApp.tsx\nReload\nClear\nFork\nTypeScript Playground\nfunction MyButton({ title }: { title: string }) {\n return (\n <button>{title}</button>\n );\n}\n\nexport default function MyApp() {\n return (\n <div>\n <h1>Welcome to my app</h1>\n <MyButton title=\"I'm a button\" />\n </div>\n );\n}\n\nNote\n\nThese sandboxes can handle TypeScript code, but they do not run the type-checker. This means you can amend the TypeScript sandboxes to learn, but you won‚Äôt get any type errors or warnings. To get type-checking, you can use the TypeScript Playground or use a more fully-featured online sandbox.\n\nThis inline syntax is the simplest way to provide types for a component, though once you start to have a few fields to describe it can become unwieldy. Instead, you can use an interface or type to describe the component‚Äôs props:\n\nApp.tsx\nReload\nClear\nFork\nTypeScript Playground\ninterface MyButtonProps {\n /** The text to display inside the button */\n title: string;\n /** Whether the button can be interacted with */\n disabled: boolean;\n}\n\nfunction MyButton({ title, disabled }: MyButtonProps) {\n return (\n <button disabled={disabled}>{title}</button>\n );\n}\n\nexport default function MyApp() {\n return (\n <div>\n <h1>Welcome to my app</h1>\n <MyButton title=\"I'm a disabled button\" disabled={true}/>\n </div>\n );\n}\n\nShow more\n\nThe type describing your component‚Äôs props can be as simple or as complex as you need, though they should be an object type described with either a type or interface. You can learn about how TypeScript describes objects in Object Types but you may also be interested in using Union Types to describe a prop that can be one of a few different types and the Creating Types from Types guide for more advanced use cases.\n\nExample Hooks \n\nThe type definitions from @types/react include types for the built-in Hooks, so you can use them in your components without any additional setup. They are built to take into account the code you write in your component, so you will get inferred types a lot of the time and ideally do not need to handle the minutiae of providing the types.\n\nHowever, we can look at a few examples of how to provide types for Hooks.\n\nuseState \n\nThe useState Hook will re-use the value passed in as the initial state to determine what the type of the value should be. For example:\n\n// Infer the type as \"boolean\"\n\nconst [enabled, setEnabled] = useState(false);\n\nThis will assign the type of boolean to enabled, and setEnabled will be a function accepting either a boolean argument, or a function that returns a boolean. If you want to explicitly provide a type for the state, you can do so by providing a type argument to the useState call:\n\n// Explicitly set the type to \"boolean\"\n\nconst [enabled, setEnabled] = useState<boolean>(false);\n\nThis isn‚Äôt very useful in this case, but a common case where you may want to provide a type is when you have a union type. For example, status here can be one of a few different strings:\n\ntype Status = \"idle\" | \"loading\" | \"success\" | \"error\";\n\nconst [status, setStatus] = useState<Status>(\"idle\");\n\nOr, as recommended in Principles for structuring state, you can group related state as an object and describe the different possibilities via object types:\n\ntype RequestState =\n\n | { status: 'idle' }\n\n | { status: 'loading' }\n\n | { status: 'success', data: any }\n\n | { status: 'error', error: Error };\n\nconst [requestState, setRequestState] = useState<RequestState>({ status: 'idle' });\nuseReducer \n\nThe useReducer Hook is a more complex Hook that takes a reducer function and an initial state. The types for the reducer function are inferred from the initial state. You can optionally provide a type argument to the useReducer call to provide a type for the state, but it is often better to set the type on the initial state instead:\n\nApp.tsx\nReload\nClear\nFork\nTypeScript Playground\nimport {useReducer} from 'react';\n\ninterface State {\n count: number\n};\n\ntype CounterAction =\n | { type: \"reset\" }\n | { type: \"setCount\"; value: State[\"count\"] }\n\nconst initialState: State = { count: 0 };\n\nfunction stateReducer(state: State, action: CounterAction): State {\n switch (action.type) {\n case \"reset\":\n return initialState;\n case \"setCount\":\n return { ...state, count: action.value };\n default:\n throw new Error(\"Unknown action\");\n }\n}\n\nexport default function App() {\n const [state, dispatch] = useReducer(stateReducer, initialState);\n\n const addFive = () => dispatch({ type: \"setCount\", value: state.count + 5 });\n const reset = () => dispatch({ type: \"reset\" });\n\n return (\n <div>\n <h1>Welcome to my counter</h1>\n\n <p>Count: {state.count}</p>\n <button onClick={addFive}>Add 5</button>\n <button onClick={reset}>Reset</button>\n </div>\n );\n}\n\nShow more\n\nWe are using TypeScript in a few key places:\n\ninterface State describes the shape of the reducer‚Äôs state.\ntype CounterAction describes the different actions which can be dispatched to the reducer.\nconst initialState: State provides a type for the initial state, and also the type which is used by useReducer by default.\nstateReducer(state: State, action: CounterAction): State sets the types for the reducer function‚Äôs arguments and return value.\n\nA more explicit alternative to setting the type on initialState is to provide a type argument to useReducer:\n\nimport { stateReducer, State } from './your-reducer-implementation';\n\nconst initialState = { count: 0 };\n\nexport default function App() {\n\n const [state, dispatch] = useReducer<State>(stateReducer, initialState);\n\n}\nuseContext \n\nThe useContext Hook is a technique for passing data down the component tree without having to pass props through components. It is used by creating a provider component and often by creating a Hook to consume the value in a child component.\n\nThe type of the value provided by the context is inferred from the value passed to the createContext call:\n\nApp.tsx\nReload\nClear\nFork\nTypeScript Playground\nimport { createContext, useContext, useState } from 'react';\n\ntype Theme = \"light\" | \"dark\" | \"system\";\nconst ThemeContext = createContext<Theme>(\"system\");\n\nconst useGetTheme = () => useContext(ThemeContext);\n\nexport default function MyApp() {\n const [theme, setTheme] = useState<Theme>('light');\n\n return (\n <ThemeContext value={theme}>\n <MyComponent />\n </ThemeContext>\n )\n}\n\nfunction MyComponent() {\n const theme = useGetTheme();\n\n return (\n <div>\n <p>Current theme: {theme}</p>\n </div>\n )\n}\n\nShow more\n\nThis technique works when you have a default value which makes sense - but there are occasionally cases when you do not, and in those cases null can feel reasonable as a default value. However, to allow the type-system to understand your code, you need to explicitly set ContextShape | null on the createContext.\n\nThis causes the issue that you need to eliminate the | null in the type for context consumers. Our recommendation is to have the Hook do a runtime check for it‚Äôs existence and throw an error when not present:\n\nimport { createContext, useContext, useState, useMemo } from 'react';\n\n// This is a simpler example, but you can imagine a more complex object here\n\ntype ComplexObject = {\n\n kind: string\n\n};\n\n// The context is created with `| null` in the type, to accurately reflect the default value.\n\nconst Context = createContext<ComplexObject | null>(null);\n\n// The `| null` will be removed via the check in the Hook.\n\nconst useGetComplexObject = () => {\n\n const object = useContext(Context);\n\n if (!object) { throw new Error(\"useGetComplexObject must be used within a Provider\") }\n\n return object;\n\n}\n\nexport default function MyApp() {\n\n const object = useMemo(() => ({ kind: \"complex\" }), []);\n\n return (\n\n <Context value={object}>\n\n <MyComponent />\n\n </Context>\n\n )\n\n}\n\nfunction MyComponent() {\n\n const object = useGetComplexObject();\n\n return (\n\n <div>\n\n <p>Current object: {object.kind}</p>\n\n </div>\n\n )\n\n}\nuseMemo \nNote\n\nReact Compiler automatically memoizes values and functions, reducing the need for manual useMemo calls. You can use the compiler to handle memoization automatically.\n\nThe useMemo Hooks will create/re-access a memorized value from a function call, re-running the function only when dependencies passed as the 2nd parameter are changed. The result of calling the Hook is inferred from the return value from the function in the first parameter. You can be more explicit by providing a type argument to the Hook.\n\n// The type of visibleTodos is inferred from the return value of filterTodos\n\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\nuseCallback \nNote\n\nReact Compiler automatically memoizes values and functions, reducing the need for manual useCallback calls. You can use the compiler to handle memoization automatically.\n\nThe useCallback provide a stable reference to a function as long as the dependencies passed into the second parameter are the same. Like useMemo, the function‚Äôs type is inferred from the return value of the function in the first parameter, and you can be more explicit by providing a type argument to the Hook.\n\nconst handleClick = useCallback(() => {\n\n // ...\n\n}, [todos]);\n\nWhen working in TypeScript strict mode useCallback requires adding types for the parameters in your callback. This is because the type of the callback is inferred from the return value of the function, and without parameters the type cannot be fully understood.\n\nDepending on your code-style preferences, you could use the *EventHandler functions from the React types to provide the type for the event handler at the same time as defining the callback:\n\nimport { useState, useCallback } from 'react';\n\nexport default function Form() {\n\n const [value, setValue] = useState(\"Change me\");\n\n const handleChange = useCallback<React.ChangeEventHandler<HTMLInputElement>>((event) => {\n\n setValue(event.currentTarget.value);\n\n }, [setValue])\n\n return (\n\n <>\n\n <input value={value} onChange={handleChange} />\n\n <p>Value: {value}</p>\n\n </>\n\n );\n\n}\nUseful Types \n\nThere is quite an expansive set of types which come from the @types/react package, it is worth a read when you feel comfortable with how React and TypeScript interact. You can find them in React‚Äôs folder in DefinitelyTyped. We will cover a few of the more common types here.\n\nDOM Events \n\nWhen working with DOM events in React, the type of the event can often be inferred from the event handler. However, when you want to extract a function to be passed to an event handler, you will need to explicitly set the type of the event.\n\nApp.tsx\nReload\nClear\nFork\nTypeScript Playground\nimport { useState } from 'react';\n\nexport default function Form() {\n const [value, setValue] = useState(\"Change me\");\n\n function handleChange(event: React.ChangeEvent<HTMLInputElement>) {\n setValue(event.currentTarget.value);\n }\n\n return (\n <>\n <input value={value} onChange={handleChange} />\n <p>Value: {value}</p>\n </>\n );\n}\n\nShow more\n\nThere are many types of events provided in the React types - the full list can be found here which is based on the most popular events from the DOM.\n\nWhen determining the type you are looking for you can first look at the hover information for the event handler you are using, which will show the type of the event.\n\nIf you need to use an event that is not included in this list, you can use the React.SyntheticEvent type, which is the base type for all events.\n\nChildren \n\nThere are two common paths to describing the children of a component. The first is to use the React.ReactNode type, which is a union of all the possible types that can be passed as children in JSX:\n\ninterface ModalRendererProps {\n\n title: string;\n\n children: React.ReactNode;\n\n}\n\nThis is a very broad definition of children. The second is to use the React.ReactElement type, which is only JSX elements and not JavaScript primitives like strings or numbers:\n\ninterface ModalRendererProps {\n\n title: string;\n\n children: React.ReactElement;\n\n}\n\nNote, that you cannot use TypeScript to describe that the children are a certain type of JSX elements, so you cannot use the type-system to describe a component which only accepts <li> children.\n\nYou can see an example of both React.ReactNode and React.ReactElement with the type-checker in this TypeScript playground.\n\nStyle Props \n\nWhen using inline styles in React, you can use React.CSSProperties to describe the object passed to the style prop. This type is a union of all the possible CSS properties, and is a good way to ensure you are passing valid CSS properties to the style prop, and to get auto-complete in your editor.\n\ninterface MyComponentProps {\n\n style: React.CSSProperties;\n\n}\nFurther learning \n\nThis guide has covered the basics of using TypeScript with React, but there is a lot more to learn.\nIndividual API pages on the docs may contain more in-depth documentation on how to use them with TypeScript.\n\nWe recommend the following resources:\n\nThe TypeScript handbook is the official documentation for TypeScript, and covers most key language features.\n\nThe TypeScript release notes cover new features in depth.\n\nReact TypeScript Cheatsheet is a community-maintained cheatsheet for using TypeScript with React, covering a lot of useful edge cases and providing more breadth than this document.\n\nTypeScript Community Discord is a great place to ask questions and get help with TypeScript and React issues.\n\nPREVIOUS\nEditor Setup\nNEXT\nReact Developer Tools",
      "tables": [],
      "code_blocks": [
        "@types/react",
        "@types/react-dom",
        "@types/react",
        "npm install --save-dev @types/react @types/react-dom",
        "npm install --save-dev @types/react @types/react-dom",
        "tsconfig.json",
        "function MyButton({ title }: { title: string }) {\n  return (\n    <button>{title}</button>\n  );\n}\n\nexport default function MyApp() {\n  return (\n    <div>\n      <h1>Welcome to my app</h1>\n      <MyButton title=\"I'm a button\" />\n    </div>\n  );\n}",
        "interface MyButtonProps {\n  /** The text to display inside the button */\n  title: string;\n  /** Whether the button can be interacted with */\n  disabled: boolean;\n}\n\nfunction MyButton({ title, disabled }: MyButtonProps) {\n  return (\n    <button disabled={disabled}>{title}</button>\n  );\n}\n\nexport default function MyApp() {\n  return (\n    <div>\n      <h1>Welcome to my app</h1>\n      <MyButton title=\"I'm a disabled button\" disabled={true}/>\n    </div>\n  );\n}",
        "@types/react",
        "// Infer the type as \"boolean\"\n\nconst [enabled, setEnabled] = useState(false);",
        "// Infer the type as \"boolean\"\n\nconst [enabled, setEnabled] = useState(false);",
        "// Explicitly set the type to \"boolean\"\n\nconst [enabled, setEnabled] = useState<boolean>(false);",
        "// Explicitly set the type to \"boolean\"\n\nconst [enabled, setEnabled] = useState<boolean>(false);",
        "type Status = \"idle\" | \"loading\" | \"success\" | \"error\";\n\n\n\nconst [status, setStatus] = useState<Status>(\"idle\");",
        "type Status = \"idle\" | \"loading\" | \"success\" | \"error\";\n\n\n\nconst [status, setStatus] = useState<Status>(\"idle\");",
        "type RequestState =\n\n  | { status: 'idle' }\n\n  | { status: 'loading' }\n\n  | { status: 'success', data: any }\n\n  | { status: 'error', error: Error };\n\n\n\nconst [requestState, setRequestState] = useState<RequestState>({ status: 'idle' });",
        "type RequestState =\n\n  | { status: 'idle' }\n\n  | { status: 'loading' }\n\n  | { status: 'success', data: any }\n\n  | { status: 'error', error: Error };\n\n\n\nconst [requestState, setRequestState] = useState<RequestState>({ status: 'idle' });",
        "import {useReducer} from 'react';\n\ninterface State {\n   count: number\n};\n\ntype CounterAction =\n  | { type: \"reset\" }\n  | { type: \"setCount\"; value: State[\"count\"] }\n\nconst initialState: State = { count: 0 };\n\nfunction stateReducer(state: State, action: CounterAction): State {\n  switch (action.type) {\n    case \"reset\":\n      return initialState;\n    case \"setCount\":\n      return { ...state, count: action.value };\n    default:\n      throw new Error(\"Unknown action\");\n  }\n}\n\nexport default function App() {\n  const [state, dispatch] = useReducer(stateReducer, initialState);\n\n  const addFive = () => dispatch({ type: \"setCount\", value: state.count + 5 });\n  const reset = () => dispatch({ type: \"reset\" });\n\n  return (\n    <div>\n      <h1>Welcome to my counter</h1>\n\n      <p>Count: {state.count}</p>\n      <button onClick={addFive}>Add 5</button>\n      <button onClick={reset}>Reset</button>\n    </div>\n  );\n}",
        "interface State",
        "type CounterAction",
        "const initialState: State",
        "stateReducer(state: State, action: CounterAction): State",
        "initialState",
        "import { stateReducer, State } from './your-reducer-implementation';\n\n\n\nconst initialState = { count: 0 };\n\n\n\nexport default function App() {\n\n  const [state, dispatch] = useReducer<State>(stateReducer, initialState);\n\n}",
        "import { stateReducer, State } from './your-reducer-implementation';\n\n\n\nconst initialState = { count: 0 };\n\n\n\nexport default function App() {\n\n  const [state, dispatch] = useReducer<State>(stateReducer, initialState);\n\n}",
        "createContext",
        "import { createContext, useContext, useState } from 'react';\n\ntype Theme = \"light\" | \"dark\" | \"system\";\nconst ThemeContext = createContext<Theme>(\"system\");\n\nconst useGetTheme = () => useContext(ThemeContext);\n\nexport default function MyApp() {\n  const [theme, setTheme] = useState<Theme>('light');\n\n  return (\n    <ThemeContext value={theme}>\n      <MyComponent />\n    </ThemeContext>\n  )\n}\n\nfunction MyComponent() {\n  const theme = useGetTheme();\n\n  return (\n    <div>\n      <p>Current theme: {theme}</p>\n    </div>\n  )\n}",
        "ContextShape | null",
        "createContext",
        "import { createContext, useContext, useState, useMemo } from 'react';\n\n\n\n// This is a simpler example, but you can imagine a more complex object here\n\ntype ComplexObject = {\n\n  kind: string\n\n};\n\n\n\n// The context is created with `| null` in the type, to accurately reflect the default value.\n\nconst Context = createContext<ComplexObject | null>(null);\n\n\n\n// The `| null` will be removed via the check in the Hook.\n\nconst useGetComplexObject = () => {\n\n  const object = useContext(Context);\n\n  if (!object) { throw new Error(\"useGetComplexObject must be used within a Provider\") }\n\n  return object;\n\n}\n\n\n\nexport default function MyApp() {\n\n  const object = useMemo(() => ({ kind: \"complex\" }), []);\n\n\n\n  return (\n\n    <Context value={object}>\n\n      <MyComponent />\n\n    </Context>\n\n  )\n\n}\n\n\n\nfunction MyComponent() {\n\n  const object = useGetComplexObject();\n\n\n\n  return (\n\n    <div>\n\n      <p>Current object: {object.kind}</p>\n\n    </div>\n\n  )\n\n}",
        "import { createContext, useContext, useState, useMemo } from 'react';\n\n\n\n// This is a simpler example, but you can imagine a more complex object here\n\ntype ComplexObject = {\n\n  kind: string\n\n};\n\n\n\n// The context is created with `| null` in the type, to accurately reflect the default value.\n\nconst Context = createContext<ComplexObject | null>(null);\n\n\n\n// The `| null` will be removed via the check in the Hook.\n\nconst useGetComplexObject = () => {\n\n  const object = useContext(Context);\n\n  if (!object) { throw new Error(\"useGetComplexObject must be used within a Provider\") }\n\n  return object;\n\n}\n\n\n\nexport default function MyApp() {\n\n  const object = useMemo(() => ({ kind: \"complex\" }), []);\n\n\n\n  return (\n\n    <Context value={object}>\n\n      <MyComponent />\n\n    </Context>\n\n  )\n\n}\n\n\n\nfunction MyComponent() {\n\n  const object = useGetComplexObject();\n\n\n\n  return (\n\n    <div>\n\n      <p>Current object: {object.kind}</p>\n\n    </div>\n\n  )\n\n}",
        "// The type of visibleTodos is inferred from the return value of filterTodos\n\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);",
        "// The type of visibleTodos is inferred from the return value of filterTodos\n\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);",
        "useCallback",
        "useCallback",
        "useCallback",
        "const handleClick = useCallback(() => {\n\n  // ...\n\n}, [todos]);",
        "const handleClick = useCallback(() => {\n\n  // ...\n\n}, [todos]);",
        "useCallback",
        "*EventHandler",
        "import { useState, useCallback } from 'react';\n\n\n\nexport default function Form() {\n\n  const [value, setValue] = useState(\"Change me\");\n\n\n\n  const handleChange = useCallback<React.ChangeEventHandler<HTMLInputElement>>((event) => {\n\n    setValue(event.currentTarget.value);\n\n  }, [setValue])\n\n\n\n  return (\n\n    <>\n\n      <input value={value} onChange={handleChange} />\n\n      <p>Value: {value}</p>\n\n    </>\n\n  );\n\n}",
        "import { useState, useCallback } from 'react';\n\n\n\nexport default function Form() {\n\n  const [value, setValue] = useState(\"Change me\");\n\n\n\n  const handleChange = useCallback<React.ChangeEventHandler<HTMLInputElement>>((event) => {\n\n    setValue(event.currentTarget.value);\n\n  }, [setValue])\n\n\n\n  return (\n\n    <>\n\n      <input value={value} onChange={handleChange} />\n\n      <p>Value: {value}</p>\n\n    </>\n\n  );\n\n}",
        "@types/react",
        "import { useState } from 'react';\n\nexport default function Form() {\n  const [value, setValue] = useState(\"Change me\");\n\n  function handleChange(event: React.ChangeEvent<HTMLInputElement>) {\n    setValue(event.currentTarget.value);\n  }\n\n  return (\n    <>\n      <input value={value} onChange={handleChange} />\n      <p>Value: {value}</p>\n    </>\n  );\n}",
        "React.SyntheticEvent",
        "React.ReactNode",
        "interface ModalRendererProps {\n\n  title: string;\n\n  children: React.ReactNode;\n\n}",
        "interface ModalRendererProps {\n\n  title: string;\n\n  children: React.ReactNode;\n\n}",
        "React.ReactElement",
        "interface ModalRendererProps {\n\n  title: string;\n\n  children: React.ReactElement;\n\n}",
        "interface ModalRendererProps {\n\n  title: string;\n\n  children: React.ReactElement;\n\n}",
        "React.ReactNode",
        "React.ReactElement",
        "React.CSSProperties",
        "interface MyComponentProps {\n\n  style: React.CSSProperties;\n\n}",
        "interface MyComponentProps {\n\n  style: React.CSSProperties;\n\n}"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 2319
    },
    {
      "url": "https://react.dev/learn/writing-markup-with-jsx",
      "title": "Writing Markup with JSX",
      "breadcrumb": [],
      "section_path": [
        "Describing the UI",
        "Writing Markup with JSX"
      ],
      "headings": {
        "h1": [
          "Writing Markup with JSX"
        ],
        "h2": [
          "JSX: Putting markup into JavaScript",
          "Converting HTML to JSX",
          "The Rules of JSX",
          "Recap",
          "Try out some challenges"
        ],
        "h3": [
          "You will learn",
          "Note",
          "Note",
          "1. Return a single root element",
          "2. Close all the tags",
          "3. camelCase all most of the things!",
          "Pitfall",
          "Pro-tip: Use a JSX Converter"
        ],
        "h4": [
          "Why do multiple JSX tags need to be wrapped?",
          "Challenge 1 of 1: Convert some HTML to JSX"
        ],
        "h5": [
          "DEEP DIVE"
        ]
      },
      "text_content": "LEARN REACT\nDESCRIBING THE UI\nWriting Markup with JSX\n\nJSX is a syntax extension for JavaScript that lets you write HTML-like markup inside a JavaScript file. Although there are other ways to write components, most React developers prefer the conciseness of JSX, and most codebases use it.\n\nYou will learn\nWhy React mixes markup with rendering logic\nHow JSX is different from HTML\nHow to display information with JSX\nJSX: Putting markup into JavaScript \n\nThe Web has been built on HTML, CSS, and JavaScript. For many years, web developers kept content in HTML, design in CSS, and logic in JavaScript‚Äîoften in separate files! Content was marked up inside HTML while the page‚Äôs logic lived separately in JavaScript:\n\nHTML\n\nJavaScript\n\nBut as the Web became more interactive, logic increasingly determined content. JavaScript was in charge of the HTML! This is why in React, rendering logic and markup live together in the same place‚Äîcomponents.\n\nSidebar.js React component\n\nForm.js React component\n\nKeeping a button‚Äôs rendering logic and markup together ensures that they stay in sync with each other on every edit. Conversely, details that are unrelated, such as the button‚Äôs markup and a sidebar‚Äôs markup, are isolated from each other, making it safer to change either of them on their own.\n\nEach React component is a JavaScript function that may contain some markup that React renders into the browser. React components use a syntax extension called JSX to represent that markup. JSX looks a lot like HTML, but it is a bit stricter and can display dynamic information. The best way to understand this is to convert some HTML markup to JSX markup.\n\nNote\n\nJSX and React are two separate things. They‚Äôre often used together, but you can use them independently of each other. JSX is a syntax extension, while React is a JavaScript library.\n\nConverting HTML to JSX \n\nSuppose that you have some (perfectly valid) HTML:\n\n<h1>Hedy Lamarr's Todos</h1>\n\n<img \n\n src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n\n alt=\"Hedy Lamarr\" \n\n class=\"photo\"\n\n>\n\n<ul>\n\n <li>Invent new traffic lights\n\n <li>Rehearse a movie scene\n\n <li>Improve the spectrum technology\n\n</ul>\n\nAnd you want to put it into your component:\n\nexport default function TodoList() {\n\n return (\n\n // ???\n\n )\n\n}\n\nIf you copy and paste it as is, it will not work:\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function TodoList() {\n return (\n // This doesn't quite work!\n <h1>Hedy Lamarr's Todos</h1>\n <img \n src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n alt=\"Hedy Lamarr\" \n class=\"photo\"\n >\n <ul>\n <li>Invent new traffic lights\n <li>Rehearse a movie scene\n <li>Improve the spectrum technology\n </ul>\n\nShow more\n\nThis is because JSX is stricter and has a few more rules than HTML! If you read the error messages above, they‚Äôll guide you to fix the markup, or you can follow the guide below.\n\nNote\n\nMost of the time, React‚Äôs on-screen error messages will help you find where the problem is. Give them a read if you get stuck!\n\nThe Rules of JSX \n1. Return a single root element \n\nTo return multiple elements from a component, wrap them with a single parent tag.\n\nFor example, you can use a <div>:\n\n<div>\n\n <h1>Hedy Lamarr's Todos</h1>\n\n <img \n\n src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n\n alt=\"Hedy Lamarr\" \n\n class=\"photo\"\n\n >\n\n <ul>\n\n ...\n\n </ul>\n\n</div>\n\nIf you don‚Äôt want to add an extra <div> to your markup, you can write <> and </> instead:\n\n<>\n\n <h1>Hedy Lamarr's Todos</h1>\n\n <img \n\n src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n\n alt=\"Hedy Lamarr\" \n\n class=\"photo\"\n\n >\n\n <ul>\n\n ...\n\n </ul>\n\n</>\n\nThis empty tag is called a Fragment. Fragments let you group things without leaving any trace in the browser HTML tree.\n\nDEEP DIVE\nWhy do multiple JSX tags need to be wrapped? \nShow Details\n2. Close all the tags \n\nJSX requires tags to be explicitly closed: self-closing tags like <img> must become <img />, and wrapping tags like <li>oranges must be written as <li>oranges</li>.\n\nThis is how Hedy Lamarr‚Äôs image and list items look closed:\n\n<>\n\n <img \n\n src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n\n alt=\"Hedy Lamarr\" \n\n class=\"photo\"\n\n />\n\n <ul>\n\n <li>Invent new traffic lights</li>\n\n <li>Rehearse a movie scene</li>\n\n <li>Improve the spectrum technology</li>\n\n </ul>\n\n</>\n3. camelCase all most of the things! \n\nJSX turns into JavaScript and attributes written in JSX become keys of JavaScript objects. In your own components, you will often want to read those attributes into variables. But JavaScript has limitations on variable names. For example, their names can‚Äôt contain dashes or be reserved words like class.\n\nThis is why, in React, many HTML and SVG attributes are written in camelCase. For example, instead of stroke-width you use strokeWidth. Since class is a reserved word, in React you write className instead, named after the corresponding DOM property:\n\n<img \n\n src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n\n alt=\"Hedy Lamarr\" \n\n className=\"photo\"\n\n/>\n\nYou can find all these attributes in the list of DOM component props. If you get one wrong, don‚Äôt worry‚ÄîReact will print a message with a possible correction to the browser console.\n\nPitfall\n\nFor historical reasons, aria-* and data-* attributes are written as in HTML with dashes.\n\nPro-tip: Use a JSX Converter \n\nConverting all these attributes in existing markup can be tedious! We recommend using a converter to translate your existing HTML and SVG to JSX. Converters are very useful in practice, but it‚Äôs still worth understanding what is going on so that you can comfortably write JSX on your own.\n\nHere is your final result:\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function TodoList() {\n return (\n <>\n <h1>Hedy Lamarr's Todos</h1>\n <img \n src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n alt=\"Hedy Lamarr\" \n className=\"photo\" \n />\n <ul>\n <li>Invent new traffic lights</li>\n <li>Rehearse a movie scene</li>\n <li>Improve the spectrum technology</li>\n </ul>\n </>\n );\n}\n\nShow more\nRecap\n\nNow you know why JSX exists and how to use it in components:\n\nReact components group rendering logic together with markup because they are related.\nJSX is similar to HTML, with a few differences. You can use a converter if you need to.\nError messages will often point you in the right direction to fixing your markup.\nTry out some challenges\nChallenge 1 of 1: Convert some HTML to JSX \n\nThis HTML was pasted into a component, but it‚Äôs not valid JSX. Fix it:\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function Bio() {\n return (\n <div class=\"intro\">\n <h1>Welcome to my website!</h1>\n </div>\n <p class=\"summary\">\n You can find my thoughts here.\n <br><br>\n <b>And <i>pictures</b></i> of scientists!\n </p>\n );\n}\n\nWhether to do it by hand or using the converter is up to you!\n\nShow solution\nPREVIOUS\nImporting and Exporting Components\nNEXT\nJavaScript in JSX with Curly Braces",
      "tables": [],
      "code_blocks": [
        "<h1>Hedy Lamarr's Todos</h1>\n\n<img \n\n  src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n\n  alt=\"Hedy Lamarr\" \n\n  class=\"photo\"\n\n>\n\n<ul>\n\n    <li>Invent new traffic lights\n\n    <li>Rehearse a movie scene\n\n    <li>Improve the spectrum technology\n\n</ul>",
        "<h1>Hedy Lamarr's Todos</h1>\n\n<img \n\n  src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n\n  alt=\"Hedy Lamarr\" \n\n  class=\"photo\"\n\n>\n\n<ul>\n\n    <li>Invent new traffic lights\n\n    <li>Rehearse a movie scene\n\n    <li>Improve the spectrum technology\n\n</ul>",
        "export default function TodoList() {\n\n  return (\n\n    // ???\n\n  )\n\n}",
        "export default function TodoList() {\n\n  return (\n\n    // ???\n\n  )\n\n}",
        "export default function TodoList() {\n  return (\n    // This doesn't quite work!\n    <h1>Hedy Lamarr's Todos</h1>\n    <img \n      src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n      alt=\"Hedy Lamarr\" \n      class=\"photo\"\n    >\n    <ul>\n      <li>Invent new traffic lights\n      <li>Rehearse a movie scene\n      <li>Improve the spectrum technology\n    </ul>",
        "<div>\n\n  <h1>Hedy Lamarr's Todos</h1>\n\n  <img \n\n    src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n\n    alt=\"Hedy Lamarr\" \n\n    class=\"photo\"\n\n  >\n\n  <ul>\n\n    ...\n\n  </ul>\n\n</div>",
        "<div>\n\n  <h1>Hedy Lamarr's Todos</h1>\n\n  <img \n\n    src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n\n    alt=\"Hedy Lamarr\" \n\n    class=\"photo\"\n\n  >\n\n  <ul>\n\n    ...\n\n  </ul>\n\n</div>",
        "<>\n\n  <h1>Hedy Lamarr's Todos</h1>\n\n  <img \n\n    src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n\n    alt=\"Hedy Lamarr\" \n\n    class=\"photo\"\n\n  >\n\n  <ul>\n\n    ...\n\n  </ul>\n\n</>",
        "<>\n\n  <h1>Hedy Lamarr's Todos</h1>\n\n  <img \n\n    src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n\n    alt=\"Hedy Lamarr\" \n\n    class=\"photo\"\n\n  >\n\n  <ul>\n\n    ...\n\n  </ul>\n\n</>",
        "<li>oranges",
        "<li>oranges</li>",
        "<>\n\n  <img \n\n    src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n\n    alt=\"Hedy Lamarr\" \n\n    class=\"photo\"\n\n   />\n\n  <ul>\n\n    <li>Invent new traffic lights</li>\n\n    <li>Rehearse a movie scene</li>\n\n    <li>Improve the spectrum technology</li>\n\n  </ul>\n\n</>",
        "<>\n\n  <img \n\n    src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n\n    alt=\"Hedy Lamarr\" \n\n    class=\"photo\"\n\n   />\n\n  <ul>\n\n    <li>Invent new traffic lights</li>\n\n    <li>Rehearse a movie scene</li>\n\n    <li>Improve the spectrum technology</li>\n\n  </ul>\n\n</>",
        "stroke-width",
        "strokeWidth",
        "<img \n\n  src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n\n  alt=\"Hedy Lamarr\" \n\n  className=\"photo\"\n\n/>",
        "<img \n\n  src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n\n  alt=\"Hedy Lamarr\" \n\n  className=\"photo\"\n\n/>",
        "export default function TodoList() {\n  return (\n    <>\n      <h1>Hedy Lamarr's Todos</h1>\n      <img \n        src=\"https://i.imgur.com/yXOvdOSs.jpg\" \n        alt=\"Hedy Lamarr\" \n        className=\"photo\" \n      />\n      <ul>\n        <li>Invent new traffic lights</li>\n        <li>Rehearse a movie scene</li>\n        <li>Improve the spectrum technology</li>\n      </ul>\n    </>\n  );\n}",
        "export default function Bio() {\n  return (\n    <div class=\"intro\">\n      <h1>Welcome to my website!</h1>\n    </div>\n    <p class=\"summary\">\n      You can find my thoughts here.\n      <br><br>\n      <b>And <i>pictures</b></i> of scientists!\n    </p>\n  );\n}"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 1042
    },
    {
      "url": "https://react.dev/learn/referencing-values-with-refs",
      "title": "Referencing Values with Refs",
      "breadcrumb": [],
      "section_path": [
        "Escape Hatches",
        "Referencing Values with Refs"
      ],
      "headings": {
        "h1": [
          "Referencing Values with Refs"
        ],
        "h2": [
          "Adding a ref to your component",
          "Example: building a stopwatch",
          "Differences between refs and state",
          "When to use refs",
          "Best practices for refs",
          "Refs and the DOM",
          "Recap",
          "Try out some challenges"
        ],
        "h3": [
          "You will learn"
        ],
        "h4": [
          "How does useRef work inside?",
          "Challenge 1 of 4: Fix a broken chat input"
        ],
        "h5": [
          "DEEP DIVE"
        ]
      },
      "text_content": "LEARN REACT\nESCAPE HATCHES\nReferencing Values with Refs\n\nWhen you want a component to ‚Äúremember‚Äù some information, but you don‚Äôt want that information to trigger new renders, you can use a ref.\n\nYou will learn\nHow to add a ref to your component\nHow to update a ref‚Äôs value\nHow refs are different from state\nHow to use refs safely\nAdding a ref to your component \n\nYou can add a ref to your component by importing the useRef Hook from React:\n\nimport { useRef } from 'react';\n\nInside your component, call the useRef Hook and pass the initial value that you want to reference as the only argument. For example, here is a ref to the value 0:\n\nconst ref = useRef(0);\n\nuseRef returns an object like this:\n\n{ \n\n current: 0 // The value you passed to useRef\n\n}\n\nIllustrated by Rachel Lee Nabors\n\nYou can access the current value of that ref through the ref.current property. This value is intentionally mutable, meaning you can both read and write to it. It‚Äôs like a secret pocket of your component that React doesn‚Äôt track. (This is what makes it an ‚Äúescape hatch‚Äù from React‚Äôs one-way data flow‚Äîmore on that below!)\n\nHere, a button will increment ref.current on every click:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useRef } from 'react';\n\nexport default function Counter() {\n let ref = useRef(0);\n\n function handleClick() {\n ref.current = ref.current + 1;\n alert('You clicked ' + ref.current + ' times!');\n }\n\n return (\n <button onClick={handleClick}>\n Click me!\n </button>\n );\n}\n\nShow more\n\nThe ref points to a number, but, like state, you could point to anything: a string, an object, or even a function. Unlike state, ref is a plain JavaScript object with the current property that you can read and modify.\n\nNote that the component doesn‚Äôt re-render with every increment. Like state, refs are retained by React between re-renders. However, setting state re-renders a component. Changing a ref does not!\n\nExample: building a stopwatch \n\nYou can combine refs and state in a single component. For example, let‚Äôs make a stopwatch that the user can start or stop by pressing a button. In order to display how much time has passed since the user pressed ‚ÄúStart‚Äù, you will need to keep track of when the Start button was pressed and what the current time is. This information is used for rendering, so you‚Äôll keep it in state:\n\nconst [startTime, setStartTime] = useState(null);\n\nconst [now, setNow] = useState(null);\n\nWhen the user presses ‚ÄúStart‚Äù, you‚Äôll use setInterval in order to update the time every 10 milliseconds:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function Stopwatch() {\n const [startTime, setStartTime] = useState(null);\n const [now, setNow] = useState(null);\n\n function handleStart() {\n // Start counting.\n setStartTime(Date.now());\n setNow(Date.now());\n\n setInterval(() => {\n // Update the current time every 10ms.\n setNow(Date.now());\n }, 10);\n }\n\n let secondsPassed = 0;\n if (startTime != null && now != null) {\n secondsPassed = (now - startTime) / 1000;\n }\n\n return (\n <>\n <h1>Time passed: {secondsPassed.toFixed(3)}</h1>\n <button onClick={handleStart}>\n Start\n </button>\n </>\n );\n}\n\nShow more\n\nWhen the ‚ÄúStop‚Äù button is pressed, you need to cancel the existing interval so that it stops updating the now state variable. You can do this by calling clearInterval, but you need to give it the interval ID that was previously returned by the setInterval call when the user pressed Start. You need to keep the interval ID somewhere. Since the interval ID is not used for rendering, you can keep it in a ref:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState, useRef } from 'react';\n\nexport default function Stopwatch() {\n const [startTime, setStartTime] = useState(null);\n const [now, setNow] = useState(null);\n const intervalRef = useRef(null);\n\n function handleStart() {\n setStartTime(Date.now());\n setNow(Date.now());\n\n clearInterval(intervalRef.current);\n intervalRef.current = setInterval(() => {\n setNow(Date.now());\n }, 10);\n }\n\n function handleStop() {\n clearInterval(intervalRef.current);\n }\n\n let secondsPassed = 0;\n if (startTime != null && now != null) {\n secondsPassed = (now - startTime) / 1000;\n }\n\n return (\n <>\n <h1>Time passed: {secondsPassed.toFixed(3)}</h1>\n <button onClick={handleStart}>\n Start\n </button>\n <button onClick={handleStop}>\n Stop\n </button>\n </>\n );\n}\n\nShow more\n\nWhen a piece of information is used for rendering, keep it in state. When a piece of information is only needed by event handlers and changing it doesn‚Äôt require a re-render, using a ref may be more efficient.\n\nDifferences between refs and state \n\nPerhaps you‚Äôre thinking refs seem less ‚Äústrict‚Äù than state‚Äîyou can mutate them instead of always having to use a state setting function, for instance. But in most cases, you‚Äôll want to use state. Refs are an ‚Äúescape hatch‚Äù you won‚Äôt need often. Here‚Äôs how state and refs compare:\n\nrefs\tstate\nuseRef(initialValue) returns { current: initialValue }\tuseState(initialValue) returns the current value of a state variable and a state setter function ( [value, setValue])\nDoesn‚Äôt trigger re-render when you change it.\tTriggers re-render when you change it.\nMutable‚Äîyou can modify and update current‚Äôs value outside of the rendering process.\t‚ÄùImmutable‚Äù‚Äîyou must use the state setting function to modify state variables to queue a re-render.\nYou shouldn‚Äôt read (or write) the current value during rendering.\tYou can read state at any time. However, each render has its own snapshot of state which does not change.\n\nHere is a counter button that‚Äôs implemented with state:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function Counter() {\n const [count, setCount] = useState(0);\n\n function handleClick() {\n setCount(count + 1);\n }\n\n return (\n <button onClick={handleClick}>\n You clicked {count} times\n </button>\n );\n}\n\nBecause the count value is displayed, it makes sense to use a state value for it. When the counter‚Äôs value is set with setCount(), React re-renders the component and the screen updates to reflect the new count.\n\nIf you tried to implement this with a ref, React would never re-render the component, so you‚Äôd never see the count change! See how clicking this button does not update its text:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useRef } from 'react';\n\nexport default function Counter() {\n let countRef = useRef(0);\n\n function handleClick() {\n // This doesn't re-render the component!\n countRef.current = countRef.current + 1;\n }\n\n return (\n <button onClick={handleClick}>\n You clicked {countRef.current} times\n </button>\n );\n}\n\nShow more\n\nThis is why reading ref.current during render leads to unreliable code. If you need that, use state instead.\n\nDEEP DIVE\nHow does useRef work inside? \nShow Details\nWhen to use refs \n\nTypically, you will use a ref when your component needs to ‚Äústep outside‚Äù React and communicate with external APIs‚Äîoften a browser API that won‚Äôt impact the appearance of the component. Here are a few of these rare situations:\n\nStoring timeout IDs\nStoring and manipulating DOM elements, which we cover on the next page\nStoring other objects that aren‚Äôt necessary to calculate the JSX.\n\nIf your component needs to store some value, but it doesn‚Äôt impact the rendering logic, choose refs.\n\nBest practices for refs \n\nFollowing these principles will make your components more predictable:\n\nTreat refs as an escape hatch. Refs are useful when you work with external systems or browser APIs. If much of your application logic and data flow relies on refs, you might want to rethink your approach.\nDon‚Äôt read or write ref.current during rendering. If some information is needed during rendering, use state instead. Since React doesn‚Äôt know when ref.current changes, even reading it while rendering makes your component‚Äôs behavior difficult to predict. (The only exception to this is code like if (!ref.current) ref.current = new Thing() which only sets the ref once during the first render.)\n\nLimitations of React state don‚Äôt apply to refs. For example, state acts like a snapshot for every render and doesn‚Äôt update synchronously. But when you mutate the current value of a ref, it changes immediately:\n\nref.current = 5;\n\nconsole.log(ref.current); // 5\n\nThis is because the ref itself is a regular JavaScript object, and so it behaves like one.\n\nYou also don‚Äôt need to worry about avoiding mutation when you work with a ref. As long as the object you‚Äôre mutating isn‚Äôt used for rendering, React doesn‚Äôt care what you do with the ref or its contents.\n\nRefs and the DOM \n\nYou can point a ref to any value. However, the most common use case for a ref is to access a DOM element. For example, this is handy if you want to focus an input programmatically. When you pass a ref to a ref attribute in JSX, like <div ref={myRef}>, React will put the corresponding DOM element into myRef.current. Once the element is removed from the DOM, React will update myRef.current to be null. You can read more about this in Manipulating the DOM with Refs.\n\nRecap\nRefs are an escape hatch to hold onto values that aren‚Äôt used for rendering. You won‚Äôt need them often.\nA ref is a plain JavaScript object with a single property called current, which you can read or set.\nYou can ask React to give you a ref by calling the useRef Hook.\nLike state, refs let you retain information between re-renders of a component.\nUnlike state, setting the ref‚Äôs current value does not trigger a re-render.\nDon‚Äôt read or write ref.current during rendering. This makes your component hard to predict.\nTry out some challenges\n1. Fix a broken chat input\n2. Fix a component failing to re-render\n3. Fix debouncing\n4. Read the latest state\nChallenge 1 of 4: Fix a broken chat input \n\nType a message and click ‚ÄúSend‚Äù. You will notice there is a three second delay before you see the ‚ÄúSent!‚Äù alert. During this delay, you can see an ‚ÄúUndo‚Äù button. Click it. This ‚ÄúUndo‚Äù button is supposed to stop the ‚ÄúSent!‚Äù message from appearing. It does this by calling clearTimeout for the timeout ID saved during handleSend. However, even after ‚ÄúUndo‚Äù is clicked, the ‚ÄúSent!‚Äù message still appears. Find why it doesn‚Äôt work, and fix it.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function Chat() {\n const [text, setText] = useState('');\n const [isSending, setIsSending] = useState(false);\n let timeoutID = null;\n\n function handleSend() {\n setIsSending(true);\n timeoutID = setTimeout(() => {\n alert('Sent!');\n setIsSending(false);\n }, 3000);\n }\n\n function handleUndo() {\n setIsSending(false);\n clearTimeout(timeoutID);\n }\n\n return (\n <>\n <input\n disabled={isSending}\n value={text}\n onChange={e => setText(e.target.value)}\n />\n <button\n disabled={isSending}\n onClick={handleSend}>\n {isSending ? 'Sending...' : 'Send'}\n </button>\n {isSending &&\n <button onClick={handleUndo}>\n Undo\n </button>\n }\n </>\n );\n}\n\nShow more\nShow hint\nShow solution\nNext Challenge\nPREVIOUS\nEscape Hatches\nNEXT\nManipulating the DOM with Refs",
      "tables": [
        {
          "headers": [
            "refs",
            "state"
          ],
          "rows": [
            [
              "useRef(initialValue) returns { current: initialValue }",
              "useState(initialValue) returns the current value of a state variable and a state setter function ( [value, setValue])"
            ],
            [
              "Doesn‚Äôt trigger re-render when you change it.",
              "Triggers re-render when you change it."
            ],
            [
              "Mutable‚Äîyou can modify and update current‚Äôs value outside of the rendering process.",
              "‚ÄùImmutable‚Äù‚Äîyou must use the state setting function to modify state variables to queue a re-render."
            ],
            [
              "You shouldn‚Äôt read (or write) the current value during rendering.",
              "You can read state at any time. However, each render has its own snapshot of state which does not change."
            ]
          ]
        }
      ],
      "code_blocks": [
        "import { useRef } from 'react';",
        "import { useRef } from 'react';",
        "const ref = useRef(0);",
        "const ref = useRef(0);",
        "{ \n\n  current: 0 // The value you passed to useRef\n\n}",
        "{ \n\n  current: 0 // The value you passed to useRef\n\n}",
        "ref.current",
        "ref.current",
        "import { useRef } from 'react';\n\nexport default function Counter() {\n  let ref = useRef(0);\n\n  function handleClick() {\n    ref.current = ref.current + 1;\n    alert('You clicked ' + ref.current + ' times!');\n  }\n\n  return (\n    <button onClick={handleClick}>\n      Click me!\n    </button>\n  );\n}",
        "const [startTime, setStartTime] = useState(null);\n\nconst [now, setNow] = useState(null);",
        "const [startTime, setStartTime] = useState(null);\n\nconst [now, setNow] = useState(null);",
        "setInterval",
        "import { useState } from 'react';\n\nexport default function Stopwatch() {\n  const [startTime, setStartTime] = useState(null);\n  const [now, setNow] = useState(null);\n\n  function handleStart() {\n    // Start counting.\n    setStartTime(Date.now());\n    setNow(Date.now());\n\n    setInterval(() => {\n      // Update the current time every 10ms.\n      setNow(Date.now());\n    }, 10);\n  }\n\n  let secondsPassed = 0;\n  if (startTime != null && now != null) {\n    secondsPassed = (now - startTime) / 1000;\n  }\n\n  return (\n    <>\n      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>\n      <button onClick={handleStart}>\n        Start\n      </button>\n    </>\n  );\n}",
        "clearInterval",
        "setInterval",
        "import { useState, useRef } from 'react';\n\nexport default function Stopwatch() {\n  const [startTime, setStartTime] = useState(null);\n  const [now, setNow] = useState(null);\n  const intervalRef = useRef(null);\n\n  function handleStart() {\n    setStartTime(Date.now());\n    setNow(Date.now());\n\n    clearInterval(intervalRef.current);\n    intervalRef.current = setInterval(() => {\n      setNow(Date.now());\n    }, 10);\n  }\n\n  function handleStop() {\n    clearInterval(intervalRef.current);\n  }\n\n  let secondsPassed = 0;\n  if (startTime != null && now != null) {\n    secondsPassed = (now - startTime) / 1000;\n  }\n\n  return (\n    <>\n      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>\n      <button onClick={handleStart}>\n        Start\n      </button>\n      <button onClick={handleStop}>\n        Stop\n      </button>\n    </>\n  );\n}",
        "useRef(initialValue)",
        "{ current: initialValue }",
        "useState(initialValue)",
        "[value, setValue]",
        "import { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  function handleClick() {\n    setCount(count + 1);\n  }\n\n  return (\n    <button onClick={handleClick}>\n      You clicked {count} times\n    </button>\n  );\n}",
        "import { useRef } from 'react';\n\nexport default function Counter() {\n  let countRef = useRef(0);\n\n  function handleClick() {\n    // This doesn't re-render the component!\n    countRef.current = countRef.current + 1;\n  }\n\n  return (\n    <button onClick={handleClick}>\n      You clicked {countRef.current} times\n    </button>\n  );\n}",
        "ref.current",
        "ref.current",
        "ref.current",
        "if (!ref.current) ref.current = new Thing()",
        "ref.current = 5;\n\nconsole.log(ref.current); // 5",
        "ref.current = 5;\n\nconsole.log(ref.current); // 5",
        "<div ref={myRef}>",
        "myRef.current",
        "myRef.current",
        "ref.current",
        "clearTimeout",
        "import { useState } from 'react';\n\nexport default function Chat() {\n  const [text, setText] = useState('');\n  const [isSending, setIsSending] = useState(false);\n  let timeoutID = null;\n\n  function handleSend() {\n    setIsSending(true);\n    timeoutID = setTimeout(() => {\n      alert('Sent!');\n      setIsSending(false);\n    }, 3000);\n  }\n\n  function handleUndo() {\n    setIsSending(false);\n    clearTimeout(timeoutID);\n  }\n\n  return (\n    <>\n      <input\n        disabled={isSending}\n        value={text}\n        onChange={e => setText(e.target.value)}\n      />\n      <button\n        disabled={isSending}\n        onClick={handleSend}>\n        {isSending ? 'Sending...' : 'Send'}\n      </button>\n      {isSending &&\n        <button onClick={handleUndo}>\n          Undo\n        </button>\n      }\n    </>\n  );\n}"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 1733
    },
    {
      "url": "https://react.dev/learn/reusing-logic-with-custom-hooks",
      "title": "Reusing Logic with Custom Hooks",
      "breadcrumb": [],
      "section_path": [
        "Escape Hatches",
        "Reusing Logic with Custom Hooks"
      ],
      "headings": {
        "h1": [
          "Reusing Logic with Custom Hooks"
        ],
        "h2": [
          "Custom Hooks: Sharing logic between components",
          "Passing reactive values between Hooks",
          "When to use custom Hooks",
          "Recap",
          "Try out some challenges"
        ],
        "h3": [
          "You will learn",
          "Extracting your own custom Hook from a component",
          "Hook names always start with use",
          "Note",
          "Custom Hooks let you share stateful logic, not state itself",
          "Passing event handlers to custom Hooks",
          "Custom Hooks help you migrate to better patterns",
          "There is more than one way to do it"
        ],
        "h4": [
          "Should all functions called during rendering start with the use prefix?",
          "Keep your custom Hooks focused on concrete high-level use cases",
          "Will React provide any built-in solution for data fetching?",
          "Challenge 1 of 5: Extract a useCounter Hook"
        ],
        "h5": [
          "DEEP DIVE",
          "DEEP DIVE",
          "DEEP DIVE"
        ]
      },
      "text_content": "LEARN REACT\nESCAPE HATCHES\nReusing Logic with Custom Hooks\n\nReact comes with several built-in Hooks like useState, useContext, and useEffect. Sometimes, you‚Äôll wish that there was a Hook for some more specific purpose: for example, to fetch data, to keep track of whether the user is online, or to connect to a chat room. You might not find these Hooks in React, but you can create your own Hooks for your application‚Äôs needs.\n\nYou will learn\nWhat custom Hooks are, and how to write your own\nHow to reuse logic between components\nHow to name and structure your custom Hooks\nWhen and why to extract custom Hooks\nCustom Hooks: Sharing logic between components \n\nImagine you‚Äôre developing an app that heavily relies on the network (as most apps do). You want to warn the user if their network connection has accidentally gone off while they were using your app. How would you go about it? It seems like you‚Äôll need two things in your component:\n\nA piece of state that tracks whether the network is online.\nAn Effect that subscribes to the global online and offline events, and updates that state.\n\nThis will keep your component synchronized with the network status. You might start with something like this:\n\nApp.js\nDownload\nReload\nClear\nFork\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nimport { useState, useEffect } from 'react';\n\nexport default function StatusBar() {\n const [isOnline, setIsOnline] = useState(true);\n useEffect(() => {\n function handleOnline() {\n setIsOnline(true);\n }\n function handleOffline() {\n setIsOnline(false);\n }\n window.addEventListener('online', handleOnline);\n window.addEventListener('offline', handleOffline);\n return () => {\n window.removeEventListener('online', handleOnline);\n window.removeEventListener('offline', handleOffline);\n };\n }, []);\n\n return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>;\n}\n\nShow more\n\nTry turning your network on and off, and notice how this StatusBar updates in response to your actions.\n\nNow imagine you also want to use the same logic in a different component. You want to implement a Save button that will become disabled and show ‚ÄúReconnecting‚Ä¶‚Äù instead of ‚ÄúSave‚Äù while the network is off.\n\nTo start, you can copy and paste the isOnline state and the Effect into SaveButton:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\n\nexport default function SaveButton() {\n const [isOnline, setIsOnline] = useState(true);\n useEffect(() => {\n function handleOnline() {\n setIsOnline(true);\n }\n function handleOffline() {\n setIsOnline(false);\n }\n window.addEventListener('online', handleOnline);\n window.addEventListener('offline', handleOffline);\n return () => {\n window.removeEventListener('online', handleOnline);\n window.removeEventListener('offline', handleOffline);\n };\n }, []);\n\n function handleSaveClick() {\n console.log('‚úÖ Progress saved');\n }\n\n return (\n <button disabled={!isOnline} onClick={handleSaveClick}>\n {isOnline ? 'Save progress' : 'Reconnecting...'}\n </button>\n );\n}\n\nShow more\n\nVerify that, if you turn off the network, the button will change its appearance.\n\nThese two components work fine, but the duplication in logic between them is unfortunate. It seems like even though they have different visual appearance, you want to reuse the logic between them.\n\nExtracting your own custom Hook from a component \n\nImagine for a moment that, similar to useState and useEffect, there was a built-in useOnlineStatus Hook. Then both of these components could be simplified and you could remove the duplication between them:\n\nfunction StatusBar() {\n\n const isOnline = useOnlineStatus();\n\n return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>;\n\n}\n\nfunction SaveButton() {\n\n const isOnline = useOnlineStatus();\n\n function handleSaveClick() {\n\n console.log('‚úÖ Progress saved');\n\n }\n\n return (\n\n <button disabled={!isOnline} onClick={handleSaveClick}>\n\n {isOnline ? 'Save progress' : 'Reconnecting...'}\n\n </button>\n\n );\n\n}\n\nAlthough there is no such built-in Hook, you can write it yourself. Declare a function called useOnlineStatus and move all the duplicated code into it from the components you wrote earlier:\n\nfunction useOnlineStatus() {\n\n const [isOnline, setIsOnline] = useState(true);\n\n useEffect(() => {\n\n function handleOnline() {\n\n setIsOnline(true);\n\n }\n\n function handleOffline() {\n\n setIsOnline(false);\n\n }\n\n window.addEventListener('online', handleOnline);\n\n window.addEventListener('offline', handleOffline);\n\n return () => {\n\n window.removeEventListener('online', handleOnline);\n\n window.removeEventListener('offline', handleOffline);\n\n };\n\n }, []);\n\n return isOnline;\n\n}\n\nAt the end of the function, return isOnline. This lets your components read that value:\n\nApp.js\nuseOnlineStatus.js\nReload\nClear\nFork\nimport { useOnlineStatus } from './useOnlineStatus.js';\n\nfunction StatusBar() {\n const isOnline = useOnlineStatus();\n return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>;\n}\n\nfunction SaveButton() {\n const isOnline = useOnlineStatus();\n\n function handleSaveClick() {\n console.log('‚úÖ Progress saved');\n }\n\n return (\n <button disabled={!isOnline} onClick={handleSaveClick}>\n {isOnline ? 'Save progress' : 'Reconnecting...'}\n </button>\n );\n}\n\nexport default function App() {\n return (\n <>\n <SaveButton />\n <StatusBar />\n </>\n );\n}\n\nShow more\n\nVerify that switching the network on and off updates both components.\n\nNow your components don‚Äôt have as much repetitive logic. More importantly, the code inside them describes what they want to do (use the online status!) rather than how to do it (by subscribing to the browser events).\n\nWhen you extract logic into custom Hooks, you can hide the gnarly details of how you deal with some external system or a browser API. The code of your components expresses your intent, not the implementation.\n\nHook names always start with use \n\nReact applications are built from components. Components are built from Hooks, whether built-in or custom. You‚Äôll likely often use custom Hooks created by others, but occasionally you might write one yourself!\n\nYou must follow these naming conventions:\n\nReact component names must start with a capital letter, like StatusBar and SaveButton. React components also need to return something that React knows how to display, like a piece of JSX.\nHook names must start with use followed by a capital letter, like useState (built-in) or useOnlineStatus (custom, like earlier on the page). Hooks may return arbitrary values.\n\nThis convention guarantees that you can always look at a component and know where its state, Effects, and other React features might ‚Äúhide‚Äù. For example, if you see a getColor() function call inside your component, you can be sure that it can‚Äôt possibly contain React state inside because its name doesn‚Äôt start with use. However, a function call like useOnlineStatus() will most likely contain calls to other Hooks inside!\n\nNote\n\nIf your linter is configured for React, it will enforce this naming convention. Scroll up to the sandbox above and rename useOnlineStatus to getOnlineStatus. Notice that the linter won‚Äôt allow you to call useState or useEffect inside of it anymore. Only Hooks and components can call other Hooks!\n\nDEEP DIVE\nShould all functions called during rendering start with the use prefix? \nShow Details\nCustom Hooks let you share stateful logic, not state itself \n\nIn the earlier example, when you turned the network on and off, both components updated together. However, it‚Äôs wrong to think that a single isOnline state variable is shared between them. Look at this code:\n\nfunction StatusBar() {\n\n const isOnline = useOnlineStatus();\n\n // ...\n\n}\n\nfunction SaveButton() {\n\n const isOnline = useOnlineStatus();\n\n // ...\n\n}\n\nIt works the same way as before you extracted the duplication:\n\nfunction StatusBar() {\n\n const [isOnline, setIsOnline] = useState(true);\n\n useEffect(() => {\n\n // ...\n\n }, []);\n\n // ...\n\n}\n\nfunction SaveButton() {\n\n const [isOnline, setIsOnline] = useState(true);\n\n useEffect(() => {\n\n // ...\n\n }, []);\n\n // ...\n\n}\n\nThese are two completely independent state variables and Effects! They happened to have the same value at the same time because you synchronized them with the same external value (whether the network is on).\n\nTo better illustrate this, we‚Äôll need a different example. Consider this Form component:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function Form() {\n const [firstName, setFirstName] = useState('Mary');\n const [lastName, setLastName] = useState('Poppins');\n\n function handleFirstNameChange(e) {\n setFirstName(e.target.value);\n }\n\n function handleLastNameChange(e) {\n setLastName(e.target.value);\n }\n\n return (\n <>\n <label>\n First name:\n <input value={firstName} onChange={handleFirstNameChange} />\n </label>\n <label>\n Last name:\n <input value={lastName} onChange={handleLastNameChange} />\n </label>\n <p><b>Good morning, {firstName} {lastName}.</b></p>\n </>\n );\n}\n\nShow more\n\nThere‚Äôs some repetitive logic for each form field:\n\nThere‚Äôs a piece of state (firstName and lastName).\nThere‚Äôs a change handler (handleFirstNameChange and handleLastNameChange).\nThere‚Äôs a piece of JSX that specifies the value and onChange attributes for that input.\n\nYou can extract the repetitive logic into this useFormInput custom Hook:\n\nApp.js\nuseFormInput.js\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport function useFormInput(initialValue) {\n const [value, setValue] = useState(initialValue);\n\n function handleChange(e) {\n setValue(e.target.value);\n }\n\n const inputProps = {\n value: value,\n onChange: handleChange\n };\n\n return inputProps;\n}\n\nShow more\n\nNotice that it only declares one state variable called value.\n\nHowever, the Form component calls useFormInput two times:\n\nfunction Form() {\n\n const firstNameProps = useFormInput('Mary');\n\n const lastNameProps = useFormInput('Poppins');\n\n // ...\n\nThis is why it works like declaring two separate state variables!\n\nCustom Hooks let you share stateful logic but not state itself. Each call to a Hook is completely independent from every other call to the same Hook. This is why the two sandboxes above are completely equivalent. If you‚Äôd like, scroll back up and compare them. The behavior before and after extracting a custom Hook is identical.\n\nWhen you need to share the state itself between multiple components, lift it up and pass it down instead.\n\nPassing reactive values between Hooks \n\nThe code inside your custom Hooks will re-run during every re-render of your component. This is why, like components, custom Hooks need to be pure. Think of custom Hooks‚Äô code as part of your component‚Äôs body!\n\nBecause custom Hooks re-render together with your component, they always receive the latest props and state. To see what this means, consider this chat room example. Change the server URL or the chat room:\n\nApp.js\nChatRoom.js\nchat.js\nnotifications.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\nimport { showNotification } from './notifications.js';\n\nexport default function ChatRoom({ roomId }) {\n const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n useEffect(() => {\n const options = {\n serverUrl: serverUrl,\n roomId: roomId\n };\n const connection = createConnection(options);\n connection.on('message', (msg) => {\n showNotification('New message: ' + msg);\n });\n connection.connect();\n return () => connection.disconnect();\n }, [roomId, serverUrl]);\n\n return (\n <>\n <label>\n Server URL:\n <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />\n </label>\n <h1>Welcome to the {roomId} room!</h1>\n </>\n );\n}\n\nShow more\n\nWhen you change serverUrl or roomId, the Effect ‚Äúreacts‚Äù to your changes and re-synchronizes. You can tell by the console messages that the chat re-connects every time that you change your Effect‚Äôs dependencies.\n\nNow move the Effect‚Äôs code into a custom Hook:\n\nexport function useChatRoom({ serverUrl, roomId }) {\n\n useEffect(() => {\n\n const options = {\n\n serverUrl: serverUrl,\n\n roomId: roomId\n\n };\n\n const connection = createConnection(options);\n\n connection.connect();\n\n connection.on('message', (msg) => {\n\n showNotification('New message: ' + msg);\n\n });\n\n return () => connection.disconnect();\n\n }, [roomId, serverUrl]);\n\n}\n\nThis lets your ChatRoom component call your custom Hook without worrying about how it works inside:\n\nexport default function ChatRoom({ roomId }) {\n\n const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n useChatRoom({\n\n roomId: roomId,\n\n serverUrl: serverUrl\n\n });\n\n return (\n\n <>\n\n <label>\n\n Server URL:\n\n <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />\n\n </label>\n\n <h1>Welcome to the {roomId} room!</h1>\n\n </>\n\n );\n\n}\n\nThis looks much simpler! (But it does the same thing.)\n\nNotice that the logic still responds to prop and state changes. Try editing the server URL or the selected room:\n\nApp.js\nChatRoom.js\nuseChatRoom.js\nchat.js\nnotifications.js\nReload\nClear\nFork\nimport { useState } from 'react';\nimport { useChatRoom } from './useChatRoom.js';\n\nexport default function ChatRoom({ roomId }) {\n const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n useChatRoom({\n roomId: roomId,\n serverUrl: serverUrl\n });\n\n return (\n <>\n <label>\n Server URL:\n <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />\n </label>\n <h1>Welcome to the {roomId} room!</h1>\n </>\n );\n}\n\nShow more\n\nNotice how you‚Äôre taking the return value of one Hook:\n\nexport default function ChatRoom({ roomId }) {\n\n const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n useChatRoom({\n\n roomId: roomId,\n\n serverUrl: serverUrl\n\n });\n\n // ...\n\nand passing it as an input to another Hook:\n\nexport default function ChatRoom({ roomId }) {\n\n const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n useChatRoom({\n\n roomId: roomId,\n\n serverUrl: serverUrl\n\n });\n\n // ...\n\nEvery time your ChatRoom component re-renders, it passes the latest roomId and serverUrl to your Hook. This is why your Effect re-connects to the chat whenever their values are different after a re-render. (If you ever worked with audio or video processing software, chaining Hooks like this might remind you of chaining visual or audio effects. It‚Äôs as if the output of useState ‚Äúfeeds into‚Äù the input of the useChatRoom.)\n\nPassing event handlers to custom Hooks \n\nAs you start using useChatRoom in more components, you might want to let components customize its behavior. For example, currently, the logic for what to do when a message arrives is hardcoded inside the Hook:\n\nexport function useChatRoom({ serverUrl, roomId }) {\n\n useEffect(() => {\n\n const options = {\n\n serverUrl: serverUrl,\n\n roomId: roomId\n\n };\n\n const connection = createConnection(options);\n\n connection.connect();\n\n connection.on('message', (msg) => {\n\n showNotification('New message: ' + msg);\n\n });\n\n return () => connection.disconnect();\n\n }, [roomId, serverUrl]);\n\n}\n\nLet‚Äôs say you want to move this logic back to your component:\n\nexport default function ChatRoom({ roomId }) {\n\n const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n useChatRoom({\n\n roomId: roomId,\n\n serverUrl: serverUrl,\n\n onReceiveMessage(msg) {\n\n showNotification('New message: ' + msg);\n\n }\n\n });\n\n // ...\n\nTo make this work, change your custom Hook to take onReceiveMessage as one of its named options:\n\nexport function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {\n\n useEffect(() => {\n\n const options = {\n\n serverUrl: serverUrl,\n\n roomId: roomId\n\n };\n\n const connection = createConnection(options);\n\n connection.connect();\n\n connection.on('message', (msg) => {\n\n onReceiveMessage(msg);\n\n });\n\n return () => connection.disconnect();\n\n }, [roomId, serverUrl, onReceiveMessage]); // ‚úÖ All dependencies declared\n\n}\n\nThis will work, but there‚Äôs one more improvement you can do when your custom Hook accepts event handlers.\n\nAdding a dependency on onReceiveMessage is not ideal because it will cause the chat to re-connect every time the component re-renders. Wrap this event handler into an Effect Event to remove it from the dependencies:\n\nimport { useEffect, useEffectEvent } from 'react';\n\n// ...\n\nexport function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {\n\n const onMessage = useEffectEvent(onReceiveMessage);\n\n useEffect(() => {\n\n const options = {\n\n serverUrl: serverUrl,\n\n roomId: roomId\n\n };\n\n const connection = createConnection(options);\n\n connection.connect();\n\n connection.on('message', (msg) => {\n\n onMessage(msg);\n\n });\n\n return () => connection.disconnect();\n\n }, [roomId, serverUrl]); // ‚úÖ All dependencies declared\n\n}\n\nNow the chat won‚Äôt re-connect every time that the ChatRoom component re-renders. Here is a fully working demo of passing an event handler to a custom Hook that you can play with:\n\nApp.js\nChatRoom.js\nuseChatRoom.js\nchat.js\nnotifications.js\nReload\nClear\nFork\nimport { useState } from 'react';\nimport { useChatRoom } from './useChatRoom.js';\nimport { showNotification } from './notifications.js';\n\nexport default function ChatRoom({ roomId }) {\n const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n useChatRoom({\n roomId: roomId,\n serverUrl: serverUrl,\n onReceiveMessage(msg) {\n showNotification('New message: ' + msg);\n }\n });\n\n return (\n <>\n <label>\n Server URL:\n <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />\n </label>\n <h1>Welcome to the {roomId} room!</h1>\n </>\n );\n}\n\nShow more\n\nNotice how you no longer need to know how useChatRoom works in order to use it. You could add it to any other component, pass any other options, and it would work the same way. That‚Äôs the power of custom Hooks.\n\nWhen to use custom Hooks \n\nYou don‚Äôt need to extract a custom Hook for every little duplicated bit of code. Some duplication is fine. For example, extracting a useFormInput Hook to wrap a single useState call like earlier is probably unnecessary.\n\nHowever, whenever you write an Effect, consider whether it would be clearer to also wrap it in a custom Hook. You shouldn‚Äôt need Effects very often, so if you‚Äôre writing one, it means that you need to ‚Äústep outside React‚Äù to synchronize with some external system or to do something that React doesn‚Äôt have a built-in API for. Wrapping it into a custom Hook lets you precisely communicate your intent and how the data flows through it.\n\nFor example, consider a ShippingForm component that displays two dropdowns: one shows the list of cities, and another shows the list of areas in the selected city. You might start with some code that looks like this:\n\nfunction ShippingForm({ country }) {\n\n const [cities, setCities] = useState(null);\n\n // This Effect fetches cities for a country\n\n useEffect(() => {\n\n let ignore = false;\n\n fetch(`/api/cities?country=${country}`)\n\n .then(response => response.json())\n\n .then(json => {\n\n if (!ignore) {\n\n setCities(json);\n\n }\n\n });\n\n return () => {\n\n ignore = true;\n\n };\n\n }, [country]);\n\n const [city, setCity] = useState(null);\n\n const [areas, setAreas] = useState(null);\n\n // This Effect fetches areas for the selected city\n\n useEffect(() => {\n\n if (city) {\n\n let ignore = false;\n\n fetch(`/api/areas?city=${city}`)\n\n .then(response => response.json())\n\n .then(json => {\n\n if (!ignore) {\n\n setAreas(json);\n\n }\n\n });\n\n return () => {\n\n ignore = true;\n\n };\n\n }\n\n }, [city]);\n\n // ...\n\nAlthough this code is quite repetitive, it‚Äôs correct to keep these Effects separate from each other. They synchronize two different things, so you shouldn‚Äôt merge them into one Effect. Instead, you can simplify the ShippingForm component above by extracting the common logic between them into your own useData Hook:\n\nfunction useData(url) {\n\n const [data, setData] = useState(null);\n\n useEffect(() => {\n\n if (url) {\n\n let ignore = false;\n\n fetch(url)\n\n .then(response => response.json())\n\n .then(json => {\n\n if (!ignore) {\n\n setData(json);\n\n }\n\n });\n\n return () => {\n\n ignore = true;\n\n };\n\n }\n\n }, [url]);\n\n return data;\n\n}\n\nNow you can replace both Effects in the ShippingForm components with calls to useData:\n\nfunction ShippingForm({ country }) {\n\n const cities = useData(`/api/cities?country=${country}`);\n\n const [city, setCity] = useState(null);\n\n const areas = useData(city ? `/api/areas?city=${city}` : null);\n\n // ...\n\nExtracting a custom Hook makes the data flow explicit. You feed the url in and you get the data out. By ‚Äúhiding‚Äù your Effect inside useData, you also prevent someone working on the ShippingForm component from adding unnecessary dependencies to it. With time, most of your app‚Äôs Effects will be in custom Hooks.\n\nDEEP DIVE\nKeep your custom Hooks focused on concrete high-level use cases \nShow Details\nCustom Hooks help you migrate to better patterns \n\nEffects are an ‚Äúescape hatch‚Äù: you use them when you need to ‚Äústep outside React‚Äù and when there is no better built-in solution for your use case. With time, the React team‚Äôs goal is to reduce the number of the Effects in your app to the minimum by providing more specific solutions to more specific problems. Wrapping your Effects in custom Hooks makes it easier to upgrade your code when these solutions become available.\n\nLet‚Äôs return to this example:\n\nApp.js\nuseOnlineStatus.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\n\nexport function useOnlineStatus() {\n const [isOnline, setIsOnline] = useState(true);\n useEffect(() => {\n function handleOnline() {\n setIsOnline(true);\n }\n function handleOffline() {\n setIsOnline(false);\n }\n window.addEventListener('online', handleOnline);\n window.addEventListener('offline', handleOffline);\n return () => {\n window.removeEventListener('online', handleOnline);\n window.removeEventListener('offline', handleOffline);\n };\n }, []);\n return isOnline;\n}\n\nShow more\n\nIn the above example, useOnlineStatus is implemented with a pair of useState and useEffect. However, this isn‚Äôt the best possible solution. There is a number of edge cases it doesn‚Äôt consider. For example, it assumes that when the component mounts, isOnline is already true, but this may be wrong if the network already went offline. You can use the browser navigator.onLine API to check for that, but using it directly would not work on the server for generating the initial HTML. In short, this code could be improved.\n\nReact includes a dedicated API called useSyncExternalStore which takes care of all of these problems for you. Here is your useOnlineStatus Hook, rewritten to take advantage of this new API:\n\nApp.js\nuseOnlineStatus.js\nReload\nClear\nFork\nimport { useSyncExternalStore } from 'react';\n\nfunction subscribe(callback) {\n window.addEventListener('online', callback);\n window.addEventListener('offline', callback);\n return () => {\n window.removeEventListener('online', callback);\n window.removeEventListener('offline', callback);\n };\n}\n\nexport function useOnlineStatus() {\n return useSyncExternalStore(\n subscribe,\n () => navigator.onLine, // How to get the value on the client\n () => true // How to get the value on the server\n );\n}\n\nShow more\n\nNotice how you didn‚Äôt need to change any of the components to make this migration:\n\nfunction StatusBar() {\n\n const isOnline = useOnlineStatus();\n\n // ...\n\n}\n\nfunction SaveButton() {\n\n const isOnline = useOnlineStatus();\n\n // ...\n\n}\n\nThis is another reason for why wrapping Effects in custom Hooks is often beneficial:\n\nYou make the data flow to and from your Effects very explicit.\nYou let your components focus on the intent rather than on the exact implementation of your Effects.\nWhen React adds new features, you can remove those Effects without changing any of your components.\n\nSimilar to a design system, you might find it helpful to start extracting common idioms from your app‚Äôs components into custom Hooks. This will keep your components‚Äô code focused on the intent, and let you avoid writing raw Effects very often. Many excellent custom Hooks are maintained by the React community.\n\nDEEP DIVE\nWill React provide any built-in solution for data fetching? \nShow Details\nThere is more than one way to do it \n\nLet‚Äôs say you want to implement a fade-in animation from scratch using the browser requestAnimationFrame API. You might start with an Effect that sets up an animation loop. During each frame of the animation, you could change the opacity of the DOM node you hold in a ref until it reaches 1. Your code might start like this:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState, useEffect, useRef } from 'react';\n\nfunction Welcome() {\n const ref = useRef(null);\n\n useEffect(() => {\n const duration = 1000;\n const node = ref.current;\n\n let startTime = performance.now();\n let frameId = null;\n\n function onFrame(now) {\n const timePassed = now - startTime;\n const progress = Math.min(timePassed / duration, 1);\n onProgress(progress);\n if (progress < 1) {\n // We still have more frames to paint\n frameId = requestAnimationFrame(onFrame);\n }\n }\n\n function onProgress(progress) {\n node.style.opacity = progress;\n }\n\n function start() {\n onProgress(0);\n startTime = performance.now();\n frameId = requestAnimationFrame(onFrame);\n }\n\n function stop() {\n cancelAnimationFrame(frameId);\n startTime = null;\n frameId = null;\n }\n\n start();\n return () => stop();\n }, []);\n\n return (\n <h1 className=\"welcome\" ref={ref}>\n Welcome\n </h1>\n );\n}\n\nexport default function App() {\n const [show, setShow] = useState(false);\n return (\n <>\n <button onClick={() => setShow(!show)}>\n {show ? 'Remove' : 'Show'}\n </button>\n <hr />\n {show && <Welcome />}\n </>\n );\n}\n\nShow more\n\nTo make the component more readable, you might extract the logic into a useFadeIn custom Hook:\n\nApp.js\nuseFadeIn.js\nReload\nClear\nFork\nimport { useState, useEffect, useRef } from 'react';\nimport { useFadeIn } from './useFadeIn.js';\n\nfunction Welcome() {\n const ref = useRef(null);\n\n useFadeIn(ref, 1000);\n\n return (\n <h1 className=\"welcome\" ref={ref}>\n Welcome\n </h1>\n );\n}\n\nexport default function App() {\n const [show, setShow] = useState(false);\n return (\n <>\n <button onClick={() => setShow(!show)}>\n {show ? 'Remove' : 'Show'}\n </button>\n <hr />\n {show && <Welcome />}\n </>\n );\n}\n\nShow more\n\nYou could keep the useFadeIn code as is, but you could also refactor it more. For example, you could extract the logic for setting up the animation loop out of useFadeIn into a custom useAnimationLoop Hook:\n\nApp.js\nuseFadeIn.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { useEffectEvent } from 'react';\n\nexport function useFadeIn(ref, duration) {\n const [isRunning, setIsRunning] = useState(true);\n\n useAnimationLoop(isRunning, (timePassed) => {\n const progress = Math.min(timePassed / duration, 1);\n ref.current.style.opacity = progress;\n if (progress === 1) {\n setIsRunning(false);\n }\n });\n}\n\nfunction useAnimationLoop(isRunning, drawFrame) {\n const onFrame = useEffectEvent(drawFrame);\n\n useEffect(() => {\n if (!isRunning) {\n return;\n }\n\n const startTime = performance.now();\n let frameId = null;\n\n function tick(now) {\n const timePassed = now - startTime;\n onFrame(timePassed);\n frameId = requestAnimationFrame(tick);\n }\n\n tick();\n return () => cancelAnimationFrame(frameId);\n }, [isRunning]);\n}\n\nShow more\n\nHowever, you didn‚Äôt have to do that. As with regular functions, ultimately you decide where to draw the boundaries between different parts of your code. You could also take a very different approach. Instead of keeping the logic in the Effect, you could move most of the imperative logic inside a JavaScript class:\n\nApp.js\nuseFadeIn.js\nanimation.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { FadeInAnimation } from './animation.js';\n\nexport function useFadeIn(ref, duration) {\n useEffect(() => {\n const animation = new FadeInAnimation(ref.current);\n animation.start(duration);\n return () => {\n animation.stop();\n };\n }, [ref, duration]);\n}\n\nEffects let you connect React to external systems. The more coordination between Effects is needed (for example, to chain multiple animations), the more it makes sense to extract that logic out of Effects and Hooks completely like in the sandbox above. Then, the code you extracted becomes the ‚Äúexternal system‚Äù. This lets your Effects stay simple because they only need to send messages to the system you‚Äôve moved outside React.\n\nThe examples above assume that the fade-in logic needs to be written in JavaScript. However, this particular fade-in animation is both simpler and much more efficient to implement with a plain CSS Animation:\n\nApp.js\nwelcome.css\nReload\nClear\nFork\n.welcome {\n color: white;\n padding: 50px;\n text-align: center;\n font-size: 50px;\n background-image: radial-gradient(circle, rgba(63,94,251,1) 0%, rgba(252,70,107,1) 100%);\n\n animation: fadeIn 1000ms;\n}\n\n@keyframes fadeIn {\n 0% { opacity: 0; }\n 100% { opacity: 1; }\n}\n\nSometimes, you don‚Äôt even need a Hook!\n\nRecap\nCustom Hooks let you share logic between components.\nCustom Hooks must be named starting with use followed by a capital letter.\nCustom Hooks only share stateful logic, not state itself.\nYou can pass reactive values from one Hook to another, and they stay up-to-date.\nAll Hooks re-run every time your component re-renders.\nThe code of your custom Hooks should be pure, like your component‚Äôs code.\nWrap event handlers received by custom Hooks into Effect Events.\nDon‚Äôt create custom Hooks like useMount. Keep their purpose specific.\nIt‚Äôs up to you how and where to choose the boundaries of your code.\nTry out some challenges\n1. Extract a useCounter Hook\n2. Make the counter delay configurable\n3. Extract useInterval out of useCounter\n4. Fix a resetting interval\n5. Implement a staggering movement\nChallenge 1 of 5: Extract a useCounter Hook \n\nThis component uses a state variable and an Effect to display a number that increments every second. Extract this logic into a custom Hook called useCounter. Your goal is to make the Counter component implementation look exactly like this:\n\nexport default function Counter() {\n\n const count = useCounter();\n\n return <h1>Seconds passed: {count}</h1>;\n\n}\n\nYou‚Äôll need to write your custom Hook in useCounter.js and import it into the App.js file.\n\nApp.js\nuseCounter.js\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\n\nexport default function Counter() {\n const [count, setCount] = useState(0);\n useEffect(() => {\n const id = setInterval(() => {\n setCount(c => c + 1);\n }, 1000);\n return () => clearInterval(id);\n }, []);\n return <h1>Seconds passed: {count}</h1>;\n}\n\nShow solution\nNext Challenge\nPREVIOUS\nRemoving Effect Dependencies",
      "tables": [],
      "code_blocks": [
        "import { useState, useEffect } from 'react';\n\nexport default function SaveButton() {\n  const [isOnline, setIsOnline] = useState(true);\n  useEffect(() => {\n    function handleOnline() {\n      setIsOnline(true);\n    }\n    function handleOffline() {\n      setIsOnline(false);\n    }\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n\n  function handleSaveClick() {\n    console.log('‚úÖ Progress saved');\n  }\n\n  return (\n    <button disabled={!isOnline} onClick={handleSaveClick}>\n      {isOnline ? 'Save progress' : 'Reconnecting...'}\n    </button>\n  );\n}",
        "useOnlineStatus",
        "function StatusBar() {\n\n  const isOnline = useOnlineStatus();\n\n  return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>;\n\n}\n\n\n\nfunction SaveButton() {\n\n  const isOnline = useOnlineStatus();\n\n\n\n  function handleSaveClick() {\n\n    console.log('‚úÖ Progress saved');\n\n  }\n\n\n\n  return (\n\n    <button disabled={!isOnline} onClick={handleSaveClick}>\n\n      {isOnline ? 'Save progress' : 'Reconnecting...'}\n\n    </button>\n\n  );\n\n}",
        "function StatusBar() {\n\n  const isOnline = useOnlineStatus();\n\n  return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>;\n\n}\n\n\n\nfunction SaveButton() {\n\n  const isOnline = useOnlineStatus();\n\n\n\n  function handleSaveClick() {\n\n    console.log('‚úÖ Progress saved');\n\n  }\n\n\n\n  return (\n\n    <button disabled={!isOnline} onClick={handleSaveClick}>\n\n      {isOnline ? 'Save progress' : 'Reconnecting...'}\n\n    </button>\n\n  );\n\n}",
        "useOnlineStatus",
        "function useOnlineStatus() {\n\n  const [isOnline, setIsOnline] = useState(true);\n\n  useEffect(() => {\n\n    function handleOnline() {\n\n      setIsOnline(true);\n\n    }\n\n    function handleOffline() {\n\n      setIsOnline(false);\n\n    }\n\n    window.addEventListener('online', handleOnline);\n\n    window.addEventListener('offline', handleOffline);\n\n    return () => {\n\n      window.removeEventListener('online', handleOnline);\n\n      window.removeEventListener('offline', handleOffline);\n\n    };\n\n  }, []);\n\n  return isOnline;\n\n}",
        "function useOnlineStatus() {\n\n  const [isOnline, setIsOnline] = useState(true);\n\n  useEffect(() => {\n\n    function handleOnline() {\n\n      setIsOnline(true);\n\n    }\n\n    function handleOffline() {\n\n      setIsOnline(false);\n\n    }\n\n    window.addEventListener('online', handleOnline);\n\n    window.addEventListener('offline', handleOffline);\n\n    return () => {\n\n      window.removeEventListener('online', handleOnline);\n\n      window.removeEventListener('offline', handleOffline);\n\n    };\n\n  }, []);\n\n  return isOnline;\n\n}",
        "import { useOnlineStatus } from './useOnlineStatus.js';\n\nfunction StatusBar() {\n  const isOnline = useOnlineStatus();\n  return <h1>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1>;\n}\n\nfunction SaveButton() {\n  const isOnline = useOnlineStatus();\n\n  function handleSaveClick() {\n    console.log('‚úÖ Progress saved');\n  }\n\n  return (\n    <button disabled={!isOnline} onClick={handleSaveClick}>\n      {isOnline ? 'Save progress' : 'Reconnecting...'}\n    </button>\n  );\n}\n\nexport default function App() {\n  return (\n    <>\n      <SaveButton />\n      <StatusBar />\n    </>\n  );\n}",
        "useOnlineStatus",
        "useOnlineStatus()",
        "useOnlineStatus",
        "getOnlineStatus",
        "function StatusBar() {\n\n  const isOnline = useOnlineStatus();\n\n  // ...\n\n}\n\n\n\nfunction SaveButton() {\n\n  const isOnline = useOnlineStatus();\n\n  // ...\n\n}",
        "function StatusBar() {\n\n  const isOnline = useOnlineStatus();\n\n  // ...\n\n}\n\n\n\nfunction SaveButton() {\n\n  const isOnline = useOnlineStatus();\n\n  // ...\n\n}",
        "function StatusBar() {\n\n  const [isOnline, setIsOnline] = useState(true);\n\n  useEffect(() => {\n\n    // ...\n\n  }, []);\n\n  // ...\n\n}\n\n\n\nfunction SaveButton() {\n\n  const [isOnline, setIsOnline] = useState(true);\n\n  useEffect(() => {\n\n    // ...\n\n  }, []);\n\n  // ...\n\n}",
        "function StatusBar() {\n\n  const [isOnline, setIsOnline] = useState(true);\n\n  useEffect(() => {\n\n    // ...\n\n  }, []);\n\n  // ...\n\n}\n\n\n\nfunction SaveButton() {\n\n  const [isOnline, setIsOnline] = useState(true);\n\n  useEffect(() => {\n\n    // ...\n\n  }, []);\n\n  // ...\n\n}",
        "import { useState } from 'react';\n\nexport default function Form() {\n  const [firstName, setFirstName] = useState('Mary');\n  const [lastName, setLastName] = useState('Poppins');\n\n  function handleFirstNameChange(e) {\n    setFirstName(e.target.value);\n  }\n\n  function handleLastNameChange(e) {\n    setLastName(e.target.value);\n  }\n\n  return (\n    <>\n      <label>\n        First name:\n        <input value={firstName} onChange={handleFirstNameChange} />\n      </label>\n      <label>\n        Last name:\n        <input value={lastName} onChange={handleLastNameChange} />\n      </label>\n      <p><b>Good morning, {firstName} {lastName}.</b></p>\n    </>\n  );\n}",
        "handleFirstNameChange",
        "handleLastNameChange",
        "useFormInput",
        "import { useState } from 'react';\n\nexport function useFormInput(initialValue) {\n  const [value, setValue] = useState(initialValue);\n\n  function handleChange(e) {\n    setValue(e.target.value);\n  }\n\n  const inputProps = {\n    value: value,\n    onChange: handleChange\n  };\n\n  return inputProps;\n}",
        "useFormInput",
        "function Form() {\n\n  const firstNameProps = useFormInput('Mary');\n\n  const lastNameProps = useFormInput('Poppins');\n\n  // ...",
        "function Form() {\n\n  const firstNameProps = useFormInput('Mary');\n\n  const lastNameProps = useFormInput('Poppins');\n\n  // ...",
        "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\nimport { showNotification } from './notifications.js';\n\nexport default function ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n  useEffect(() => {\n    const options = {\n      serverUrl: serverUrl,\n      roomId: roomId\n    };\n    const connection = createConnection(options);\n    connection.on('message', (msg) => {\n      showNotification('New message: ' + msg);\n    });\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId, serverUrl]);\n\n  return (\n    <>\n      <label>\n        Server URL:\n        <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n    </>\n  );\n}",
        "export function useChatRoom({ serverUrl, roomId }) {\n\n  useEffect(() => {\n\n    const options = {\n\n      serverUrl: serverUrl,\n\n      roomId: roomId\n\n    };\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    connection.on('message', (msg) => {\n\n      showNotification('New message: ' + msg);\n\n    });\n\n    return () => connection.disconnect();\n\n  }, [roomId, serverUrl]);\n\n}",
        "export function useChatRoom({ serverUrl, roomId }) {\n\n  useEffect(() => {\n\n    const options = {\n\n      serverUrl: serverUrl,\n\n      roomId: roomId\n\n    };\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    connection.on('message', (msg) => {\n\n      showNotification('New message: ' + msg);\n\n    });\n\n    return () => connection.disconnect();\n\n  }, [roomId, serverUrl]);\n\n}",
        "export default function ChatRoom({ roomId }) {\n\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n\n\n  useChatRoom({\n\n    roomId: roomId,\n\n    serverUrl: serverUrl\n\n  });\n\n\n\n  return (\n\n    <>\n\n      <label>\n\n        Server URL:\n\n        <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />\n\n      </label>\n\n      <h1>Welcome to the {roomId} room!</h1>\n\n    </>\n\n  );\n\n}",
        "export default function ChatRoom({ roomId }) {\n\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n\n\n  useChatRoom({\n\n    roomId: roomId,\n\n    serverUrl: serverUrl\n\n  });\n\n\n\n  return (\n\n    <>\n\n      <label>\n\n        Server URL:\n\n        <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />\n\n      </label>\n\n      <h1>Welcome to the {roomId} room!</h1>\n\n    </>\n\n  );\n\n}",
        "import { useState } from 'react';\nimport { useChatRoom } from './useChatRoom.js';\n\nexport default function ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n  useChatRoom({\n    roomId: roomId,\n    serverUrl: serverUrl\n  });\n\n  return (\n    <>\n      <label>\n        Server URL:\n        <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n    </>\n  );\n}",
        "export default function ChatRoom({ roomId }) {\n\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n\n\n  useChatRoom({\n\n    roomId: roomId,\n\n    serverUrl: serverUrl\n\n  });\n\n  // ...",
        "export default function ChatRoom({ roomId }) {\n\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n\n\n  useChatRoom({\n\n    roomId: roomId,\n\n    serverUrl: serverUrl\n\n  });\n\n  // ...",
        "export default function ChatRoom({ roomId }) {\n\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n\n\n  useChatRoom({\n\n    roomId: roomId,\n\n    serverUrl: serverUrl\n\n  });\n\n  // ...",
        "export default function ChatRoom({ roomId }) {\n\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n\n\n  useChatRoom({\n\n    roomId: roomId,\n\n    serverUrl: serverUrl\n\n  });\n\n  // ...",
        "useChatRoom",
        "useChatRoom",
        "export function useChatRoom({ serverUrl, roomId }) {\n\n  useEffect(() => {\n\n    const options = {\n\n      serverUrl: serverUrl,\n\n      roomId: roomId\n\n    };\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    connection.on('message', (msg) => {\n\n      showNotification('New message: ' + msg);\n\n    });\n\n    return () => connection.disconnect();\n\n  }, [roomId, serverUrl]);\n\n}",
        "export function useChatRoom({ serverUrl, roomId }) {\n\n  useEffect(() => {\n\n    const options = {\n\n      serverUrl: serverUrl,\n\n      roomId: roomId\n\n    };\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    connection.on('message', (msg) => {\n\n      showNotification('New message: ' + msg);\n\n    });\n\n    return () => connection.disconnect();\n\n  }, [roomId, serverUrl]);\n\n}",
        "export default function ChatRoom({ roomId }) {\n\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n\n\n  useChatRoom({\n\n    roomId: roomId,\n\n    serverUrl: serverUrl,\n\n    onReceiveMessage(msg) {\n\n      showNotification('New message: ' + msg);\n\n    }\n\n  });\n\n  // ...",
        "export default function ChatRoom({ roomId }) {\n\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n\n\n  useChatRoom({\n\n    roomId: roomId,\n\n    serverUrl: serverUrl,\n\n    onReceiveMessage(msg) {\n\n      showNotification('New message: ' + msg);\n\n    }\n\n  });\n\n  // ...",
        "onReceiveMessage",
        "export function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {\n\n  useEffect(() => {\n\n    const options = {\n\n      serverUrl: serverUrl,\n\n      roomId: roomId\n\n    };\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    connection.on('message', (msg) => {\n\n      onReceiveMessage(msg);\n\n    });\n\n    return () => connection.disconnect();\n\n  }, [roomId, serverUrl, onReceiveMessage]); // ‚úÖ All dependencies declared\n\n}",
        "export function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {\n\n  useEffect(() => {\n\n    const options = {\n\n      serverUrl: serverUrl,\n\n      roomId: roomId\n\n    };\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    connection.on('message', (msg) => {\n\n      onReceiveMessage(msg);\n\n    });\n\n    return () => connection.disconnect();\n\n  }, [roomId, serverUrl, onReceiveMessage]); // ‚úÖ All dependencies declared\n\n}",
        "onReceiveMessage",
        "import { useEffect, useEffectEvent } from 'react';\n\n// ...\n\n\n\nexport function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {\n\n  const onMessage = useEffectEvent(onReceiveMessage);\n\n\n\n  useEffect(() => {\n\n    const options = {\n\n      serverUrl: serverUrl,\n\n      roomId: roomId\n\n    };\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    connection.on('message', (msg) => {\n\n      onMessage(msg);\n\n    });\n\n    return () => connection.disconnect();\n\n  }, [roomId, serverUrl]); // ‚úÖ All dependencies declared\n\n}",
        "import { useEffect, useEffectEvent } from 'react';\n\n// ...\n\n\n\nexport function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {\n\n  const onMessage = useEffectEvent(onReceiveMessage);\n\n\n\n  useEffect(() => {\n\n    const options = {\n\n      serverUrl: serverUrl,\n\n      roomId: roomId\n\n    };\n\n    const connection = createConnection(options);\n\n    connection.connect();\n\n    connection.on('message', (msg) => {\n\n      onMessage(msg);\n\n    });\n\n    return () => connection.disconnect();\n\n  }, [roomId, serverUrl]); // ‚úÖ All dependencies declared\n\n}",
        "import { useState } from 'react';\nimport { useChatRoom } from './useChatRoom.js';\nimport { showNotification } from './notifications.js';\n\nexport default function ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n  useChatRoom({\n    roomId: roomId,\n    serverUrl: serverUrl,\n    onReceiveMessage(msg) {\n      showNotification('New message: ' + msg);\n    }\n  });\n\n  return (\n    <>\n      <label>\n        Server URL:\n        <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n    </>\n  );\n}",
        "useChatRoom",
        "useFormInput",
        "ShippingForm",
        "function ShippingForm({ country }) {\n\n  const [cities, setCities] = useState(null);\n\n  // This Effect fetches cities for a country\n\n  useEffect(() => {\n\n    let ignore = false;\n\n    fetch(`/api/cities?country=${country}`)\n\n      .then(response => response.json())\n\n      .then(json => {\n\n        if (!ignore) {\n\n          setCities(json);\n\n        }\n\n      });\n\n    return () => {\n\n      ignore = true;\n\n    };\n\n  }, [country]);\n\n\n\n  const [city, setCity] = useState(null);\n\n  const [areas, setAreas] = useState(null);\n\n  // This Effect fetches areas for the selected city\n\n  useEffect(() => {\n\n    if (city) {\n\n      let ignore = false;\n\n      fetch(`/api/areas?city=${city}`)\n\n        .then(response => response.json())\n\n        .then(json => {\n\n          if (!ignore) {\n\n            setAreas(json);\n\n          }\n\n        });\n\n      return () => {\n\n        ignore = true;\n\n      };\n\n    }\n\n  }, [city]);\n\n\n\n  // ...",
        "function ShippingForm({ country }) {\n\n  const [cities, setCities] = useState(null);\n\n  // This Effect fetches cities for a country\n\n  useEffect(() => {\n\n    let ignore = false;\n\n    fetch(`/api/cities?country=${country}`)\n\n      .then(response => response.json())\n\n      .then(json => {\n\n        if (!ignore) {\n\n          setCities(json);\n\n        }\n\n      });\n\n    return () => {\n\n      ignore = true;\n\n    };\n\n  }, [country]);\n\n\n\n  const [city, setCity] = useState(null);\n\n  const [areas, setAreas] = useState(null);\n\n  // This Effect fetches areas for the selected city\n\n  useEffect(() => {\n\n    if (city) {\n\n      let ignore = false;\n\n      fetch(`/api/areas?city=${city}`)\n\n        .then(response => response.json())\n\n        .then(json => {\n\n          if (!ignore) {\n\n            setAreas(json);\n\n          }\n\n        });\n\n      return () => {\n\n        ignore = true;\n\n      };\n\n    }\n\n  }, [city]);\n\n\n\n  // ...",
        "ShippingForm",
        "function useData(url) {\n\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n\n    if (url) {\n\n      let ignore = false;\n\n      fetch(url)\n\n        .then(response => response.json())\n\n        .then(json => {\n\n          if (!ignore) {\n\n            setData(json);\n\n          }\n\n        });\n\n      return () => {\n\n        ignore = true;\n\n      };\n\n    }\n\n  }, [url]);\n\n  return data;\n\n}",
        "function useData(url) {\n\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n\n    if (url) {\n\n      let ignore = false;\n\n      fetch(url)\n\n        .then(response => response.json())\n\n        .then(json => {\n\n          if (!ignore) {\n\n            setData(json);\n\n          }\n\n        });\n\n      return () => {\n\n        ignore = true;\n\n      };\n\n    }\n\n  }, [url]);\n\n  return data;\n\n}",
        "ShippingForm",
        "function ShippingForm({ country }) {\n\n  const cities = useData(`/api/cities?country=${country}`);\n\n  const [city, setCity] = useState(null);\n\n  const areas = useData(city ? `/api/areas?city=${city}` : null);\n\n  // ...",
        "function ShippingForm({ country }) {\n\n  const cities = useData(`/api/cities?country=${country}`);\n\n  const [city, setCity] = useState(null);\n\n  const areas = useData(city ? `/api/areas?city=${city}` : null);\n\n  // ...",
        "ShippingForm",
        "import { useState, useEffect } from 'react';\n\nexport function useOnlineStatus() {\n  const [isOnline, setIsOnline] = useState(true);\n  useEffect(() => {\n    function handleOnline() {\n      setIsOnline(true);\n    }\n    function handleOffline() {\n      setIsOnline(false);\n    }\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n  return isOnline;\n}",
        "useOnlineStatus",
        "navigator.onLine",
        "useSyncExternalStore",
        "useOnlineStatus",
        "import { useSyncExternalStore } from 'react';\n\nfunction subscribe(callback) {\n  window.addEventListener('online', callback);\n  window.addEventListener('offline', callback);\n  return () => {\n    window.removeEventListener('online', callback);\n    window.removeEventListener('offline', callback);\n  };\n}\n\nexport function useOnlineStatus() {\n  return useSyncExternalStore(\n    subscribe,\n    () => navigator.onLine, // How to get the value on the client\n    () => true // How to get the value on the server\n  );\n}",
        "function StatusBar() {\n\n  const isOnline = useOnlineStatus();\n\n  // ...\n\n}\n\n\n\nfunction SaveButton() {\n\n  const isOnline = useOnlineStatus();\n\n  // ...\n\n}",
        "function StatusBar() {\n\n  const isOnline = useOnlineStatus();\n\n  // ...\n\n}\n\n\n\nfunction SaveButton() {\n\n  const isOnline = useOnlineStatus();\n\n  // ...\n\n}",
        "requestAnimationFrame",
        "import { useState, useEffect, useRef } from 'react';\n\nfunction Welcome() {\n  const ref = useRef(null);\n\n  useEffect(() => {\n    const duration = 1000;\n    const node = ref.current;\n\n    let startTime = performance.now();\n    let frameId = null;\n\n    function onFrame(now) {\n      const timePassed = now - startTime;\n      const progress = Math.min(timePassed / duration, 1);\n      onProgress(progress);\n      if (progress < 1) {\n        // We still have more frames to paint\n        frameId = requestAnimationFrame(onFrame);\n      }\n    }\n\n    function onProgress(progress) {\n      node.style.opacity = progress;\n    }\n\n    function start() {\n      onProgress(0);\n      startTime = performance.now();\n      frameId = requestAnimationFrame(onFrame);\n    }\n\n    function stop() {\n      cancelAnimationFrame(frameId);\n      startTime = null;\n      frameId = null;\n    }\n\n    start();\n    return () => stop();\n  }, []);\n\n  return (\n    <h1 className=\"welcome\" ref={ref}>\n      Welcome\n    </h1>\n  );\n}\n\nexport default function App() {\n  const [show, setShow] = useState(false);\n  return (\n    <>\n      <button onClick={() => setShow(!show)}>\n        {show ? 'Remove' : 'Show'}\n      </button>\n      <hr />\n      {show && <Welcome />}\n    </>\n  );\n}",
        "import { useState, useEffect, useRef } from 'react';\nimport { useFadeIn } from './useFadeIn.js';\n\nfunction Welcome() {\n  const ref = useRef(null);\n\n  useFadeIn(ref, 1000);\n\n  return (\n    <h1 className=\"welcome\" ref={ref}>\n      Welcome\n    </h1>\n  );\n}\n\nexport default function App() {\n  const [show, setShow] = useState(false);\n  return (\n    <>\n      <button onClick={() => setShow(!show)}>\n        {show ? 'Remove' : 'Show'}\n      </button>\n      <hr />\n      {show && <Welcome />}\n    </>\n  );\n}",
        "useAnimationLoop",
        "import { useState, useEffect } from 'react';\nimport { useEffectEvent } from 'react';\n\nexport function useFadeIn(ref, duration) {\n  const [isRunning, setIsRunning] = useState(true);\n\n  useAnimationLoop(isRunning, (timePassed) => {\n    const progress = Math.min(timePassed / duration, 1);\n    ref.current.style.opacity = progress;\n    if (progress === 1) {\n      setIsRunning(false);\n    }\n  });\n}\n\nfunction useAnimationLoop(isRunning, drawFrame) {\n  const onFrame = useEffectEvent(drawFrame);\n\n  useEffect(() => {\n    if (!isRunning) {\n      return;\n    }\n\n    const startTime = performance.now();\n    let frameId = null;\n\n    function tick(now) {\n      const timePassed = now - startTime;\n      onFrame(timePassed);\n      frameId = requestAnimationFrame(tick);\n    }\n\n    tick();\n    return () => cancelAnimationFrame(frameId);\n  }, [isRunning]);\n}",
        "import { useState, useEffect } from 'react';\nimport { FadeInAnimation } from './animation.js';\n\nexport function useFadeIn(ref, duration) {\n  useEffect(() => {\n    const animation = new FadeInAnimation(ref.current);\n    animation.start(duration);\n    return () => {\n      animation.stop();\n    };\n  }, [ref, duration]);\n}",
        ".welcome {\n  color: white;\n  padding: 50px;\n  text-align: center;\n  font-size: 50px;\n  background-image: radial-gradient(circle, rgba(63,94,251,1) 0%, rgba(252,70,107,1) 100%);\n\n  animation: fadeIn 1000ms;\n}\n\n@keyframes fadeIn {\n  0% { opacity: 0; }\n  100% { opacity: 1; }\n}",
        "useInterval",
        "export default function Counter() {\n\n  const count = useCounter();\n\n  return <h1>Seconds passed: {count}</h1>;\n\n}",
        "export default function Counter() {\n\n  const count = useCounter();\n\n  return <h1>Seconds passed: {count}</h1>;\n\n}",
        "useCounter.js",
        "import { useState, useEffect } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(c => c + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n  return <h1>Seconds passed: {count}</h1>;\n}"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 4327
    },
    {
      "url": "https://react.dev/learn/react-compiler/introduction",
      "title": "Introduction",
      "breadcrumb": [],
      "section_path": [
        "React Compiler",
        "Introduction"
      ],
      "headings": {
        "h1": [
          "Introduction"
        ],
        "h2": [
          "What does React Compiler do?",
          "Should I try out the compiler?",
          "What build tools are supported?",
          "What should I do about useMemo, useCallback, and React.memo?",
          "Try React Compiler",
          "Additional resources"
        ],
        "h3": [
          "You will learn",
          "Before React Compiler",
          "Note",
          "After React Compiler",
          "Is it safe to use?"
        ],
        "h4": [
          "What kind of memoization does React Compiler add?"
        ],
        "h5": [
          "DEEP DIVE"
        ]
      },
      "text_content": "LEARN REACT\nREACT COMPILER\nIntroduction\n\nReact Compiler is a new build-time tool that automatically optimizes your React app. It works with plain JavaScript, and understands the Rules of React, so you don‚Äôt need to rewrite any code to use it.\n\nYou will learn\nWhat React Compiler does\nGetting started with the compiler\nIncremental adoption strategies\nDebugging and troubleshooting when things go wrong\nUsing the compiler on your React library\nWhat does React Compiler do? \n\nReact Compiler automatically optimizes your React application at build time. React is often fast enough without optimization, but sometimes you need to manually memoize components and values to keep your app responsive. This manual memoization is tedious, easy to get wrong, and adds extra code to maintain. React Compiler does this optimization automatically for you, freeing you from this mental burden so you can focus on building features.\n\nBefore React Compiler \n\nWithout the compiler, you need to manually memoize components and values to optimize re-renders:\n\nimport { useMemo, useCallback, memo } from 'react';\n\nconst ExpensiveComponent = memo(function ExpensiveComponent({ data, onClick }) {\n\n const processedData = useMemo(() => {\n\n return expensiveProcessing(data);\n\n }, [data]);\n\n const handleClick = useCallback((item) => {\n\n onClick(item.id);\n\n }, [onClick]);\n\n return (\n\n <div>\n\n {processedData.map(item => (\n\n <Item key={item.id} onClick={() => handleClick(item)} />\n\n ))}\n\n </div>\n\n );\n\n});\nNote\n\nThis manual memoization has a subtle bug that breaks memoization:\n\n<Item key={item.id} onClick={() => handleClick(item)} />\n\nEven though handleClick is wrapped in useCallback, the arrow function () => handleClick(item) creates a new function every time the component renders. This means that Item will always receive a new onClick prop, breaking memoization.\n\nReact Compiler is able to optimize this correctly with or without the arrow function, ensuring that Item only re-renders when props.onClick changes.\n\nAfter React Compiler \n\nWith React Compiler, you write the same code without manual memoization:\n\nfunction ExpensiveComponent({ data, onClick }) {\n\n const processedData = expensiveProcessing(data);\n\n const handleClick = (item) => {\n\n onClick(item.id);\n\n };\n\n return (\n\n <div>\n\n {processedData.map(item => (\n\n <Item key={item.id} onClick={() => handleClick(item)} />\n\n ))}\n\n </div>\n\n );\n\n}\n\nSee this example in the React Compiler Playground\n\nReact Compiler automatically applies the optimal memoization, ensuring your app only re-renders when necessary.\n\nDEEP DIVE\nWhat kind of memoization does React Compiler add? \nShow Details\nShould I try out the compiler? \n\nWe encourage everyone to start using React Compiler. While the compiler is still an optional addition to React today, in the future some features may require the compiler in order to fully work.\n\nIs it safe to use? \n\nReact Compiler is now stable and has been tested extensively in production. While it has been used in production at companies like Meta, rolling out the compiler to production for your app will depend on the health of your codebase and how well you‚Äôve followed the Rules of React.\n\nWhat build tools are supported? \n\nReact Compiler can be installed across several build tools such as Babel, Vite, Metro, and Rsbuild.\n\nReact Compiler is primarily a light Babel plugin wrapper around the core compiler, which was designed to be decoupled from Babel itself. While the initial stable version of the compiler will remain primarily a Babel plugin, we are working with the swc and oxc teams to build first class support for React Compiler so you won‚Äôt have to add Babel back to your build pipelines in the future.\n\nNext.js users can enable the swc-invoked React Compiler by using v15.3.1 and up.\n\nWhat should I do about useMemo, useCallback, and React.memo? \n\nBy default, React Compiler will memoize your code based on its analysis and heuristics. In most cases, this memoization will be as precise, or moreso, than what you may have written.\n\nHowever, in some cases developers may need more control over memoization. The useMemo and useCallback hooks can continue to be used with React Compiler as an escape hatch to provide control over which values are memoized. A common use-case for this is if a memoized value is used as an effect dependency, in order to ensure that an effect does not fire repeatedly even when its dependencies do not meaningfully change.\n\nFor new code, we recommend relying on the compiler for memoization and using useMemo/useCallback where needed to achieve precise control.\n\nFor existing code, we recommend either leaving existing memoization in place (removing it can change compilation output) or carefully testing before removing the memoization.\n\nTry React Compiler \n\nThis section will help you get started with React Compiler and understand how to use it effectively in your projects.\n\nInstallation - Install React Compiler and configure it for your build tools\nReact Version Compatibility - Support for React 17, 18, and 19\nConfiguration - Customize the compiler for your specific needs\nIncremental Adoption - Strategies for gradually rolling out the compiler in existing codebases\nDebugging and Troubleshooting - Identify and fix issues when using the compiler\nCompiling Libraries - Best practices for shipping compiled code\nAPI Reference - Detailed documentation of all configuration options\nAdditional resources \n\nIn addition to these docs, we recommend checking the React Compiler Working Group for additional information and discussion about the compiler.\n\nPREVIOUS\nReact Compiler\nNEXT\nInstallation",
      "tables": [],
      "code_blocks": [
        "import { useMemo, useCallback, memo } from 'react';\n\n\n\nconst ExpensiveComponent = memo(function ExpensiveComponent({ data, onClick }) {\n\n  const processedData = useMemo(() => {\n\n    return expensiveProcessing(data);\n\n  }, [data]);\n\n\n\n  const handleClick = useCallback((item) => {\n\n    onClick(item.id);\n\n  }, [onClick]);\n\n\n\n  return (\n\n    <div>\n\n      {processedData.map(item => (\n\n        <Item key={item.id} onClick={() => handleClick(item)} />\n\n      ))}\n\n    </div>\n\n  );\n\n});",
        "import { useMemo, useCallback, memo } from 'react';\n\n\n\nconst ExpensiveComponent = memo(function ExpensiveComponent({ data, onClick }) {\n\n  const processedData = useMemo(() => {\n\n    return expensiveProcessing(data);\n\n  }, [data]);\n\n\n\n  const handleClick = useCallback((item) => {\n\n    onClick(item.id);\n\n  }, [onClick]);\n\n\n\n  return (\n\n    <div>\n\n      {processedData.map(item => (\n\n        <Item key={item.id} onClick={() => handleClick(item)} />\n\n      ))}\n\n    </div>\n\n  );\n\n});",
        "<Item key={item.id} onClick={() => handleClick(item)} />",
        "<Item key={item.id} onClick={() => handleClick(item)} />",
        "handleClick",
        "useCallback",
        "() => handleClick(item)",
        "props.onClick",
        "function ExpensiveComponent({ data, onClick }) {\n\n  const processedData = expensiveProcessing(data);\n\n\n\n  const handleClick = (item) => {\n\n    onClick(item.id);\n\n  };\n\n\n\n  return (\n\n    <div>\n\n      {processedData.map(item => (\n\n        <Item key={item.id} onClick={() => handleClick(item)} />\n\n      ))}\n\n    </div>\n\n  );\n\n}",
        "function ExpensiveComponent({ data, onClick }) {\n\n  const processedData = expensiveProcessing(data);\n\n\n\n  const handleClick = (item) => {\n\n    onClick(item.id);\n\n  };\n\n\n\n  return (\n\n    <div>\n\n      {processedData.map(item => (\n\n        <Item key={item.id} onClick={() => handleClick(item)} />\n\n      ))}\n\n    </div>\n\n  );\n\n}",
        "useCallback",
        "useCallback"
      ],
      "internal_links": [],
      "parent_url": "https://react.dev/learn",
      "depth": 1,
      "word_count": 843
    }
  ],
  "errors": []
}